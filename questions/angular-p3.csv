question,answer,category,difficulty,tags
What are Angular elements?,"Angular elements are Angular components packaged as custom elements (a web standard for defining new HTML elements in a framework-agnostic way). Angular Elements host an Angular component, providing a bridge between the data and the logic defined in the component and the standard DOM APIs, thus, providing a way to use Angular components in non-Angular environments.",Angular Elements,easy,angular;elements
What is the browser support of Angular Elements?,"Since Angular elements are packaged as custom elements the browser support of angular elements is same as custom elements support.
This feature is is currently supported natively in a number of browsers and pending for other browsers.
Browser	Angular Element Support
Chrome	Natively supported
Opera	Natively supported
Safari	Natively supported
Firefox	Natively supported from 63 version onwards. You need to enable dom.webcomponents.enabled and dom.webcomponents.customelements.enabled in older browsers
Edge	Currently it is in progress",Angular Elements,easy,angular;elements
What are custom elements?,"Custom elements (or Web Components) are a Web Platform feature which extends HTML by allowing you to define a tag whose content is created and controlled by JavaScript code. The browser maintains a CustomElementRegistry of defined custom elements, which maps an instantiable JavaScript class to an HTML tag. Currently this feature is supported by Chrome, Firefox, Opera, and Safari, and available in other browsers through polyfills.",Angular Elements,hard,elements
Do I need to bootstrap custom elements?,"No, custom elements bootstrap (or start) automatically when they are added to the DOM, and are automatically destroyed when removed from the DOM. Once a custom element is added to the DOM for any page, it looks and behaves like any other HTML element, and does not require any special knowledge of Angular.",Angular Elements,hard,elements
Explain how custom elements works internally?,"Below are the steps in an order about custom elements functionality,
App registers custom element with browser: Use the createCustomElement() function to convert a component into a class that can be registered with the browser as a custom element.
App adds custom element to DOM: Add custom element just like a built-in HTML element directly into the DOM.
Browser instantiate component based class: Browser creates an instance of the registered class and adds it to the DOM.
Instance provides content with data binding and change detection: The content with in template is rendered using the component and DOM data. The flow chart of the custom elements functionality would be as follows,
CustomElement",Angular Elements,hard,elements
How to transfer components to custom elements?,"Transforming components to custom elements involves two major steps,
Build custom element class: Angular provides the createCustomElement() function for converting an Angular component (along with its dependencies) to a custom element. The conversion process implements NgElementConstructor interface, and creates a constructor class which is used to produce a self-bootstrapping instance of Angular component.
Register element class with browser: It uses customElements.define() JS function, to register the configured constructor and its associated custom-element tag with the browser's CustomElementRegistry. When the browser encounters the tag for the registered element, it uses the constructor to create a custom-element instance.
The detailed structure would be as follows, CreateElement",Angular Elements,hard,component;elements
What are the mapping rules between Angular component and custom element?,"The Component properties and logic maps directly into HTML attributes and the browser's event system. Let us describe them in two steps,
The createCustomElement() API parses the component input properties with corresponding attributes for the custom element. For example, component @Input('myInputProp') converted as custom element attribute my-input-prop.
The Component outputs are dispatched as HTML Custom Events, with the name of the custom event matching the output name. For example, component @Output() valueChanged = new EventEmitter() converted as custom element with dispatch event as ""valueChanged"".",Components,easy,angular;component
How do you define typings for custom elements?,"You can use the NgElement and WithProperties types exported from @angular/elements.
Let's see how it can be applied by comparing with Angular component.
The simple container with input property would be as below,
@Component(...)
class MyContainer {
  @Input() message: string;
}
After applying types typescript validates input value and their types,
const container = document.createElement('my-container') as NgElement & WithProperties<{message: string}>;
container.message = 'Welcome to Angular elements!';
container.message = true;  // <-- ERROR: TypeScript knows this should be a string.
container.greet = 'News';  // <-- ERROR: TypeScript knows there is no `greet` property on `container`.",Angular Elements,hard,elements
What are dynamic components?,"Dynamic components are the components in which the component's location in the application is not defined at build time i.e. they are not used in any angular template. Instead, the component is instantiated and placed in the application at runtime.",Components,easy,component
What are the various kinds of directives?,"There are mainly three kinds of directives:
Components — These are directives with a template.
Structural directives — These directives change the DOM layout by adding and removing DOM elements.
Attribute directives — These directives change the appearance or behavior of an element, component, or another directive.",Directives,easy,directive;di
How do you create directives using CLI?,"You can use CLI command ng generate directive to create the directive class file. It creates the source file(src/app/components/directivename.directive.ts), the respective test file .spec.ts and declare the directive class file in root module.",Directives,easy,cli;directive;di
Give an example for attribute directives?,"Let's take simple highlighter behavior as a example directive for DOM element. You can create and apply the attribute directive using below step:
Create HighlightDirective class with the file name src/app/highlight.directive.ts. In this file, we need to import Directive from core library to apply the metadata and ElementRef in the directive's constructor to inject a reference to the host DOM element ,
import { Directive, ElementRef } from '@angular/core';
@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
    constructor(el: ElementRef) {
       el.nativeElement.style.backgroundColor = 'red';
    }
}
Apply the attribute directive as an attribute to the host element(for example,
)
<p appHighlight>Highlight me!</p>
Run the application to see the highlight behavior on paragraph element
ng serve",Directives,easy,directive;di
What is Angular Router?,Angular Router is a mechanism in which navigation happens from one view to the next as users perform application tasks. It borrows the concepts or model of browser's application navigation. It enables developers to build Single Page Applications with multiple views and allow navigation between these views.,Routing,intermediate,angular;router
What is the purpose of base href tag?,"The routing application should add element to the index.html as the first child in the tag in order to indicate how to compose navigation URLs. If app folder is the application root then you can set the href value as below
<base href=""/"">",Angular Basics,easy,angular
What are the router imports?,"The Angular Router which represents a particular component view for a given URL is not part of Angular Core. It is available in library named @angular/router to import required router components. For example, we import them in app module as below,
import { RouterModule, Routes } from '@angular/router';",Routing,intermediate,router
What is router outlet?,"The RouterOutlet is a directive from the router library and it acts as a placeholder that marks the spot in the template where the router should display the components for that outlet. Router outlet is used like a component,
<router-outlet></router-outlet>
<!-- Routed components go here -->",Routing,intermediate,router
What are router links?,"The RouterLink is a directive on the anchor tags give the router control over those elements. Since the navigation paths are fixed, you can assign string values to router-link directive as below,
<h1>Angular Router</h1>
<nav>
  <a routerLink=""/todosList"" >List of todos</a>
  <a routerLink=""/completed"" >Completed todos</a>
</nav>
<router-outlet></router-outlet>",Routing,intermediate,router
What are active router links?,"RouterLinkActive is a directive that toggles css classes for active RouterLink bindings based on the current RouterState. i.e, The Router will add CSS classes when this link is active and remove when the link is inactive. For example, you can add them to RouterLinks as below.
<h1>Angular Router</h1>
<nav>
  <a routerLink=""/todosList"" routerLinkActive=""active"">List of todos</a>
  <a routerLink=""/completed"" routerLinkActive=""active"">Completed todos</a>
</nav>
<router-outlet></router-outlet>",Routing,intermediate,router
What is router state?,"RouterState is a tree of activated routes. Every node in this tree knows about the ""consumed"" URL segments, the extracted parameters, and the resolved data. You can access the current RouterState from anywhere in the application using the Router service and the routerState property.
@Component({templateUrl:'template.html'})
class MyComponent {
  constructor(router: Router) {
    const state: RouterState = router.routerState;
    const root: ActivatedRoute = state.root;
    const child = root.firstChild;
    const id: Observable<string> = child.params.map(p => p.id);
    //...
  }
}",Routing,intermediate,router
What are router events?,"During each navigation, the Router emits navigation events through the Router.events property allowing you to track the lifecycle of the route.
The sequence of router events is as below,
NavigationStart,
RouteConfigLoadStart,
RouteConfigLoadEnd,
RoutesRecognized,
GuardsCheckStart,
ChildActivationStart,
ActivationStart,
GuardsCheckEnd,
ResolveStart,
ResolveEnd,
ActivationEnd
ChildActivationEnd
NavigationEnd,
NavigationCancel,
NavigationError
Scroll",Routing,intermediate,router
What is activated route?,"ActivatedRoute contains the information about a route associated with a component loaded in an outlet. It can also be used to traverse the router state tree. The ActivatedRoute will be injected as a router service to access the information. In the below example, you can access route path and parameters,
@Component({...})
class MyComponent {
  constructor(route: ActivatedRoute) {
    const id: Observable<string> = route.params.pipe(map(p => p.id));
    const url: Observable<string> = route.url.pipe(map(segments => segments.join('')));
    // route.data includes both `data` and `resolve`
    const user = route.data.pipe(map(d => d.user));
  }
}",Routing,easy,angular
How do you define routes?,"A router must be configured with a list of route definitions. You configures the router with routes via the RouterModule.forRoot() method, and adds the result to the AppModule's imports array.
 const appRoutes: Routes = [
  { path: 'todo/:id',      component: TodoDetailComponent },
  {
    path: 'todos',
    component: TodosListComponent,
    data: { title: 'Todos List' }
  },
  { path: '',
    redirectTo: '/todos',
    pathMatch: 'full'
  },
  { path: '**', component: PageNotFoundComponent }
];
@NgModule({
  imports: [
    RouterModule.forRoot(
      appRoutes,
      { enableTracing: true } // <-- debugging purposes only
    )
    // other imports here
  ],
  ...
})
export class AppModule { }",Routing,easy,angular
What is the purpose of Wildcard route?,"If the URL doesn't match any predefined routes then it causes the router to throw an error and crash the app. In this case, you can use wildcard route. A wildcard route has a path consisting of two asterisks to match every URL.
For example, you can define PageNotFoundComponent for wildcard route as below
{ path: '**', component: PageNotFoundComponent }",Routing,easy,angular
Do I need a Routing Module always?,"No, the Routing Module is a design choice. You can skip routing Module (for example, AppRoutingModule) when the configuration is simple and merge the routing configuration directly into the companion module (for example, AppModule). But it is recommended when the configuration is complex and includes specialized guard and resolver services.",Modules,easy,module
What is Angular Universal?,Angular Universal is a server-side rendering module for Angular applications in various scenarios. This is a community driven project and available under @angular/platform-server package. Recently Angular Universal is integrated with Angular CLI.,Angular Basics,easy,angular
What are different types of compilation in Angular?,"Angular offers two ways to compile your application,
Just-in-Time (JIT)
Ahead-of-Time (AOT)",Compilation/AOT,easy,angular;di
What is JIT?,"Just-in-Time (JIT) is a type of compilation that compiles your app in the browser at runtime. JIT compilation was the default until Angular 8, now default is AOT. When you run the ng build (build only) or ng serve (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the aot property in your build configuration specified in angular.json. By default, aot is set to true.",Compilation/AOT,hard,jit
What is AOT?,"Ahead-of-Time (AOT) is a type of compilation that compiles your app at build time. This is the default starting in Angular 9. When you run the ng build (build only) or ng serve (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the aot property in your build configuration specified in angular.json. By default, aot is set to true.
ng build
ng serve",Compilation/AOT,hard,aot
Why do we need compilation process?,"The Angular components and templates cannot be understood by the browser directly. Due to that Angular applications require a compilation process before they can run in a browser. For example, In AOT compilation, both Angular HTML and TypeScript code converted into efficient JavaScript code during the build phase before browser runs it.",Compilation/AOT,easy,angular
What are the advantages with AOT?,"Below are the list of AOT benefits,
Faster rendering: The browser downloads a pre-compiled version of the application. So it can render the application immediately without compiling the app.
Fewer asynchronous requests: It inlines external HTML templates and CSS style sheets within the application javascript which eliminates separate ajax requests.
Smaller Angular framework download size: Doesn't require downloading the Angular compiler. Hence it dramatically reduces the application payload.
Detect template errors earlier: Detects and reports template binding errors during the build step itself
Better security: It compiles HTML templates and components into JavaScript. So there won't be any injection attacks.",Compilation/AOT,hard,aot
What are the ways to control AOT compilation?,"You can control your app compilation in two ways,
By providing template compiler options in the tsconfig.json file
By configuring Angular metadata with decorators",Compilation/AOT,hard,aot
What are the restrictions of metadata?,"In Angular, You must write metadata with the following general constraints,
Write expression syntax with in the supported range of javascript features
The compiler can only reference symbols which are exported
Only call the functions supported by the compiler
Decorated and data-bound class members must be public.",Compilation/AOT,hard,angular
What are the three phases of AOT?,"The AOT compiler works in three phases,
Code Analysis: The compiler records a representation of the source
Code generation: It handles the interpretation as well as places restrictions on what it interprets.
Validation: In this phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.",Compilation/AOT,hard,aot
Can I use arrow functions in AOT?,"No, Arrow functions or lambda functions can’t be used to assign values to the decorator properties. For example, the following snippet is invalid:
@Component({
  providers: [{
    provide: MyService, useFactory: () => getService()
  }]
})
To fix this, it has to be changed as following exported function:
function getService(){
  return new MyService();
}
@Component({
  providers: [{
    provide: MyService, useFactory: getService
  }]
})
If you still use arrow function, it generates an error node in place of the function. When the compiler later interprets this node, it reports an error to turn the arrow function into an exported function. Note: From Angular5 onwards, the compiler automatically performs this rewriting while emitting the .js file.",Compilation/AOT,hard,aot
What is the purpose of metadata json files?,"The metadata.json file can be treated as a diagram of the overall structure of a decorator's metadata, represented as an abstract syntax tree(AST). During the analysis phase, the AOT collector scan the metadata recorded in the Angular decorators and outputs metadata information in .metadata.json files, one per .d.ts file.",Compilation/AOT,hard,angular
Can I use any javascript feature for expression syntax in AOT?,"No, the AOT collector understands a subset of (or limited) JavaScript features. If an expression uses unsupported syntax, the collector writes an error node to the .metadata.json file. Later point of time, the compiler reports an error if it needs that piece of metadata to generate the application code.",Compilation/AOT,hard,aot
What is folding?,"The compiler can only resolve references to exported symbols in the metadata. Where as some of the non-exported members are folded while generating the code. i.e Folding is a process in which the collector evaluate an expression during collection and record the result in the .metadata.json instead of the original expression. For example, the compiler couldn't refer selector reference because it is not exported
let selector = 'app-root';
@Component({
  selector: selector
})
Will be folded into inline selector
@Component({
      selector: 'app-root'
    })
Remember that the compiler can’t fold everything. For example, spread operator on arrays, objects created using new keywords and function calls.",Angular Basics,hard,di
What are macros?,"The AOT compiler supports macros in the form of functions or static methods that return an expression in a single return expression. For example, let us take a below macro function,
export function wrapInArray<T>(value: T): T[] {
  return [value];
}
You can use it inside metadata as an expression,
@NgModule({
  declarations: wrapInArray(TypicalComponent)
})
export class TypicalModule {}
The compiler treats the macro expression as it written directly
@NgModule({
  declarations: [TypicalComponent]
})
export class TypicalModule {}",Angular Basics,hard,angular
Give an example of few metadata errors?,"Below are some of the errors encountered in metadata,
Expression form not supported: Some of the language features outside of the compiler's restricted expression syntax used in angular metadata can produce this error. Let's see some of these examples,
1. export class User { ... }
   const prop = typeof User; // typeof is not valid in metadata
2. { provide: 'token', useValue: { [prop]: 'value' } }; // bracket notation is not valid in metadata
Reference to a local (non-exported) symbol: The compiler encountered a referenced to a locally defined symbol that either wasn't exported or wasn't initialized. Let's take example of this error,
// ERROR
let username: string; // neither exported nor initialized
@Component({
  selector: 'my-component',
  template: ... ,
  providers: [
    { provide: User, useValue: username }
  ]
})
export class MyComponent {}
You can fix this by either exporting or initializing the value,
export let username: string; // exported
(or)
let username = 'John'; // initialized
Function calls are not supported: The compiler does not currently support function expressions or lambda functions. For example, you cannot set a provider's useFactory to an anonymous function or arrow function as below.
 providers: [
    { provide: MyStrategy, useFactory: function() { ... } },
    { provide: OtherStrategy, useFactory: () => { ... } }
  ]
You can fix this with exported function
export function myStrategy() { ... }
export function otherStrategy() { ... }
... // metadata
providers: [
    { provide: MyStrategy, useFactory: myStrategy },
    { provide: OtherStrategy, useFactory: otherStrategy },
Destructured variable or constant not supported: The compiler does not support references to variables assigned by destructuring. For example, you cannot write something like this:
import { user } from './user';
// destructured assignment to name and age
const {name, age} = user;
... //metadata
providers: [
    {provide: Name, useValue: name},
    {provide: Age, useValue: age},
  ]
You can fix this by non-destructured values
import { user } from './user';
... //metadata
providers: [
    {provide: Name, useValue: user.name},
    {provide: Age, useValue: user.age},
  ]",Compilation/AOT,hard,angular
What is metadata rewriting?,"Metadata rewriting is the process in which the compiler converts the expression initializing the fields such as useClass, useValue, useFactory, and data into an exported variable, which replaces the expression. Remember that the compiler does this rewriting during the emit of the .js file but not in definition files( .d.ts file).",Compilation/AOT,hard,angular
How do you provide configuration inheritance?,"Angular Compiler supports configuration inheritance through extends in the tsconfig.json on angularCompilerOptions. i.e, The configuration from the base file(for example, tsconfig.base.json) are loaded first, then overridden by those in the inheriting config file.
{
  ""extends"": ""../tsconfig.base.json"",
  ""compilerOptions"": {
    ""experimentalDecorators"": true,
    ...
  },
  ""angularCompilerOptions"": {
    ""fullTemplateTypeCheck"": true,
    ""preserveWhitespaces"": true,
    ...
  }
}",Angular Basics,hard,angular
How do you specify angular template compiler options?,"The angular template compiler options are specified as members of the angularCompilerOptions object in the tsconfig.json file. These options will be specified adjacent to typescript compiler options.
{
  ""compilerOptions"": {
    ""experimentalDecorators"": true,
              ...
  },
  ""angularCompilerOptions"": {
    ""fullTemplateTypeCheck"": true,
    ""preserveWhitespaces"": true,
              ...
  }
}",Compilation/AOT,easy,angular;template
How do you enable binding expression validation?,"You can enable binding expression validation explicitly by adding the compiler option fullTemplateTypeCheck in the ""angularCompilerOptions"" of the project's tsconfig.json. It produces error messages when a type error is detected in a template binding expression.
For example, consider the following component:
@Component({
  selector: 'my-component',
  template: '{{user.contacts.email}}'
})
class MyComponent {
  user?: User;
}
This will produce the following error:
my.component.ts.MyComponent.html(1,1): : Property 'contacts' does not exist on type 'User'. Did you mean 'contact'?",Angular Basics,hard,binding;di
What is the purpose of any type cast function?,"You can disable binding expression type checking using $any() type cast function(by surrounding the expression). In the following example, the error Property contacts does not exist is suppressed by casting user to the any type.
  template:
  '{{ $any(user).contacts.email }}'
The $any() cast function also works with this to allow access to undeclared members of the component.
   template:
   '{{ $any(this).contacts.email }}'",Angular Basics,easy,angular
What is Non null type assertion operator?,"You can use the non-null type assertion operator to suppress the Object is possibly 'undefined' error. In the following example, the user and contact properties are always set together, implying that contact is always non-null if user is non-null. The error is suppressed in the example by using contact!.email.
@Component({
  selector: 'my-component',
  template: '<span *ngIf=""user""> {{user.name}} contacted through {{contact!.email}} </span>'
})
class MyComponent {
  user?: User;
  contact?: Contact;
  setData(user: User, contact: Contact) {
    this.user = user;
    this.contact = contact;
  }
}",Angular Basics,easy,angular
How is type narrowing applied in templates?,"The expression used in an ngIf directive is used to narrow type unions in the Angular template compiler similar to if expression in typescript. So *ngIf allows the typeScript compiler to infer that the data used in the binding expression will never be undefined.
@Component({
  selector: 'my-component',
  template: '<span *ngIf=""user""> {{user.contact.email}} </span>'
})
class MyComponent {
  user?: User;
}",Templates,easy,template
How do you describe various dependencies in angular application?,"The dependencies section of package.json with in an angular application can be divided as follow,
Angular packages: Angular core and optional modules; their package names begin @angular/.
Support packages: Third-party libraries that must be present for Angular apps to run.
Polyfill packages: Polyfills plug gaps in a browser's JavaScript implementation.",Angular Basics,easy,angular
What is zone?,A Zone is an execution context that persists across async tasks. Angular relies on zone.js to run Angular's change detection processes when native JavaScript operations raise events,Dependency Injection,intermediate,zone
What is the purpose of common module?,"The commonly-needed services, pipes, and directives provided by @angular/common module. Apart from these HttpClientModule is available under @angular/common/http.",Modules,easy,module
What is codelyzer?,"Codelyzer provides set of tslint rules for static code analysis of Angular TypeScript projects. You can run the static code analyzer over web apps, NativeScript, Ionic etc. Angular CLI has support for this and it can be use as below,
ng new codelyzer
ng lint",Tooling,easy,angular
