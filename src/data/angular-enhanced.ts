// Angular Interview Questions - Senior-Level (Angular 16-19)
// Comprehensive answers designed for technical interview preparation
// Covers: Interceptors, RxJS, Observables, NgRx, Change Detection, Signals, and more

export interface QA {
  id: number;
  question: string;
  answer: string;
  category?: string;
  difficulty?: string;
  tags?: string[];
}

export const ANGULAR_ENHANCED_QUESTIONS: QA[] = [
  {
    id: 1,
    question:
      "What are HTTP Interceptors in Angular? Explain common use cases with detailed examples.",
    answer:
      "HTTP Interceptors are services that intercept and modify HTTP requests and responses globally in your Angular application.\n\n" +
      "**How Interceptors Work:**\n\n" +
      "Interceptors sit between your application and the HTTP backend:\n" +
      "```\n" +
      "Component → HttpClient → Interceptor Chain → Backend\n" +
      "Component ← HttpClient ← Interceptor Chain ← Backend\n" +
      "```\n\n" +
      "**Creating an Interceptor:**\n\n" +
      "```typescript\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';\n" +
      "import { Observable } from 'rxjs';\n\n" +
      "@Injectable()\n" +
      "export class AuthInterceptor implements HttpInterceptor {\n" +
      "  intercept(req: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n" +
      "    // Clone and modify request\n" +
      "    const authReq = req.clone({\n" +
      "      setHeaders: {\n" +
      "        Authorization: `Bearer ${this.getToken()}`\n" +
      "      }\n" +
      "    });\n\n" +
      "    // Pass to next interceptor or backend\n" +
      "    return next.handle(authReq);\n" +
      "  }\n\n" +
      "  private getToken(): string {\n" +
      "    return localStorage.getItem('token') || '';\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Registering Interceptors (Angular 15+):**\n\n" +
      "```typescript\n" +
      "// main.ts or app.config.ts\n" +
      "import { provideHttpClient, withInterceptors } from '@angular/common/http';\n\n" +
      "export const appConfig: ApplicationConfig = {\n" +
      "  providers: [\n" +
      "    provideHttpClient(\n" +
      "      withInterceptors([authInterceptor, loggingInterceptor])\n" +
      "    )\n" +
      "  ]\n" +
      "};\n\n" +
      "// Functional interceptor (Angular 15+)\n" +
      "export const authInterceptor: HttpInterceptorFn = (req, next) => {\n" +
      "  const token = inject(AuthService).getToken();\n" +
      "  \n" +
      "  const authReq = req.clone({\n" +
      "    setHeaders: { Authorization: `Bearer ${token}` }\n" +
      "  });\n" +
      "  \n" +
      "  return next(authReq);\n" +
      "};\n" +
      "```\n\n" +
      "**Legacy Registration (Angular <15):**\n\n" +
      "```typescript\n" +
      "// app.module.ts\n" +
      "import { HTTP_INTERCEPTORS } from '@angular/common/http';\n\n" +
      "@NgModule({\n" +
      "  providers: [\n" +
      "    {\n" +
      "      provide: HTTP_INTERCEPTORS,\n" +
      "      useClass: AuthInterceptor,\n" +
      "      multi: true // Important! Allows multiple interceptors\n" +
      "    }\n" +
      "  ]\n" +
      "})\n" +
      "```\n\n" +
      "**Common Use Cases:**\n\n" +
      "**1. Authentication (Add JWT Token):**\n\n" +
      "```typescript\n" +
      "@Injectable()\n" +
      "export class AuthInterceptor implements HttpInterceptor {\n" +
      "  constructor(private authService: AuthService) {}\n\n" +
      "  intercept(req: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n" +
      "    // Skip for login/register endpoints\n" +
      "    if (req.url.includes('/auth/')) {\n" +
      "      return next.handle(req);\n" +
      "    }\n\n" +
      "    const token = this.authService.getToken();\n" +
      "    \n" +
      "    if (token) {\n" +
      "      const cloned = req.clone({\n" +
      "        setHeaders: {\n" +
      "          Authorization: `Bearer ${token}`\n" +
      "        }\n" +
      "      });\n" +
      "      return next.handle(cloned);\n" +
      "    }\n\n" +
      "    return next.handle(req);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**2. Error Handling & Retry:**\n\n" +
      "```typescript\n" +
      "import { catchError, retry, throwError } from 'rxjs';\n\n" +
      "@Injectable()\n" +
      "export class ErrorInterceptor implements HttpInterceptor {\n" +
      "  constructor(\n" +
      "    private router: Router,\n" +
      "    private toastr: ToastrService\n" +
      "  ) {}\n\n" +
      "  intercept(req: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n" +
      "    return next.handle(req).pipe(\n" +
      "      retry(2), // Retry failed requests twice\n" +
      "      catchError((error: HttpErrorResponse) => {\n" +
      "        if (error.status === 401) {\n" +
      "          // Unauthorized - redirect to login\n" +
      "          this.router.navigate(['/login']);\n" +
      "        } else if (error.status === 403) {\n" +
      "          this.toastr.error('Access denied');\n" +
      "        } else if (error.status === 500) {\n" +
      "          this.toastr.error('Server error. Please try again later.');\n" +
      "        }\n\n" +
      "        return throwError(() => error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. Logging & Monitoring:**\n\n" +
      "```typescript\n" +
      "import { tap, finalize } from 'rxjs/operators';\n\n" +
      "@Injectable()\n" +
      "export class LoggingInterceptor implements HttpInterceptor {\n" +
      "  intercept(req: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n" +
      "    const started = Date.now();\n" +
      "    console.log(`[HTTP] ${req.method} ${req.url}`);\n\n" +
      "    return next.handle(req).pipe(\n" +
      "      tap(\n" +
      "        event => {\n" +
      "          if (event instanceof HttpResponse) {\n" +
      "            const elapsed = Date.now() - started;\n" +
      "            console.log(`[HTTP] ${req.method} ${req.url} - ${event.status} in ${elapsed}ms`);\n" +
      "          }\n" +
      "        }\n" +
      "      ),\n" +
      "      finalize(() => {\n" +
      "        console.log(`[HTTP] ${req.method} ${req.url} completed`);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**4. Loading Indicator:**\n\n" +
      "```typescript\n" +
      "@Injectable()\n" +
      "export class LoadingInterceptor implements HttpInterceptor {\n" +
      "  constructor(private loadingService: LoadingService) {}\n\n" +
      "  intercept(req: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n" +
      "    this.loadingService.show();\n\n" +
      "    return next.handle(req).pipe(\n" +
      "      finalize(() => this.loadingService.hide())\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**5. Caching:**\n\n" +
      "```typescript\n" +
      "@Injectable()\n" +
      "export class CacheInterceptor implements HttpInterceptor {\n" +
      "  private cache = new Map<string, HttpResponse<unknown>>();\n\n" +
      "  intercept(req: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n" +
      "    // Only cache GET requests\n" +
      "    if (req.method !== 'GET') {\n" +
      "      return next.handle(req);\n" +
      "    }\n\n" +
      "    // Check cache\n" +
      "    const cachedResponse = this.cache.get(req.url);\n" +
      "    if (cachedResponse) {\n" +
      "      return of(cachedResponse.clone());\n" +
      "    }\n\n" +
      "    // Cache response\n" +
      "    return next.handle(req).pipe(\n" +
      "      tap(event => {\n" +
      "        if (event instanceof HttpResponse) {\n" +
      "          this.cache.set(req.url, event.clone());\n" +
      "        }\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**6. Request/Response Transformation:**\n\n" +
      "```typescript\n" +
      "@Injectable()\n" +
      "export class ApiInterceptor implements HttpInterceptor {\n" +
      "  intercept(req: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n" +
      "    // Add API prefix\n" +
      "    const apiReq = req.clone({\n" +
      "      url: `https://api.myapp.com${req.url}`,\n" +
      "      setHeaders: {\n" +
      "        'Content-Type': 'application/json',\n" +
      "        'X-API-Version': '2.0'\n" +
      "      }\n" +
      "    });\n\n" +
      "    return next.handle(apiReq).pipe(\n" +
      "      map(event => {\n" +
      "        if (event instanceof HttpResponse) {\n" +
      "          // Transform response data\n" +
      "          return event.clone({\n" +
      "            body: this.transformResponse(event.body)\n" +
      "          });\n" +
      "        }\n" +
      "        return event;\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**7. Token Refresh:**\n\n" +
      "```typescript\n" +
      "@Injectable()\n" +
      "export class TokenInterceptor implements HttpInterceptor {\n" +
      "  private isRefreshing = false;\n" +
      "  private refreshTokenSubject = new BehaviorSubject<string | null>(null);\n\n" +
      "  constructor(\n" +
      "    private authService: AuthService,\n" +
      "    private router: Router\n" +
      "  ) {}\n\n" +
      "  intercept(req: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n" +
      "    const token = this.authService.getAccessToken();\n\n" +
      "    if (token) {\n" +
      "      req = this.addToken(req, token);\n" +
      "    }\n\n" +
      "    return next.handle(req).pipe(\n" +
      "      catchError(error => {\n" +
      "        if (error.status === 401 && !req.url.includes('/refresh')) {\n" +
      "          return this.handle401Error(req, next);\n" +
      "        }\n" +
      "        return throwError(() => error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n\n" +
      "  private handle401Error(req: HttpRequest<unknown>, next: HttpHandler) {\n" +
      "    if (!this.isRefreshing) {\n" +
      "      this.isRefreshing = true;\n" +
      "      this.refreshTokenSubject.next(null);\n\n" +
      "      return this.authService.refreshToken().pipe(\n" +
      "        switchMap((token: string) => {\n" +
      "          this.isRefreshing = false;\n" +
      "          this.refreshTokenSubject.next(token);\n" +
      "          return next.handle(this.addToken(req, token));\n" +
      "        }),\n" +
      "        catchError(err => {\n" +
      "          this.isRefreshing = false;\n" +
      "          this.authService.logout();\n" +
      "          return throwError(() => err);\n" +
      "        })\n" +
      "      );\n" +
      "    } else {\n" +
      "      // Wait for token refresh\n" +
      "      return this.refreshTokenSubject.pipe(\n" +
      "        filter(token => token !== null),\n" +
      "        take(1),\n" +
      "        switchMap(token => next.handle(this.addToken(req, token)))\n" +
      "      );\n" +
      "    }\n" +
      "  }\n\n" +
      "  private addToken(req: HttpRequest<unknown>, token: string): HttpRequest<unknown> {\n" +
      "    return req.clone({\n" +
      "      setHeaders: { Authorization: `Bearer ${token}` }\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices:**\n\n" +
      "1. **Immutability:** Always clone requests (they're immutable)\n" +
      "2. **Order Matters:** Interceptors execute in registration order\n" +
      "3. **Error Handling:** Use catchError to handle errors gracefully\n" +
      "4. **Skip Interceptors:** Use HttpBackend for requests that should skip interceptors\n" +
      "5. **Testing:** Mock interceptors in tests using HttpTestingController",
    category: "HTTP",
    difficulty: "hard",
    tags: ["interceptors", "http", "auth", "error-handling", "rxjs"],
  },
  {
    id: 2,
    question: "Explain Observables in Angular/RxJS. How do they differ from Promises?",
    answer:
      "Observables are lazy, cancellable streams that can emit multiple values over time, unlike Promises which are eager and emit one value.\n\n" +
      "**Observable Basics:**\n\n" +
      "```typescript\n" +
      "import { Observable } from 'rxjs';\n\n" +
      "// Create an observable\n" +
      "const observable = new Observable<number>(subscriber => {\n" +
      "  console.log('Observable started');\n" +
      "  subscriber.next(1);\n" +
      "  subscriber.next(2);\n" +
      "  subscriber.next(3);\n" +
      "  subscriber.complete();\n" +
      "  \n" +
      "  // Cleanup function\n" +
      "  return () => {\n" +
      "    console.log('Observable cleaned up');\n" +
      "  };\n" +
      "});\n\n" +
      "// Subscribe to receive values\n" +
      "const subscription = observable.subscribe({\n" +
      "  next: (value) => console.log('Received:', value),\n" +
      "  error: (err) => console.error('Error:', err),\n" +
      "  complete: () => console.log('Complete')\n" +
      "});\n\n" +
      "// Unsubscribe to cancel\n" +
      "subscription.unsubscribe();\n" +
      "```\n\n" +
      "**Observable vs Promise:**\n\n" +
      "| Feature | Observable | Promise |\n" +
      "|---------|-----------|--------|\n" +
      "| Execution | Lazy (starts on subscribe) | Eager (starts immediately) |\n" +
      "| Values | Multiple (stream) | Single value |\n" +
      "| Cancellation | Yes (unsubscribe) | No |\n" +
      "| Operators | Rich (map, filter, etc.) | Limited (then, catch) |\n" +
      "| Push/Pull | Push (producer decides) | Push (one value) |\n\n" +
      "**Comparison Example:**\n\n" +
      "```typescript\n" +
      "// Promise - Executes immediately\n" +
      "const promise = fetch('/api/data').then(res => res.json());\n" +
      "console.log('Promise created');\n" +
      "// Output: 'Promise created' (fetch already running)\n\n" +
      "// Observable - Lazy (doesn't execute until subscribe)\n" +
      "const observable = new Observable(subscriber => {\n" +
      "  console.log('Fetching...');\n" +
      "  fetch('/api/data')\n" +
      "    .then(res => res.json())\n" +
      "    .then(data => {\n" +
      "      subscriber.next(data);\n" +
      "      subscriber.complete();\n" +
      "    });\n" +
      "});\n\n" +
      "console.log('Observable created');\n" +
      "// Output: 'Observable created' (NO fetch yet)\n\n" +
      "observable.subscribe(data => console.log(data));\n" +
      "// NOW Output: 'Fetching...'\n" +
      "```\n\n" +
      "**Multiple Values:**\n\n" +
      "```typescript\n" +
      "// Promise - Single value\n" +
      "const promise = Promise.resolve(1);\n" +
      "promise.then(val => console.log(val)); // 1\n" +
      "// Can't emit more values\n\n" +
      "// Observable - Multiple values\n" +
      "const observable = new Observable(subscriber => {\n" +
      "  subscriber.next(1);\n" +
      "  subscriber.next(2);\n" +
      "  subscriber.next(3);\n" +
      "});\n\n" +
      "observable.subscribe(val => console.log(val));\n" +
      "// Output: 1, 2, 3\n" +
      "```\n\n" +
      "**Cancellation:**\n\n" +
      "```typescript\n" +
      "// Promise - Cannot cancel\n" +
      "const promise = longRunningOperation();\n" +
      "// No way to cancel it!\n\n" +
      "// Observable - Cancellable\n" +
      "const subscription = observable.subscribe(...);\n" +
      "subscription.unsubscribe(); // Stops execution, runs cleanup\n" +
      "```\n\n" +
      "**Common Operators:**\n\n" +
      "```typescript\n" +
      "import { of, interval } from 'rxjs';\n" +
      "import { map, filter, take, debounceTime, switchMap } from 'rxjs/operators';\n\n" +
      "// map - Transform values\n" +
      "of(1, 2, 3).pipe(\n" +
      "  map(x => x * 2)\n" +
      ").subscribe(console.log); // 2, 4, 6\n\n" +
      "// filter - Filter values\n" +
      "of(1, 2, 3, 4).pipe(\n" +
      "  filter(x => x % 2 === 0)\n" +
      ").subscribe(console.log); // 2, 4\n\n" +
      "// take - Limit emissions\n" +
      "interval(1000).pipe(\n" +
      "  take(3)\n" +
      ").subscribe(console.log); // 0, 1, 2, then complete\n\n" +
      "// debounceTime - Wait for pause in emissions\n" +
      "searchInput.valueChanges.pipe(\n" +
      "  debounceTime(300), // Wait 300ms after last keystroke\n" +
      "  switchMap(query => this.searchService.search(query))\n" +
      ").subscribe(results => this.results = results);\n" +
      "```\n\n" +
      "**Angular Integration:**\n\n" +
      "```typescript\n" +
      "// HttpClient returns Observables\n" +
      "@Component({...})\n" +
      "export class UserComponent implements OnInit, OnDestroy {\n" +
      "  users$: Observable<User[]>;\n" +
      "  private subscription = new Subscription();\n\n" +
      "  constructor(private http: HttpClient) {}\n\n" +
      "  ngOnInit() {\n" +
      "    // Method 1: Subscribe in component\n" +
      "    this.subscription.add(\n" +
      "      this.http.get<User[]>('/api/users').subscribe({\n" +
      "        next: users => this.users = users,\n" +
      "        error: err => console.error(err)\n" +
      "      })\n" +
      "    );\n\n" +
      "    // Method 2: Use async pipe (better!)\n" +
      "    this.users$ = this.http.get<User[]>('/api/users');\n" +
      "  }\n\n" +
      "  ngOnDestroy() {\n" +
      "    this.subscription.unsubscribe(); // Prevent memory leaks\n" +
      "  }\n" +
      "}\n\n" +
      "// Template with async pipe\n" +
      '<div *ngFor="let user of users$ | async">\n' +
      "  {{ user.name }}\n" +
      "</div>\n" +
      "// async pipe auto-subscribes and auto-unsubscribes!\n" +
      "```\n\n" +
      "**Key Takeaway:** Observables are perfect for async streams (HTTP, events, websockets). They're lazy, cancellable, and composable with operators. Always unsubscribe to prevent memory leaks (or use async pipe).",
    category: "RxJS",
    difficulty: "hard",
    tags: ["observables", "rxjs", "async", "streams", "fundamentals"],
  },
  {
    id: 3,
    question:
      "Explain RxJS Subjects. What are the differences between Subject, BehaviorSubject, ReplaySubject, and AsyncSubject?",
    answer:
      "Subjects are special Observables that can multicast to multiple observers AND allow you to manually emit values.\n\n" +
      "**Observable vs Subject:**\n\n" +
      "```typescript\n" +
      "// Regular Observable - Unicast (separate execution per subscriber)\n" +
      "const observable = new Observable(subscriber => {\n" +
      "  console.log('Execution!');\n" +
      "  subscriber.next(Math.random());\n" +
      "});\n\n" +
      "observable.subscribe(val => console.log('Sub 1:', val));\n" +
      "observable.subscribe(val => console.log('Sub 2:', val));\n" +
      "// Output:\n" +
      "// 'Execution!'\n" +
      "// 'Sub 1: 0.123'\n" +
      "// 'Execution!'\n" +
      "// 'Sub 2: 0.456'\n" +
      "// Different values! (separate executions)\n\n" +
      "// Subject - Multicast (shared execution)\n" +
      "const subject = new Subject<number>();\n\n" +
      "subject.subscribe(val => console.log('Sub 1:', val));\n" +
      "subject.subscribe(val => console.log('Sub 2:', val));\n\n" +
      "subject.next(0.789);\n" +
      "// Output:\n" +
      "// 'Sub 1: 0.789'\n" +
      "// 'Sub 2: 0.789'\n" +
      "// Same value! (shared execution)\n" +
      "```\n\n" +
      "**1. Subject (Basic):**\n\n" +
      "No initial value. New subscribers only get future emissions.\n\n" +
      "```typescript\n" +
      "import { Subject } from 'rxjs';\n\n" +
      "const subject = new Subject<string>();\n\n" +
      "subject.subscribe(val => console.log('Sub 1:', val));\n" +
      "subject.next('A'); // Sub 1: A\n\n" +
      "subject.subscribe(val => console.log('Sub 2:', val));\n" +
      "subject.next('B'); // Sub 1: B, Sub 2: B\n\n" +
      "// Sub 2 never receives 'A' (it was emitted before subscription)\n" +
      "```\n\n" +
      "**Use Case:** Event bus, notifications\n\n" +
      "```typescript\n" +
      "// Notification service\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class NotificationService {\n" +
      "  private notificationSubject = new Subject<Notification>();\n" +
      "  notifications$ = this.notificationSubject.asObservable();\n\n" +
      "  show(message: string, type: 'success' | 'error') {\n" +
      "    this.notificationSubject.next({ message, type });\n" +
      "  }\n" +
      "}\n\n" +
      "// In component\n" +
      "this.notificationService.notifications$.subscribe(notif => {\n" +
      "  this.showToast(notif);\n" +
      "});\n" +
      "```\n\n" +
      "**2. BehaviorSubject:**\n\n" +
      "Requires initial value. New subscribers immediately receive current/last value.\n\n" +
      "```typescript\n" +
      "import { BehaviorSubject } from 'rxjs';\n\n" +
      "const subject = new BehaviorSubject<string>('Initial');\n\n" +
      "subject.subscribe(val => console.log('Sub 1:', val));\n" +
      "// Sub 1: Initial (receives immediately!)\n\n" +
      "subject.next('A'); // Sub 1: A\n\n" +
      "subject.subscribe(val => console.log('Sub 2:', val));\n" +
      "// Sub 2: A (receives current value immediately)\n\n" +
      "subject.next('B'); // Sub 1: B, Sub 2: B\n\n" +
      "// Get current value synchronously\n" +
      "console.log(subject.getValue()); // 'B'\n" +
      "```\n\n" +
      "**Use Case:** Shared state, current user, theme\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class AuthService {\n" +
      "  private currentUserSubject = new BehaviorSubject<User | null>(null);\n" +
      "  currentUser$ = this.currentUserSubject.asObservable();\n\n" +
      "  constructor() {\n" +
      "    // Initialize from localStorage\n" +
      "    const user = this.getUserFromStorage();\n" +
      "    this.currentUserSubject.next(user);\n" +
      "  }\n\n" +
      "  login(credentials: Credentials) {\n" +
      "    return this.http.post<User>('/api/login', credentials).pipe(\n" +
      "      tap(user => this.currentUserSubject.next(user))\n" +
      "    );\n" +
      "  }\n\n" +
      "  logout() {\n" +
      "    this.currentUserSubject.next(null);\n" +
      "  }\n\n" +
      "  // Synchronous access to current value\n" +
      "  get currentUserValue(): User | null {\n" +
      "    return this.currentUserSubject.getValue();\n" +
      "  }\n" +
      "}\n\n" +
      "// In component - always has current user\n" +
      "this.authService.currentUser$.subscribe(user => {\n" +
      "  this.user = user; // Receives immediately if user exists\n" +
      "});\n" +
      "```\n\n" +
      "**3. ReplaySubject:**\n\n" +
      "Buffers N previous values. New subscribers receive buffered values.\n\n" +
      "```typescript\n" +
      "import { ReplaySubject } from 'rxjs';\n\n" +
      "// Buffer last 3 values\n" +
      "const subject = new ReplaySubject<string>(3);\n\n" +
      "subject.next('A');\n" +
      "subject.next('B');\n" +
      "subject.next('C');\n" +
      "subject.next('D');\n\n" +
      "subject.subscribe(val => console.log('Sub 1:', val));\n" +
      "// Sub 1: B (oldest in buffer)\n" +
      "// Sub 1: C\n" +
      "// Sub 1: D (newest)\n\n" +
      "subject.next('E');\n" +
      "// Sub 1: E\n\n" +
      "subject.subscribe(val => console.log('Sub 2:', val));\n" +
      "// Sub 2: C\n" +
      "// Sub 2: D\n" +
      "// Sub 2: E\n" +
      "```\n\n" +
      "**Time Window:**\n" +
      "```typescript\n" +
      "// Replay values from last 500ms\n" +
      "const subject = new ReplaySubject<string>(100, 500);\n" +
      "```\n\n" +
      "**Use Case:** Activity log, chat history\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class ActivityService {\n" +
      "  // Keep last 10 activities\n" +
      "  private activitySubject = new ReplaySubject<Activity>(10);\n" +
      "  activities$ = this.activitySubject.asObservable();\n\n" +
      "  logActivity(activity: Activity) {\n" +
      "    this.activitySubject.next(activity);\n" +
      "  }\n" +
      "}\n\n" +
      "// Late subscriber gets last 10 activities immediately\n" +
      "```\n\n" +
      "**4. AsyncSubject:**\n\n" +
      "Emits only the last value when complete.\n\n" +
      "```typescript\n" +
      "import { AsyncSubject } from 'rxjs';\n\n" +
      "const subject = new AsyncSubject<string>();\n\n" +
      "subject.subscribe(val => console.log('Sub 1:', val));\n\n" +
      "subject.next('A');\n" +
      "subject.next('B');\n" +
      "subject.next('C');\n" +
      "// Nothing logged yet!\n\n" +
      "subject.complete();\n" +
      "// Sub 1: C (only last value before complete)\n\n" +
      "subject.subscribe(val => console.log('Sub 2:', val));\n" +
      "// Sub 2: C (immediately receives last value)\n" +
      "```\n\n" +
      "**Use Case:** Final result of async operation\n\n" +
      "**Comparison Table:**\n\n" +
      "| Type | Initial Value | Emissions | Use Case |\n" +
      "|------|--------------|-----------|----------|\n" +
      "| Subject | None | Future only | Events, messages |\n" +
      "| BehaviorSubject | Required | Current + future | State, current user |\n" +
      "| ReplaySubject | None | Buffer + future | History, audit log |\n" +
      "| AsyncSubject | None | Last value only | Final result |\n\n" +
      "**Common Patterns:**\n\n" +
      "```typescript\n" +
      "// Private Subject, public Observable\n" +
      "export class DataService {\n" +
      "  private dataSubject = new BehaviorSubject<Data>(initialData);\n" +
      "  data$ = this.dataSubject.asObservable(); // Read-only\n\n" +
      "  // Only service can emit\n" +
      "  updateData(data: Data) {\n" +
      "    this.dataSubject.next(data);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Memory Leaks:**\n\n" +
      "```typescript\n" +
      "// ❌ Leak - never completes, subscribers accumulate\n" +
      "private subject = new Subject<string>();\n\n" +
      "ngOnInit() {\n" +
      "  this.subject.subscribe(...); // Leak if component destroyed\n" +
      "}\n\n" +
      "// ✅ Complete on destroy\n" +
      "ngOnDestroy() {\n" +
      "  this.subject.complete(); // Unsubscribes all observers\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices:**\n" +
      "1. Use BehaviorSubject for state management\n" +
      "2. Expose as Observable (not Subject)\n" +
      "3. Complete subjects in ngOnDestroy\n" +
      "4. Use async pipe when possible (auto-unsubscribe)\n" +
      "5. Prefer Subject over EventEmitter in services",
    category: "RxJS",
    difficulty: "hard",
    tags: ["subject", "behaviorsubject", "replaysubject", "rxjs", "state-management", "multicast"],
  },
  {
    id: 4,
    question:
      "Explain Angular's Change Detection mechanism. How does it work and how can you optimize it?",
    answer:
      "Change Detection is Angular's mechanism for synchronizing the component tree with the DOM when data changes.\n\n" +
      "**How Change Detection Works:**\n\n" +
      "**1. Zone.js (Default Strategy):**\n\n" +
      "Zone.js patches async operations and triggers change detection automatically:\n" +
      "```typescript\n" +
      "// These trigger change detection:\n" +
      "- DOM events (click, input, etc.)\n" +
      "- setTimeout / setInterval\n" +
      "- HTTP requests\n" +
      "- Promises\n" +
      "- RxJS observables (with async pipe)\n" +
      "```\n\n" +
      "**Change Detection Flow:**\n\n" +
      "```\n" +
      "1. Event occurs (e.g., button click)\n" +
      "2. Zone.js notifies Angular\n" +
      "3. Angular runs change detection from root\n" +
      "4. Checks each component's bindings\n" +
      "5. Updates DOM if values changed\n" +
      "```\n\n" +
      "**Default Strategy:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-user',\n" +
      "  template: `<div>{{ user.name }}</div>`,\n" +
      "  // changeDetection: ChangeDetectionStrategy.Default (default)\n" +
      "})\n" +
      "export class UserComponent {\n" +
      "  @Input() user: User;\n" +
      "}\n\n" +
      "// Checks component on EVERY change detection cycle\n" +
      "// Even if inputs haven't changed!\n" +
      "```\n\n" +
      "**OnPush Strategy (Optimized):**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-user',\n" +
      "  template: `<div>{{ user.name }}</div>`,\n" +
      "  changeDetection: ChangeDetectionStrategy.OnPush // Optimize!\n" +
      "})\n" +
      "export class UserComponent {\n" +
      "  @Input() user: User;\n" +
      "}\n\n" +
      "// Only checks component when:\n" +
      "// 1. Input reference changes\n" +
      "// 2. Event fires from component or children\n" +
      "// 3. Observable emits via async pipe\n" +
      "// 4. Manual trigger (ChangeDetectorRef.markForCheck)\n" +
      "```\n\n" +
      "**OnPush Gotchas:**\n\n" +
      "```typescript\n" +
      "// ❌ Mutation doesn't trigger change detection\n" +
      "@Component({\n" +
      "  changeDetection: ChangeDetectionStrategy.OnPush\n" +
      "})\n" +
      "export class ListComponent {\n" +
      "  @Input() items: Item[];\n\n" +
      "  addItem(item: Item) {\n" +
      "    this.items.push(item); // Mutation! Reference didn't change\n" +
      "    // UI won't update!\n" +
      "  }\n" +
      "}\n\n" +
      "// ✅ Create new reference\n" +
      "addItem(item: Item) {\n" +
      "  this.items = [...this.items, item]; // New array reference\n" +
      "  // UI updates!\n" +
      "}\n" +
      "```\n\n" +
      "**Manual Change Detection:**\n\n" +
      "```typescript\n" +
      "import { ChangeDetectorRef } from '@angular/core';\n\n" +
      "@Component({...})\n" +
      "export class MyComponent {\n" +
      "  constructor(private cdr: ChangeDetectorRef) {}\n\n" +
      "  // Mark this component and ancestors for check\n" +
      "  markForCheck() {\n" +
      "    this.cdr.markForCheck();\n" +
      "  }\n\n" +
      "  // Immediately check this component and children\n" +
      "  detectChanges() {\n" +
      "    this.cdr.detectChanges();\n" +
      "  }\n\n" +
      "  // Detach from change detection tree\n" +
      "  detach() {\n" +
      "    this.cdr.detach();\n" +
      "    // Component won't be checked until reattach()\n" +
      "  }\n\n" +
      "  // Reattach to change detection tree\n" +
      "  reattach() {\n" +
      "    this.cdr.reattach();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Optimization Patterns:**\n\n" +
      "**1. Use OnPush Everywhere:**\n\n" +
      "```typescript\n" +
      "// ✅ OnPush + Immutable data\n" +
      "@Component({\n" +
      "  changeDetection: ChangeDetectionStrategy.OnPush\n" +
      "})\n" +
      "export class SmartComponent {\n" +
      "  users$ = this.userService.getUsers(); // Observable\n" +
      "}\n\n" +
      "// Template\n" +
      '<div *ngFor="let user of users$ | async">\n' +
      "  {{ user.name }}\n" +
      "</div>\n" +
      "```\n\n" +
      "**2. Detach for High-Frequency Updates:**\n\n" +
      "```typescript\n" +
      "// WebSocket updates 60 times per second\n" +
      "@Component({...})\n" +
      "export class ChartComponent implements OnInit, OnDestroy {\n" +
      "  constructor(private cdr: ChangeDetectorRef) {}\n\n" +
      "  ngOnInit() {\n" +
      "    this.cdr.detach(); // Detach from automatic CD\n\n" +
      "    this.websocket.data$.subscribe(data => {\n" +
      "      this.chartData = data;\n" +
      "      // Manually trigger CD only every 100ms\n" +
      "      this.scheduleUpdate();\n" +
      "    });\n" +
      "  }\n\n" +
      "  private updateScheduled = false;\n\n" +
      "  private scheduleUpdate() {\n" +
      "    if (this.updateScheduled) return;\n" +
      "    \n" +
      "    this.updateScheduled = true;\n" +
      "    setTimeout(() => {\n" +
      "      this.cdr.detectChanges();\n" +
      "      this.updateScheduled = false;\n" +
      "    }, 100);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. Run Outside Angular Zone:**\n\n" +
      "```typescript\n" +
      "import { NgZone } from '@angular/core';\n\n" +
      "@Component({...})\n" +
      "export class AnimationComponent {\n" +
      "  constructor(private ngZone: NgZone) {}\n\n" +
      "  startAnimation() {\n" +
      "    // Run outside Angular - no change detection\n" +
      "    this.ngZone.runOutsideAngular(() => {\n" +
      "      requestAnimationFrame(() => this.animate());\n" +
      "    });\n" +
      "  }\n\n" +
      "  private animate() {\n" +
      "    // Heavy animation loop\n" +
      "    // Doesn't trigger CD on every frame\n" +
      "    \n" +
      "    if (this.shouldContinue) {\n" +
      "      requestAnimationFrame(() => this.animate());\n" +
      "    } else {\n" +
      "      // Re-enter Angular zone when done\n" +
      "      this.ngZone.run(() => {\n" +
      "        this.animationComplete = true;\n" +
      "      });\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**4. TrackBy for ngFor:**\n\n" +
      "```typescript\n" +
      "// ❌ Without trackBy - recreates DOM on every change\n" +
      '<div *ngFor="let item of items">\n' +
      "  {{ item.name }}\n" +
      "</div>\n\n" +
      "// ✅ With trackBy - reuses DOM\n" +
      '<div *ngFor="let item of items; trackBy: trackById">\n' +
      "  {{ item.name }}\n" +
      "</div>\n\n" +
      "trackById(index: number, item: Item): number {\n" +
      "  return item.id; // Unique identifier\n" +
      "}\n" +
      "```\n\n" +
      "**Zoneless Angular (Angular 18+):**\n\n" +
      "```typescript\n" +
      "// Opt out of Zone.js\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideExperimentalZonelessChangeDetection()\n" +
      "  ]\n" +
      "});\n\n" +
      "// Use Signals for reactivity instead\n" +
      "@Component({...})\n" +
      "export class MyComponent {\n" +
      "  count = signal(0); // Signal\n\n" +
      "  increment() {\n" +
      "    this.count.set(this.count() + 1); // Triggers CD automatically\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Performance Profiling:**\n\n" +
      "```typescript\n" +
      "// Enable in DevTools\n" +
      "ng.profiler.timeChangeDetection();\n\n" +
      "// Chrome DevTools Performance tab\n" +
      "// Look for: [AngularChangeDetection]\n" +
      "```\n\n" +
      "**Key Takeaway:** Use OnPush + immutable data + async pipe for optimal performance. Zone.js is convenient but has overhead; Signals (Angular 16+) offer better performance with fine-grained reactivity.",
    category: "Core Concepts",
    difficulty: "hard",
    tags: ["change-detection", "performance", "zonejs", "onpush", "optimization", "signals"],
  },
  {
    id: 5,
    question:
      "What are Signals in Angular (16+)? How do they differ from Observables and improve change detection?",
    answer:
      "Signals are Angular's new primitive for reactive state management, providing fine-grained reactivity without Zone.js overhead.\n\n" +
      "**What is a Signal?**\n\n" +
      "A signal is a wrapper around a value that notifies consumers when the value changes.\n\n" +
      "```typescript\n" +
      "import { signal, computed, effect } from '@angular/core';\n\n" +
      "@Component({...})\n" +
      "export class CounterComponent {\n" +
      "  // Create signal with initial value\n" +
      "  count = signal(0);\n\n" +
      "  // Read value\n" +
      "  get currentCount() {\n" +
      "    return this.count(); // Call as function\n" +
      "  }\n\n" +
      "  // Update value\n" +
      "  increment() {\n" +
      "    this.count.set(this.count() + 1); // Set new value\n" +
      "    // or\n" +
      "    this.count.update(val => val + 1); // Update based on current\n" +
      "  }\n" +
      "}\n\n" +
      "// Template - auto updates when signal changes\n" +
      "<div>Count: {{ count() }}</div>\n" +
      '<button (click)="increment()">+</button>\n' +
      "```\n\n" +
      "**Computed Signals:**\n\n" +
      "Derived values that automatically update when dependencies change:\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class CartComponent {\n" +
      "  items = signal<CartItem[]>([]);\n" +
      "  \n" +
      "  // Computed - automatically updates when items changes\n" +
      "  total = computed(() => \n" +
      "    this.items().reduce((sum, item) => sum + item.price * item.quantity, 0)\n" +
      "  );\n" +
      "  \n" +
      "  itemCount = computed(() => this.items().length);\n\n" +
      "  isEmpty = computed(() => this.items().length === 0);\n" +
      "}\n\n" +
      "// Template\n" +
      "<div>Total: {{ total() }}</div>\n" +
      "<div>Items: {{ itemCount() }}</div>\n" +
      "```\n\n" +
      "**Effects:**\n\n" +
      "Side effects that run when signals change:\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class UserComponent {\n" +
      "  userId = signal(1);\n\n" +
      "  constructor() {\n" +
      "    // Effect runs whenever userId changes\n" +
      "    effect(() => {\n" +
      "      console.log('User ID changed to:', this.userId());\n" +
      "      this.loadUserData(this.userId());\n" +
      "    });\n" +
      "  }\n\n" +
      "  loadUserData(id: number) {\n" +
      "    // Fetch user data\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Signals vs Observables:**\n\n" +
      "| Feature | Signals | Observables |\n" +
      "|---------|---------|-------------|\n" +
      "| Reactivity | Synchronous, automatic | Asynchronous, manual subscribe |\n" +
      "| Current Value | Always available: `signal()` | Not always available |\n" +
      "| Subscription | Automatic in templates | Need async pipe or manual |\n" +
      "| Memory | Auto-cleanup | Must unsubscribe |\n" +
      "| Operators | Limited (computed, effect) | Rich (map, filter, etc.) |\n" +
      "| Change Detection | Fine-grained updates | Zone.js or OnPush |\n" +
      "| Use Case | Sync state | Async streams (HTTP, events) |\n\n" +
      "**When to Use Each:**\n\n" +
      "**Signals:**\n" +
      "```typescript\n" +
      "// ✅ Local component state\n" +
      "count = signal(0);\n" +
      "isOpen = signal(false);\n" +
      "selectedItems = signal<Item[]>([]);\n\n" +
      "// ✅ Derived state\n" +
      "doubleCount = computed(() => this.count() * 2);\n\n" +
      "// ✅ Shared state (in service)\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class ThemeService {\n" +
      "  theme = signal<'light' | 'dark'>('light');\n\n" +
      "  toggle() {\n" +
      "    this.theme.update(t => t === 'light' ? 'dark' : 'light');\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Observables:**\n" +
      "```typescript\n" +
      "// ✅ HTTP requests\n" +
      "users$ = this.http.get<User[]>('/api/users');\n\n" +
      "// ✅ Events over time\n" +
      "clicks$ = fromEvent(document, 'click');\n\n" +
      "// ✅ Complex async flows\n" +
      "searchResults$ = this.searchControl.valueChanges.pipe(\n" +
      "  debounceTime(300),\n" +
      "  distinctUntilChanged(),\n" +
      "  switchMap(query => this.searchService.search(query))\n" +
      ");\n" +
      "```\n\n" +
      "**Interoperability:**\n\n" +
      "```typescript\n" +
      "import { toSignal, toObservable } from '@angular/core/rxjs-interop';\n\n" +
      "// Observable → Signal\n" +
      "users$ = this.http.get<User[]>('/api/users');\n" +
      "users = toSignal(this.users$, { initialValue: [] });\n" +
      "// Now use as signal: {{ users()[0].name }}\n\n" +
      "// Signal → Observable\n" +
      "count = signal(0);\n" +
      "count$ = toObservable(this.count);\n" +
      "// Can use RxJS operators on count$\n" +
      "```\n\n" +
      "**Signal Inputs/Outputs (Angular 17.1+):**\n\n" +
      "```typescript\n" +
      "import { input, output } from '@angular/core';\n\n" +
      "@Component({...})\n" +
      "export class UserCardComponent {\n" +
      "  // Signal input (replaces @Input)\n" +
      "  user = input.required<User>(); // Required\n" +
      "  size = input<'sm' | 'lg'>('sm'); // Optional with default\n\n" +
      "  // Signal output (replaces @Output)\n" +
      "  userClick = output<User>(); // EventEmitter replacement\n\n" +
      "  // Computed from signal input\n" +
      "  displayName = computed(() => \n" +
      "    `${this.user().firstName} ${this.user().lastName}`\n" +
      "  );\n\n" +
      "  onClick() {\n" +
      "    this.userClick.emit(this.user());\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage\n" +
      "<app-user-card \n" +
      '  [user]="currentUser" \n' +
      '  (userClick)="handleClick($event)"\n' +
      "/>\n" +
      "```\n\n" +
      "**Benefits of Signals:**\n\n" +
      "1. **Fine-Grained Reactivity:** Only updates what changed\n" +
      "2. **No Zone.js Needed:** Can run zoneless for better performance\n" +
      "3. **Synchronous:** Immediate value access, no async pipe needed\n" +
      "4. **Auto-Cleanup:** No unsubscribe needed\n" +
      "5. **Type-Safe:** Full TypeScript support\n" +
      "6. **Composable:** Computed signals build on each other\n\n" +
      "**Migration Pattern:**\n\n" +
      "```typescript\n" +
      "// Old: Observable + async pipe\n" +
      "users$: Observable<User[]>;\n" +
      "\n" +
      "ngOnInit() {\n" +
      "  this.users$ = this.userService.getUsers();\n" +
      "}\n\n" +
      "// Template\n" +
      '<div *ngFor="let user of users$ | async">\n\n' +
      "// New: Signal\n" +
      "users = signal<User[]>([]);\n\n" +
      "ngOnInit() {\n" +
      "  this.userService.getUsers().subscribe(users => {\n" +
      "    this.users.set(users);\n" +
      "  });\n" +
      "  \n" +
      "  // Or use toSignal\n" +
      "  this.users = toSignal(this.userService.getUsers(), { initialValue: [] });\n" +
      "}\n\n" +
      "// Template\n" +
      '<div *ngFor="let user of users()">\n' +
      "```\n\n" +
      "**Key Takeaway:** Signals are Angular's future for state management. They provide better performance through fine-grained reactivity and enable zoneless Angular. Use Signals for state, Observables for async streams.",
    category: "State Management",
    difficulty: "hard",
    tags: ["signals", "reactivity", "state-management", "angular16+", "performance"],
  },
  {
    id: 6,
    question:
      "Explain NgRx and the Redux pattern in Angular. When should you use NgRx vs Services?",
    answer:
      "NgRx is Angular's implementation of the Redux pattern for state management, providing a single source of truth for application state.\n\n" +
      "**Core Concepts:**\n\n" +
      "**1. Store (Single Source of Truth):**\n" +
      "```typescript\n" +
      "// Store holds entire app state\n" +
      "interface AppState {\n" +
      "  users: UserState;\n" +
      "  products: ProductState;\n" +
      "  auth: AuthState;\n" +
      "}\n" +
      "```\n\n" +
      "**2. Actions (Events):**\n" +
      "```typescript\n" +
      "import { createAction, props } from '@ngrx/store';\n\n" +
      "// Action describes what happened\n" +
      "export const loadUsers = createAction('[User List] Load Users');\n\n" +
      "export const loadUsersSuccess = createAction(\n" +
      "  '[User API] Load Users Success',\n" +
      "  props<{ users: User[] }>()\n" +
      ");\n\n" +
      "export const loadUsersFailure = createAction(\n" +
      "  '[User API] Load Users Failure',\n" +
      "  props<{ error: string }>()\n" +
      ");\n" +
      "```\n\n" +
      "**3. Reducers (Pure Functions):**\n" +
      "```typescript\n" +
      "import { createReducer, on } from '@ngrx/store';\n\n" +
      "export interface UserState {\n" +
      "  users: User[];\n" +
      "  loading: boolean;\n" +
      "  error: string | null;\n" +
      "}\n\n" +
      "const initialState: UserState = {\n" +
      "  users: [],\n" +
      "  loading: false,\n" +
      "  error: null\n" +
      "};\n\n" +
      "export const userReducer = createReducer(\n" +
      "  initialState,\n" +
      "  on(loadUsers, (state) => ({\n" +
      "    ...state,\n" +
      "    loading: true,\n" +
      "    error: null\n" +
      "  })),\n" +
      "  on(loadUsersSuccess, (state, { users }) => ({\n" +
      "    ...state,\n" +
      "    users,\n" +
      "    loading: false\n" +
      "  })),\n" +
      "  on(loadUsersFailure, (state, { error }) => ({\n" +
      "    ...state,\n" +
      "    error,\n" +
      "    loading: false\n" +
      "  }))\n" +
      ");\n" +
      "```\n\n" +
      "**4. Effects (Side Effects):**\n" +
      "```typescript\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { Actions, createEffect, ofType } from '@ngrx/effects';\n" +
      "import { of } from 'rxjs';\n" +
      "import { map, catchError, switchMap } from 'rxjs/operators';\n\n" +
      "@Injectable()\n" +
      "export class UserEffects {\n" +
      "  loadUsers$ = createEffect(() =>\n" +
      "    this.actions$.pipe(\n" +
      "      ofType(loadUsers),\n" +
      "      switchMap(() =>\n" +
      "        this.userService.getUsers().pipe(\n" +
      "          map(users => loadUsersSuccess({ users })),\n" +
      "          catchError(error => of(loadUsersFailure({ error: error.message })))\n" +
      "        )\n" +
      "      )\n" +
      "    )\n" +
      "  );\n\n" +
      "  constructor(\n" +
      "    private actions$: Actions,\n" +
      "    private userService: UserService\n" +
      "  ) {}\n" +
      "}\n" +
      "```\n\n" +
      "**5. Selectors (Derived State):**\n" +
      "```typescript\n" +
      "import { createSelector, createFeatureSelector } from '@ngrx/store';\n\n" +
      "// Feature selector\n" +
      "export const selectUserState = createFeatureSelector<UserState>('users');\n\n" +
      "// Memoized selectors\n" +
      "export const selectAllUsers = createSelector(\n" +
      "  selectUserState,\n" +
      "  (state) => state.users\n" +
      ");\n\n" +
      "export const selectUserLoading = createSelector(\n" +
      "  selectUserState,\n" +
      "  (state) => state.loading\n" +
      ");\n\n" +
      "export const selectActiveUsers = createSelector(\n" +
      "  selectAllUsers,\n" +
      "  (users) => users.filter(u => u.active)\n" +
      ");\n" +
      "```\n\n" +
      "**Using in Components:**\n\n" +
      "```typescript\n" +
      "import { Store } from '@ngrx/store';\n\n" +
      "@Component({...})\n" +
      "export class UserListComponent implements OnInit {\n" +
      "  users$ = this.store.select(selectAllUsers);\n" +
      "  loading$ = this.store.select(selectUserLoading);\n\n" +
      "  constructor(private store: Store) {}\n\n" +
      "  ngOnInit() {\n" +
      "    // Dispatch action\n" +
      "    this.store.dispatch(loadUsers());\n" +
      "  }\n\n" +
      "  deleteUser(id: number) {\n" +
      "    this.store.dispatch(deleteUser({ id }));\n" +
      "  }\n" +
      "}\n\n" +
      "// Template\n" +
      '<div *ngIf="loading$ | async">Loading...</div>\n' +
      '<div *ngFor="let user of users$ | async">\n' +
      "  {{ user.name }}\n" +
      '  <button (click)="deleteUser(user.id)">Delete</button>\n' +
      "</div>\n" +
      "```\n\n" +
      "**When to Use NgRx:**\n\n" +
      "✅ **Use NgRx when:**\n" +
      "- Large application with complex state\n" +
      "- Multiple components need same data\n" +
      "- Need time-travel debugging\n" +
      "- Want predictable state management\n" +
      "- Team wants enforced patterns\n" +
      "- Need to track all state changes (audit)\n\n" +
      "❌ **Don't use NgRx when:**\n" +
      "- Small application\n" +
      "- Simple CRUD\n" +
      "- State is mostly local to components\n" +
      "- Team unfamiliar with Redux\n" +
      "- Adds unnecessary complexity\n\n" +
      "**NgRx vs Services:**\n\n" +
      "```typescript\n" +
      "// Service approach (simpler)\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class UserService {\n" +
      "  private usersSubject = new BehaviorSubject<User[]>([]);\n" +
      "  users$ = this.usersSubject.asObservable();\n\n" +
      "  loadUsers() {\n" +
      "    this.http.get<User[]>('/api/users').subscribe(\n" +
      "      users => this.usersSubject.next(users)\n" +
      "    );\n" +
      "  }\n" +
      "}\n\n" +
      "// NgRx approach (more structure)\n" +
      "// - Actions for every event\n" +
      "// - Reducer for state changes\n" +
      "// - Effects for side effects\n" +
      "// - Selectors for derived data\n" +
      "// More boilerplate but more predictable\n" +
      "```\n\n" +
      "**Entity Adapter (Common Pattern):**\n\n" +
      "```typescript\n" +
      "import { EntityState, EntityAdapter, createEntityAdapter } from '@ngrx/entity';\n\n" +
      "export interface UserState extends EntityState<User> {\n" +
      "  selectedUserId: number | null;\n" +
      "}\n\n" +
      "export const adapter: EntityAdapter<User> = createEntityAdapter<User>({\n" +
      "  selectId: (user: User) => user.id,\n" +
      "  sortComparer: (a, b) => a.name.localeCompare(b.name)\n" +
      "});\n\n" +
      "const initialState: UserState = adapter.getInitialState({\n" +
      "  selectedUserId: null\n" +
      "});\n\n" +
      "export const userReducer = createReducer(\n" +
      "  initialState,\n" +
      "  on(loadUsersSuccess, (state, { users }) => \n" +
      "    adapter.setAll(users, state)\n" +
      "  ),\n" +
      "  on(addUserSuccess, (state, { user }) => \n" +
      "    adapter.addOne(user, state)\n" +
      "  ),\n" +
      "  on(updateUserSuccess, (state, { user }) => \n" +
      "    adapter.updateOne({ id: user.id, changes: user }, state)\n" +
      "  ),\n" +
      "  on(deleteUserSuccess, (state, { id }) => \n" +
      "    adapter.removeOne(id, state)\n" +
      "  )\n" +
      ");\n\n" +
      "// Auto-generated selectors\n" +
      "const { selectAll, selectEntities, selectIds } = adapter.getSelectors();\n" +
      "```\n\n" +
      "**Best Practices:**\n" +
      "1. Keep reducers pure (no side effects)\n" +
      "2. Use effects for async operations\n" +
      "3. Use selectors for derived data (memoized)\n" +
      "4. Action naming: [Source] Event\n" +
      "5. Use Entity Adapter for collections\n" +
      "6. DevTools for debugging",
    category: "State Management",
    difficulty: "hard",
    tags: ["ngrx", "redux", "state-management", "effects", "selectors", "store"],
  },
  {
    id: 7,
    question:
      "What are Pipes in Angular? Explain built-in pipes, custom pipes, and RxJS pipeable operators.",
    answer:
      "Pipes transform data in templates. RxJS pipeable operators transform observable streams.\n\n" +
      "**Template Pipes:**\n\n" +
      "**Built-in Pipes:**\n" +
      "```typescript\n" +
      "// DatePipe\n" +
      "{{ today | date:'short' }}  // 1/1/24, 12:00 PM\n" +
      "{{ today | date:'fullDate' }} // Monday, January 1, 2024\n\n" +
      "// CurrencyPipe\n" +
      "{{ price | currency }}  // $99.99\n" +
      "{{ price | currency:'EUR':'symbol':'1.2-2' }}  // €99.99\n\n" +
      "// PercentPipe\n" +
      "{{ 0.25 | percent }}  // 25%\n\n" +
      "// DecimalPipe\n" +
      "{{ 123.456 | number:'1.2-2' }}  // 123.46\n\n" +
      "// UpperCase/LowerCase/TitleCase\n" +
      "{{ 'hello' | uppercase }}  // HELLO\n" +
      "{{ 'WORLD' | lowercase }}  // world\n" +
      "{{ 'hello world' | titlecase }}  // Hello World\n\n" +
      "// JsonPipe (debugging)\n" +
      "{{ user | json }}  // Formatted JSON\n\n" +
      "// SlicePipe\n" +
      "{{ items | slice:0:5 }}  // First 5 items\n\n" +
      "// AsyncPipe (most important!)\n" +
      "{{ users$ | async }}  // Auto-subscribe/unsubscribe\n" +
      "```\n\n" +
      "**Custom Pipe:**\n\n" +
      "```typescript\n" +
      "import { Pipe, PipeTransform } from '@angular/core';\n\n" +
      "@Pipe({\n" +
      "  name: 'truncate',\n" +
      "  standalone: true // Angular 14+\n" +
      "})\n" +
      "export class TruncatePipe implements PipeTransform {\n" +
      "  transform(value: string, limit: number = 20, trail: string = '...'): string {\n" +
      "    if (!value) return '';\n" +
      "    if (value.length <= limit) return value;\n" +
      "    return value.substring(0, limit) + trail;\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage\n" +
      "{{ longText | truncate:50:'...' }}\n" +
      "```\n\n" +
      "**Pure vs Impure Pipes:**\n\n" +
      "```typescript\n" +
      "// Pure pipe (default) - only re-runs when input reference changes\n" +
      "@Pipe({\n" +
      "  name: 'filterPure',\n" +
      "  pure: true // default\n" +
      "})\n" +
      "export class FilterPurePipe implements PipeTransform {\n" +
      "  transform(items: Item[], filter: string): Item[] {\n" +
      "    console.log('FilterPipe executed');\n" +
      "    return items.filter(item => item.name.includes(filter));\n" +
      "  }\n" +
      "}\n\n" +
      "// ❌ Doesn't work with mutations\n" +
      "addItem(item: Item) {\n" +
      "  this.items.push(item); // Mutation - same reference\n" +
      "  // Pipe doesn't re-run!\n" +
      "}\n\n" +
      "// ✅ Works with new reference\n" +
      "addItem(item: Item) {\n" +
      "  this.items = [...this.items, item]; // New reference\n" +
      "  // Pipe re-runs\n" +
      "}\n\n" +
      "// Impure pipe - re-runs on every change detection\n" +
      "@Pipe({\n" +
      "  name: 'filterImpure',\n" +
      "  pure: false // Runs every CD cycle - expensive!\n" +
      "})\n" +
      "export class FilterImpurePipe implements PipeTransform {\n" +
      "  transform(items: Item[], filter: string): Item[] {\n" +
      "    return items.filter(item => item.name.includes(filter));\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**AsyncPipe (Critical for Memory Management):**\n\n" +
      "```typescript\n" +
      "// ❌ Manual subscription - memory leak risk\n" +
      "@Component({...})\n" +
      "export class UsersComponent implements OnInit, OnDestroy {\n" +
      "  users: User[];\n" +
      "  private subscription: Subscription;\n\n" +
      "  ngOnInit() {\n" +
      "    this.subscription = this.userService.getUsers().subscribe(\n" +
      "      users => this.users = users\n" +
      "    );\n" +
      "  }\n\n" +
      "  ngOnDestroy() {\n" +
      "    this.subscription.unsubscribe(); // Must remember!\n" +
      "  }\n" +
      "}\n\n" +
      "// ✅ AsyncPipe - automatic cleanup\n" +
      "@Component({...})\n" +
      "export class UsersComponent {\n" +
      "  users$ = this.userService.getUsers();\n" +
      "  // No ngOnDestroy needed!\n" +
      "}\n\n" +
      "// Template\n" +
      '<div *ngFor="let user of users$ | async">\n' +
      "  {{ user.name }}\n" +
      "</div>\n" +
      "```\n\n" +
      "**RxJS Pipeable Operators:**\n\n" +
      "Chain operators to transform observable streams:\n\n" +
      "```typescript\n" +
      "import { map, filter, debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';\n\n" +
      "// Search with debounce\n" +
      "this.searchControl.valueChanges.pipe(\n" +
      "  debounceTime(300),           // Wait 300ms after last keystroke\n" +
      "  distinctUntilChanged(),      // Only if value actually changed\n" +
      "  filter(query => query.length >= 3),  // Minimum 3 characters\n" +
      "  switchMap(query => this.searchService.search(query))  // Cancel previous, switch to new\n" +
      ").subscribe(results => this.results = results);\n\n" +
      "// Multiple transformations\n" +
      "this.users$.pipe(\n" +
      "  map(users => users.filter(u => u.active)),  // Filter active\n" +
      "  map(users => users.sort((a, b) => a.name.localeCompare(b.name))),  // Sort\n" +
      "  map(users => users.slice(0, 10))  // Take first 10\n" +
      ").subscribe(topUsers => this.topUsers = topUsers);\n" +
      "```\n\n" +
      "**Common RxJS Operators:**\n\n" +
      "**Transformation:**\n" +
      "- `map` - Transform each value\n" +
      "- `pluck` - Extract property\n" +
      "- `scan` - Accumulate values (like reduce)\n\n" +
      "**Filtering:**\n" +
      "- `filter` - Filter emissions\n" +
      "- `take` - Take N values\n" +
      "- `skip` - Skip N values\n" +
      "- `distinctUntilChanged` - Skip duplicates\n\n" +
      "**Combination:**\n" +
      "- `combineLatest` - Combine latest from all\n" +
      "- `merge` - Merge multiple observables\n" +
      "- `concat` - Subscribe sequentially\n\n" +
      "**Higher-Order:**\n" +
      "- `switchMap` - Cancel previous, switch to new\n" +
      "- `mergeMap` - Run all concurrently\n" +
      "- `concatMap` - Run sequentially\n" +
      "- `exhaustMap` - Ignore new until current completes\n\n" +
      "**Utility:**\n" +
      "- `tap` - Side effects without changing stream\n" +
      "- `catchError` - Error handling\n" +
      "- `retry` - Retry on error\n" +
      "- `delay` - Delay emissions\n\n" +
      "**Key Differences:**\n\n" +
      "| Feature | Template Pipes | RxJS Operators |\n" +
      "|---------|---------------|----------------|\n" +
      "| Used in | Templates | TypeScript code |\n" +
      "| Transform | Display values | Observable streams |\n" +
      "| Syntax | `value \\| pipe:arg` | `obs.pipe(operator())` |\n" +
      "| Purity | Pure by default | Depends on operator |\n\n" +
      "**Best Practices:**\n" +
      "1. Use async pipe for all observables\n" +
      "2. Keep pipes pure when possible\n" +
      "3. Avoid complex logic in pipes\n" +
      "4. Use switchMap for search (cancels previous)\n" +
      "5. Use mergeMap for independent requests\n" +
      "6. Always handle errors with catchError",
    category: "Pipes & Operators",
    difficulty: "intermediate",
    tags: ["pipes", "rxjs", "operators", "async-pipe", "custom-pipes", "transforms"],
  },
  {
    id: 8,
    question:
      "Explain Angular component lifecycle hooks. What is ngOnDestroy used for and why is it critical?",
    answer:
      "Angular components go through a lifecycle managed by Angular, with hooks that let you tap into key moments.\n\n" +
      "**Complete Lifecycle Order:**\n\n" +
      "1. **constructor()** - Class instantiation\n" +
      "2. **ngOnChanges()** - When @Input properties change (before ngOnInit and on every change)\n" +
      "3. **ngOnInit()** - After first ngOnChanges, one-time initialization\n" +
      "4. **ngDoCheck()** - Custom change detection (every CD cycle)\n" +
      "5. **ngAfterContentInit()** - After content (ng-content) projection initialized\n" +
      "6. **ngAfterContentChecked()** - After content checked (every CD)\n" +
      "7. **ngAfterViewInit()** - After component view and child views initialized\n" +
      "8. **ngAfterViewChecked()** - After view checked (every CD)\n" +
      "9. **ngOnDestroy()** - Just before component destruction\n\n" +
      "**ngOnDestroy - Critical for Cleanup:**\n\n" +
      "```typescript\n" +
      "import { OnDestroy } from '@angular/core';\n" +
      "import { Subscription, Subject } from 'rxjs';\n" +
      "import { takeUntil } from 'rxjs/operators';\n\n" +
      "export class Component implements OnInit, OnDestroy {\n" +
      "  // Pattern 1: Subscription collection\n" +
      "  private subscriptions = new Subscription();\n\n" +
      "  // Pattern 2: takeUntil with Subject\n" +
      "  private destroy$ = new Subject<void>();\n\n" +
      "  private intervalId: any;\n" +
      "  private webSocket: WebSocket;\n\n" +
      "  ngOnInit() {\n" +
      "    // ❌ Memory leak without cleanup\n" +
      "    this.userService.getUsers().subscribe(users => this.users = users);\n\n" +
      "    // ✅ Add to subscriptions\n" +
      "    this.subscriptions.add(\n" +
      "      this.userService.getUsers().subscribe(users => this.users = users)\n" +
      "    );\n\n" +
      "    // ✅ Or use takeUntil\n" +
      "    this.route.params\n" +
      "      .pipe(takeUntil(this.destroy$))\n" +
      "      .subscribe(params => this.loadData(params));\n\n" +
      "    this.intervalId = setInterval(() => this.poll(), 5000);\n" +
      "    this.webSocket = new WebSocket('ws://...');\n" +
      "  }\n\n" +
      "  ngOnDestroy() {\n" +
      "    // ✅ Unsubscribe from observables\n" +
      "    this.subscriptions.unsubscribe();\n\n" +
      "    // ✅ Complete takeUntil subject\n" +
      "    this.destroy$.next();\n" +
      "    this.destroy$.complete();\n\n" +
      "    // ✅ Clear timers\n" +
      "    if (this.intervalId) {\n" +
      "      clearInterval(this.intervalId);\n" +
      "    }\n\n" +
      "    // ✅ Close WebSocket\n" +
      "    this.webSocket?.close();\n\n" +
      "    // ✅ Remove event listeners\n" +
      "    document.removeEventListener('click', this.handleClick);\n\n" +
      "    // ✅ Complete custom subjects\n" +
      "    this.dataSubject.complete();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**What Happens Without Cleanup:**\n" +
      "- Memory leaks (subscriptions never released)\n" +
      "- Multiple subscriptions accumulate\n" +
      "- Timers keep running\n" +
      "- Event listeners stay attached\n" +
      "- WebSockets stay open\n\n" +
      "**Best Practices:**\n" +
      "1. Always implement ngOnDestroy if subscribing\n" +
      "2. Use async pipe when possible (auto-cleanup)\n" +
      "3. Use takeUntil pattern for multiple subscriptions\n" +
      "4. Complete custom Subjects\n" +
      "5. Clear timers and intervals\n" +
      "6. Remove event listeners",
    category: "Lifecycle",
    difficulty: "intermediate",
    tags: ["lifecycle", "ngOnDestroy", "cleanup", "memory-leaks", "subscriptions"],
  },
  {
    id: 9,
    question:
      "Compare localStorage, sessionStorage, and Cookies. When should you use each for storing JWT tokens?",
    answer:
      "**Comparison:**\n\n" +
      "| Feature | localStorage | sessionStorage | Cookies |\n" +
      "|---------|-------------|----------------|--------|\n" +
      "| Size | ~10MB | ~10MB | ~4KB |\n" +
      "| Lifetime | Forever | Tab session | Set expiration |\n" +
      "| Scope | All tabs | Single tab | All tabs |\n" +
      "| Sent to server | No | No | Yes (auto) |\n" +
      "| Access | JS only | JS only | JS (unless HttpOnly) |\n" +
      "| XSS vulnerable | Yes | Yes | Can be protected |\n\n" +
      "**JWT Token Storage (Security Critical):**\n\n" +
      "```typescript\n" +
      "// ❌ INSECURE - XSS can steal token\n" +
      "localStorage.setItem('token', jwt);\n\n" +
      "// ✅ SECURE - HttpOnly cookie (server-side only)\n" +
      "// Server sets:\n" +
      "Set-Cookie: token=xyz; HttpOnly; Secure; SameSite=Strict\n\n" +
      "// HttpOnly = JavaScript cannot access (XSS protection)\n" +
      "// Secure = HTTPS only\n" +
      "// SameSite = CSRF protection\n" +
      "```\n\n" +
      "**Best Practice - Hybrid Approach:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class TokenService {\n" +
      "  // Access token in memory (most secure)\n" +
      "  private accessToken: string | null = null;\n\n" +
      "  // Refresh token in HttpOnly cookie (server manages)\n" +
      "  // User data in localStorage (non-sensitive)\n\n" +
      "  setAccessToken(token: string) {\n" +
      "    this.accessToken = token; // Memory only\n" +
      "  }\n\n" +
      "  getAccessToken(): string | null {\n" +
      "    return this.accessToken;\n" +
      "  }\n\n" +
      "  setUserData(user: User) {\n" +
      "    localStorage.setItem('user', JSON.stringify({\n" +
      "      id: user.id,\n" +
      "      name: user.name // Non-sensitive data only\n" +
      "    }));\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Security",
    difficulty: "intermediate",
    tags: ["storage", "security", "jwt", "cookies", "xss"],
  },
  {
    id: 10,
    question:
      "What is the difference between Reactive Forms and Template-Driven Forms? Provide examples.",
    answer:
      "**Reactive Forms (Recommended):**\n\n" +
      "```typescript\n" +
      "import { ReactiveFormsModule, FormBuilder, Validators } from '@angular/forms';\n\n" +
      "@Component({\n" +
      "  imports: [ReactiveFormsModule],\n" +
      "  template: `\n" +
      '    <form [formGroup]="form" (ngSubmit)="onSubmit()">\n' +
      '      <input formControlName="email" />\n' +
      '      <input formControlName="password" type="password" />\n' +
      '      <button [disabled]="form.invalid">Submit</button>\n' +
      "    </form>\n" +
      "  `\n" +
      "})\n" +
      "export class LoginComponent {\n" +
      "  form = this.fb.group({\n" +
      "    email: ['', [Validators.required, Validators.email]],\n" +
      "    password: ['', [Validators.required, Validators.minLength(8)]]\n" +
      "  });\n\n" +
      "  constructor(private fb: FormBuilder) {}\n\n" +
      "  onSubmit() {\n" +
      "    if (this.form.valid) {\n" +
      "      console.log(this.form.value);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template-Driven Forms:**\n\n" +
      "```typescript\n" +
      "import { FormsModule } from '@angular/forms';\n\n" +
      "@Component({\n" +
      "  imports: [FormsModule],\n" +
      "  template: `\n" +
      '    <form #f="ngForm" (ngSubmit)="onSubmit(f)">\n' +
      '      <input name="email" [(ngModel)]="user.email" required email />\n' +
      '      <input name="password" [(ngModel)]="user.password" required minlength="8" />\n' +
      '      <button [disabled]="f.invalid">Submit</button>\n' +
      "    </form>\n" +
      "  `\n" +
      "})\n" +
      "export class LoginComponent {\n" +
      "  user = { email: '', password: '' };\n\n" +
      "  onSubmit(form: NgForm) {\n" +
      "    if (form.valid) console.log(form.value);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**When to Use Reactive:**\n" +
      "- Complex validation\n" +
      "- Dynamic forms\n" +
      "- Unit testing\n" +
      "- Programmatic control\n\n" +
      "**When to Use Template-Driven:**\n" +
      "- Simple forms\n" +
      "- Rapid prototyping",
    category: "Forms",
    difficulty: "intermediate",
    tags: ["forms", "reactive-forms", "template-driven", "validation"],
  },
  {
    id: 11,
    question: "Explain CanActivate, CanLoad, CanDeactivate routing guards. Provide use cases.",
    answer:
      "**CanActivate - Protect Routes:**\n\n" +
      "```typescript\n" +
      "export const authGuard: CanActivateFn = (route, state) => {\n" +
      "  const authService = inject(AuthService);\n" +
      "  const router = inject(Router);\n\n" +
      "  if (authService.isAuthenticated()) {\n" +
      "    return true;\n" +
      "  }\n\n" +
      "  return router.createUrlTree(['/login'], {\n" +
      "    queryParams: { returnUrl: state.url }\n" +
      "  });\n" +
      "};\n\n" +
      "// Route\n" +
      "{ path: 'dashboard', canActivate: [authGuard], component: DashboardComponent }\n" +
      "```\n\n" +
      "**CanLoad - Lazy Loading Protection:**\n\n" +
      "```typescript\n" +
      "export const adminCanLoad: CanLoadFn = () => {\n" +
      "  const auth = inject(AuthService);\n" +
      "  return auth.hasRole('admin'); // Module won't load if false\n" +
      "};\n\n" +
      "// Route\n" +
      "{\n" +
      "  path: 'admin',\n" +
      "  loadChildren: () => import('./admin/admin.routes'),\n" +
      "  canLoad: [adminCanLoad]\n" +
      "}\n" +
      "```\n\n" +
      "**CanDeactivate - Unsaved Changes:**\n\n" +
      "```typescript\n" +
      "export const unsavedChangesGuard: CanDeactivateFn<FormComponent> = (component) => {\n" +
      "  if (component.form.dirty && !component.saved) {\n" +
      "    return confirm('Unsaved changes. Leave anyway?');\n" +
      "  }\n" +
      "  return true;\n" +
      "};\n\n" +
      "// Route\n" +
      "{ path: 'edit/:id', canDeactivate: [unsavedChangesGuard], component: FormComponent }\n" +
      "```\n\n" +
      "**Execution Order:**\n" +
      "1. CanDeactivate (current route)\n" +
      "2. CanLoad (if lazy)\n" +
      "3. CanActivate (target route)\n" +
      "4. Resolve (if guards pass)",
    category: "Routing",
    difficulty: "hard",
    tags: ["routing", "guards", "canactivate", "canload", "candeactivate", "auth"],
  },
  {
    id: 12,
    question: "What are Route Resolvers? How do they differ from guards?",
    answer:
      "Resolvers pre-fetch data before activating a route, ensuring data is available when component loads.\n\n" +
      "**Resolver Implementation:**\n\n" +
      "```typescript\n" +
      "import { ResolveFn } from '@angular/router';\n\n" +
      "export const userResolver: ResolveFn<User> = (route, state) => {\n" +
      "  const userService = inject(UserService);\n" +
      "  const userId = route.paramMap.get('id')!;\n" +
      "  \n" +
      "  return userService.getUser(userId).pipe(\n" +
      "    catchError(() => {\n" +
      "      const router = inject(Router);\n" +
      "      router.navigate(['/not-found']);\n" +
      "      return EMPTY;\n" +
      "    })\n" +
      "  );\n" +
      "};\n\n" +
      "// Route\n" +
      "{\n" +
      "  path: 'user/:id',\n" +
      "  component: UserDetailComponent,\n" +
      "  resolve: { user: userResolver }\n" +
      "}\n\n" +
      "// Component\n" +
      "@Component({...})\n" +
      "export class UserDetailComponent implements OnInit {\n" +
      "  user: User;\n\n" +
      "  constructor(private route: ActivatedRoute) {}\n\n" +
      "  ngOnInit() {\n" +
      "    // Data already loaded!\n" +
      "    this.user = this.route.snapshot.data['user'];\n" +
      "    \n" +
      "    // Or observe changes\n" +
      "    this.route.data.subscribe(data => {\n" +
      "      this.user = data['user'];\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Resolver vs Guard:**\n" +
      "- **Guard:** Decides if route can activate (true/false)\n" +
      "- **Resolver:** Fetches data before activation (returns data)\n\n" +
      "**Resolver vs Component Fetch:**\n" +
      "- **Resolver:** Data ready immediately, no loading state\n" +
      "- **Component:** Shows loading spinner, data arrives async",
    category: "Routing",
    difficulty: "intermediate",
    tags: ["routing", "resolver", "data-fetching", "guards"],
  },
  {
    id: 13,
    question:
      "Explain @Input/@Output decorators. How do Signal inputs/outputs (Angular 17+) improve upon them?",
    answer:
      "**Traditional @Input/@Output:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class UserCardComponent {\n" +
      "  @Input() user: User; // Can be undefined!\n" +
      "  @Input() size: 'sm' | 'lg' = 'sm';\n" +
      "  @Output() userClick = new EventEmitter<User>();\n\n" +
      "  onClick() {\n" +
      "    this.userClick.emit(this.user);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Signal Inputs/Outputs (Angular 17.1+):**\n\n" +
      "```typescript\n" +
      "import { input, output, computed } from '@angular/core';\n\n" +
      "@Component({...})\n" +
      "export class UserCardComponent {\n" +
      "  // Signal input - always has value, type-safe\n" +
      "  user = input.required<User>(); // Required\n" +
      "  size = input<'sm' | 'lg'>('sm'); // Optional with default\n\n" +
      "  // Signal output - type-safe\n" +
      "  userClick = output<User>();\n\n" +
      "  // Computed from input\n" +
      "  displayName = computed(() => \n" +
      "    `${this.user().firstName} ${this.user().lastName}`\n" +
      "  );\n\n" +
      "  onClick() {\n" +
      "    this.userClick.emit(this.user());\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage identical\n" +
      '<app-user-card [user]="currentUser" (userClick)="handleClick($event)" />\n' +
      "```\n\n" +
      "**Benefits of Signal Inputs:**\n" +
      "1. Type-safe (required vs optional)\n" +
      "2. Can use in computed signals\n" +
      "3. Better change detection\n" +
      "4. No undefined checks needed\n" +
      "5. Automatic reactivity\n\n" +
      "**Key Difference:**\n" +
      "```typescript\n" +
      "// Traditional - might be undefined\n" +
      "@Input() user: User;\n" +
      "ngOnInit() {\n" +
      "  if (this.user) { // Must check!\n" +
      "    this.loadData(this.user.id);\n" +
      "  }\n" +
      "}\n\n" +
      "// Signal - always has value\n" +
      "user = input.required<User>();\n" +
      "ngOnInit() {\n" +
      "  this.loadData(this.user().id); // No check needed\n" +
      "}\n" +
      "```",
    category: "Component Communication",
    difficulty: "intermediate",
    tags: ["input", "output", "signals", "component-communication", "angular17+"],
  },
  {
    id: 14,
    question:
      "How do you implement WebSocket communication in Angular? What is SignalR and how to integrate it?",
    answer:
      "**WebSocket with RxJS:**\n\n" +
      "```typescript\n" +
      "import { webSocket, WebSocketSubject } from 'rxjs/webSocket';\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class WebSocketService {\n" +
      "  private socket$: WebSocketSubject<unknown>;\n\n" +
      "  connect(url: string): WebSocketSubject<unknown> {\n" +
      "    if (!this.socket$ || this.socket$.closed) {\n" +
      "      this.socket$ = webSocket({\n" +
      "        url,\n" +
      "        openObserver: {\n" +
      "          next: () => console.log('WebSocket connected')\n" +
      "        },\n" +
      "        closeObserver: {\n" +
      "          next: () => console.log('WebSocket disconnected')\n" +
      "        }\n" +
      "      });\n" +
      "    }\n" +
      "    return this.socket$;\n" +
      "  }\n\n" +
      "  send(message: any) {\n" +
      "    this.socket$.next(message);\n" +
      "  }\n\n" +
      "  close() {\n" +
      "    this.socket$.complete();\n" +
      "  }\n" +
      "}\n\n" +
      "// Component\n" +
      "ngOnInit() {\n" +
      "  this.ws.connect('wss://api.example.com').subscribe(\n" +
      "    message => console.log('Received:', message),\n" +
      "    error => console.error('Error:', error)\n" +
      "  );\n" +
      "}\n" +
      "```\n\n" +
      "**SignalR Integration:**\n\n" +
      "```typescript\n" +
      "import * as signalR from '@microsoft/signalr';\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class SignalRService {\n" +
      "  private hubConnection: signalR.HubConnection;\n" +
      "  private messageSubject = new Subject<Message>();\n" +
      "  messages$ = this.messageSubject.asObservable();\n\n" +
      "  async connect() {\n" +
      "    this.hubConnection = new signalR.HubConnectionBuilder()\n" +
      "      .withUrl('https://api.example.com/chatHub', {\n" +
      "        accessTokenFactory: () => this.authService.getToken()\n" +
      "      })\n" +
      "      .withAutomaticReconnect() // Auto-reconnect\n" +
      "      .build();\n\n" +
      "    // Register handlers\n" +
      "    this.hubConnection.on('ReceiveMessage', (message) => {\n" +
      "      this.messageSubject.next(message);\n" +
      "    });\n\n" +
      "    // Connect\n" +
      "    await this.hubConnection.start();\n" +
      "    console.log('SignalR connected');\n" +
      "  }\n\n" +
      "  async sendMessage(message: string) {\n" +
      "    await this.hubConnection.invoke('SendMessage', message);\n" +
      "  }\n\n" +
      "  async disconnect() {\n" +
      "    await this.hubConnection.stop();\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Real-time",
    difficulty: "hard",
    tags: ["websocket", "signalr", "real-time", "rxjs"],
  },
  {
    id: 15,
    question:
      "Explain JWT authentication in Angular. How do you implement token refresh and secure storage?",
    answer:
      "**Authentication Flow:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class AuthService {\n" +
      "  private accessToken: string | null = null;\n" +
      "  private currentUserSubject = new BehaviorSubject<User | null>(null);\n" +
      "  currentUser$ = this.currentUserSubject.asObservable();\n\n" +
      "  constructor(private http: HttpClient) {\n" +
      "    // Initialize from storage\n" +
      "    const user = localStorage.getItem('user');\n" +
      "    if (user) {\n" +
      "      this.currentUserSubject.next(JSON.parse(user));\n" +
      "    }\n" +
      "  }\n\n" +
      "  login(credentials: Credentials): Observable<LoginResponse> {\n" +
      "    return this.http.post<LoginResponse>('/api/auth/login', credentials).pipe(\n" +
      "      tap(response => {\n" +
      "        this.accessToken = response.accessToken;\n" +
      "        localStorage.setItem('user', JSON.stringify(response.user));\n" +
      "        this.currentUserSubject.next(response.user);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n\n" +
      "  refreshToken(): Observable<TokenResponse> {\n" +
      "    return this.http.post<TokenResponse>('/api/auth/refresh', {}, \n" +
      "      { withCredentials: true } // Send refresh token cookie\n" +
      "    ).pipe(\n" +
      "      tap(response => {\n" +
      "        this.accessToken = response.accessToken;\n" +
      "      })\n" +
      "    );\n" +
      "  }\n\n" +
      "  logout() {\n" +
      "    this.accessToken = null;\n" +
      "    localStorage.removeItem('user');\n" +
      "    this.currentUserSubject.next(null);\n" +
      "    this.http.post('/api/auth/logout', {}, { withCredentials: true }).subscribe();\n" +
      "  }\n\n" +
      "  getToken(): string | null {\n" +
      "    return this.accessToken;\n" +
      "  }\n\n" +
      "  isAuthenticated(): boolean {\n" +
      "    return !!this.accessToken;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Token Interceptor:**\n\n" +
      "```typescript\n" +
      "export const authInterceptor: HttpInterceptorFn = (req, next) => {\n" +
      "  const authService = inject(AuthService);\n" +
      "  const token = authService.getToken();\n\n" +
      "  if (token && !req.url.includes('/auth/')) {\n" +
      "    req = req.clone({\n" +
      "      setHeaders: { Authorization: `Bearer ${token}` }\n" +
      "    });\n" +
      "  }\n\n" +
      "  return next(req).pipe(\n" +
      "    catchError((error: HttpErrorResponse) => {\n" +
      "      if (error.status === 401) {\n" +
      "        // Token expired - try refresh\n" +
      "        return authService.refreshToken().pipe(\n" +
      "          switchMap(response => {\n" +
      "            // Retry original request with new token\n" +
      "            const retryReq = req.clone({\n" +
      "              setHeaders: { Authorization: `Bearer ${response.accessToken}` }\n" +
      "            });\n" +
      "            return next(retryReq);\n" +
      "          }),\n" +
      "          catchError(refreshError => {\n" +
      "            // Refresh failed - logout\n" +
      "            authService.logout();\n" +
      "            inject(Router).navigate(['/login']);\n" +
      "            return throwError(() => refreshError);\n" +
      "          })\n" +
      "        );\n" +
      "      }\n" +
      "      return throwError(() => error);\n" +
      "    })\n" +
      "  );\n" +
      "};\n" +
      "```\n\n" +
      "**Security Best Practices:**\n" +
      "1. Store access token in memory\n" +
      "2. Store refresh token in HttpOnly cookie\n" +
      "3. Use HTTPS only (Secure flag)\n" +
      "4. Set SameSite=Strict (CSRF protection)\n" +
      "5. Short access token lifetime (15 min)\n" +
      "6. Rotate refresh tokens\n" +
      "7. Clear all on logout",
    category: "Security",
    difficulty: "hard",
    tags: ["auth", "jwt", "security", "interceptors", "tokens"],
  },
  {
    id: 16,
    question:
      "Explain Dependency Injection in Angular. What are providers, injection tokens, and hierarchical injectors?",
    answer:
      "Dependency Injection (DI) is Angular's core design pattern for providing dependencies to classes.\n\n" +
      "**Basic DI:**\n\n" +
      "```typescript\n" +
      "// Service\n" +
      "@Injectable({ providedIn: 'root' }) // Singleton\n" +
      "export class UserService {\n" +
      "  constructor(private http: HttpClient) {}\n" +
      "}\n\n" +
      "// Component injects service\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  constructor(private userService: UserService) {}\n" +
      "}\n" +
      "```\n\n" +
      "**Injection Tokens:**\n\n" +
      "```typescript\n" +
      "import { InjectionToken } from '@angular/core';\n\n" +
      "// Create token\n" +
      "export const API_URL = new InjectionToken<string>('API_URL');\n\n" +
      "// Provide value\n" +
      "providers: [\n" +
      "  { provide: API_URL, useValue: 'https://api.example.com' }\n" +
      "]\n\n" +
      "// Inject\n" +
      "constructor(@Inject(API_URL) private apiUrl: string) {}\n" +
      "```\n\n" +
      "**Provider Types:**\n\n" +
      "```typescript\n" +
      "// useClass\n" +
      "{ provide: Logger, useClass: ConsoleLogger }\n\n" +
      "// useValue\n" +
      "{ provide: 'API_URL', useValue: 'https://api.example.com' }\n\n" +
      "// useFactory\n" +
      "{\n" +
      "  provide: Logger,\n" +
      "  useFactory: (config: Config) => {\n" +
      "    return config.debug ? new DebugLogger() : new ProductionLogger();\n" +
      "  },\n" +
      "  deps: [Config]\n" +
      "}\n\n" +
      "// useExisting (alias)\n" +
      "{ provide: NewLogger, useExisting: Logger }\n" +
      "```",
    category: "Dependency Injection",
    difficulty: "hard",
    tags: ["di", "providers", "injection-tokens", "services"],
  },
  {
    id: 17,
    question:
      "What are Standalone Components (Angular 14+)? How do they differ from NgModule-based components?",
    answer:
      "Standalone components simplify Angular by eliminating the need for NgModules.\n\n" +
      "**Traditional NgModule Approach:**\n\n" +
      "```typescript\n" +
      "// Component\n" +
      "@Component({ selector: 'app-user', template: '...' })\n" +
      "export class UserComponent {}\n\n" +
      "// Must declare in NgModule\n" +
      "@NgModule({\n" +
      "  declarations: [UserComponent],\n" +
      "  imports: [CommonModule, FormsModule],\n" +
      "  exports: [UserComponent]\n" +
      "})\n" +
      "export class UserModule {}\n" +
      "```\n\n" +
      "**Standalone Approach:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-user',\n" +
      "  standalone: true, // Key flag\n" +
      "  imports: [CommonModule, FormsModule], // Direct imports\n" +
      "  template: '...'\n" +
      "})\n" +
      "export class UserComponent {}\n\n" +
      "// No NgModule needed!\n" +
      "// Use directly in other components or routes\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "1. Less boilerplate (no NgModule ceremony)\n" +
      "2. Clearer dependencies (imports in component)\n" +
      "3. Better tree-shaking\n" +
      "4. Simpler mental model\n" +
      "5. Easier lazy loading\n\n" +
      "**Migration Pattern:**\n\n" +
      "```typescript\n" +
      "// Standalone routes (Angular 15+)\n" +
      "const routes: Routes = [\n" +
      "  {\n" +
      "    path: 'user',\n" +
      "    loadComponent: () => import('./user.component').then(m => m.UserComponent)\n" +
      "  }\n" +
      "];\n\n" +
      "// Standalone bootstrap (Angular 14+)\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideRouter(routes),\n" +
      "    provideHttpClient()\n" +
      "  ]\n" +
      "});\n" +
      "```",
    category: "Architecture",
    difficulty: "intermediate",
    tags: ["standalone", "angular14+", "architecture", "modules"],
  },
  {
    id: 18,
    question: "Explain @ViewChild and @ContentChild. When do you use each?",
    answer:
      "**@ViewChild - Query Component's View:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  template: `\n" +
      "    <input #nameInput />\n" +
      "    <app-child #childComp></app-child>\n" +
      "  `\n" +
      "})\n" +
      "export class Parent implements AfterViewInit {\n" +
      "  @ViewChild('nameInput') input: ElementRef;\n" +
      "  @ViewChild('childComp') child: ChildComponent;\n" +
      "  @ViewChild(ChildComponent) childByType: ChildComponent;\n\n" +
      "  ngAfterViewInit() {\n" +
      "    // Available here!\n" +
      "    this.input.nativeElement.focus();\n" +
      "    this.child.someMethod();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**@ContentChild - Query Projected Content:**\n\n" +
      "```typescript\n" +
      "// Child component\n" +
      "@Component({\n" +
      "  selector: 'app-card',\n" +
      "  template: '<div><ng-content></ng-content></div>'\n" +
      "})\n" +
      "export class CardComponent implements AfterContentInit {\n" +
      "  @ContentChild(HeaderComponent) header: HeaderComponent;\n\n" +
      "  ngAfterContentInit() {\n" +
      "    // Projected content available here\n" +
      "    if (this.header) {\n" +
      "      this.header.highlight();\n" +
      "    }\n" +
      "  }\n" +
      "}\n\n" +
      "// Parent usage\n" +
      "<app-card>\n" +
      "  <app-header>Title</app-header>\n" +
      "  <p>Content</p>\n" +
      "</app-card>\n" +
      "```\n\n" +
      "**Key Difference:**\n" +
      "- @ViewChild: Query component's own template\n" +
      "- @ContentChild: Query content projected via ng-content",
    category: "Component Queries",
    difficulty: "intermediate",
    tags: ["viewchild", "contentchild", "queries", "dom-access"],
  },
  {
    id: 19,
    question:
      "What are Directives in Angular? Explain structural vs attribute directives with custom examples.",
    answer:
      "Directives are classes that add behavior to elements.\n\n" +
      "**Three Types:**\n" +
      "1. Components (directives with templates)\n" +
      "2. Structural directives (change DOM structure)\n" +
      "3. Attribute directives (change appearance/behavior)\n\n" +
      "**Structural Directives:**\n\n" +
      "```typescript\n" +
      "// Built-in: *ngIf, *ngFor, *ngSwitch\n" +
      '<div *ngIf="isVisible">Content</div>\n' +
      '<div *ngFor="let item of items">{{ item }}</div>\n\n' +
      "// Custom structural directive\n" +
      "@Directive({\n" +
      "  selector: '[appUnless]',\n" +
      "  standalone: true\n" +
      "})\n" +
      "export class UnlessDirective {\n" +
      "  constructor(\n" +
      "    private templateRef: TemplateRef<unknown>,\n" +
      "    private viewContainer: ViewContainerRef\n" +
      "  ) {}\n\n" +
      "  @Input() set appUnless(condition: boolean) {\n" +
      "    if (!condition) {\n" +
      "      this.viewContainer.createEmbeddedView(this.templateRef);\n" +
      "    } else {\n" +
      "      this.viewContainer.clear();\n" +
      "    }\n" +
      "  }\n" +
      "}\n\n" +
      '// Usage: <div *appUnless="isHidden">Shown when isHidden is false</div>\n' +
      "```\n\n" +
      "**Attribute Directives:**\n\n" +
      "```typescript\n" +
      "// Built-in: ngClass, ngStyle, ngModel\n" +
      '<div [ngClass]="{ active: isActive }"></div>\n\n' +
      "// Custom attribute directive\n" +
      "@Directive({\n" +
      "  selector: '[appHighlight]',\n" +
      "  standalone: true\n" +
      "})\n" +
      "export class HighlightDirective {\n" +
      "  constructor(private el: ElementRef) {}\n\n" +
      "  @Input() appHighlight = 'yellow';\n\n" +
      "  @HostListener('mouseenter') onMouseEnter() {\n" +
      "    this.highlight(this.appHighlight);\n" +
      "  }\n\n" +
      "  @HostListener('mouseleave') onMouseLeave() {\n" +
      "    this.highlight('');\n" +
      "  }\n\n" +
      "  private highlight(color: string) {\n" +
      "    this.el.nativeElement.style.backgroundColor = color;\n" +
      "  }\n" +
      "}\n\n" +
      '// Usage: <div appHighlight="lightblue">Hover me</div>\n' +
      "```",
    category: "Directives",
    difficulty: "intermediate",
    tags: ["directives", "structural", "attribute", "dom"],
  },
  {
    id: 20,
    question: "How do you test Angular components and services? Explain TestBed and async testing.",
    answer:
      "**Testing a Component:**\n\n" +
      "```typescript\n" +
      "import { TestBed, ComponentFixture } from '@angular/core/testing';\n\n" +
      "describe('UserComponent', () => {\n" +
      "  let component: UserComponent;\n" +
      "  let fixture: ComponentFixture<UserComponent>;\n\n" +
      "  beforeEach(async () => {\n" +
      "    await TestBed.configureTestingModule({\n" +
      "      imports: [UserComponent] // Standalone\n" +
      "    }).compileComponents();\n\n" +
      "    fixture = TestBed.createComponent(UserComponent);\n" +
      "    component = fixture.componentInstance;\n" +
      "    fixture.detectChanges();\n" +
      "  });\n\n" +
      "  it('should create', () => {\n" +
      "    expect(component).toBeTruthy();\n" +
      "  });\n\n" +
      "  it('should display user name', () => {\n" +
      "    component.user = { name: 'John', email: 'john@example.com' };\n" +
      "    fixture.detectChanges(); // Trigger change detection\n" +
      "    \n" +
      "    const compiled = fixture.nativeElement;\n" +
      "    expect(compiled.querySelector('h1').textContent).toContain('John');\n" +
      "  });\n" +
      "});\n" +
      "```\n\n" +
      "**Testing Services:**\n\n" +
      "```typescript\n" +
      "import { TestBed } from '@angular/core/testing';\n" +
      "import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\n\n" +
      "describe('UserService', () => {\n" +
      "  let service: UserService;\n" +
      "  let httpMock: HttpTestingController;\n\n" +
      "  beforeEach(() => {\n" +
      "    TestBed.configureTestingModule({\n" +
      "      imports: [HttpClientTestingModule],\n" +
      "      providers: [UserService]\n" +
      "    });\n\n" +
      "    service = TestBed.inject(UserService);\n" +
      "    httpMock = TestBed.inject(HttpTestingController);\n" +
      "  });\n\n" +
      "  afterEach(() => {\n" +
      "    httpMock.verify(); // No outstanding requests\n" +
      "  });\n\n" +
      "  it('should fetch users', () => {\n" +
      "    const mockUsers = [{ id: 1, name: 'John' }];\n\n" +
      "    service.getUsers().subscribe(users => {\n" +
      "      expect(users).toEqual(mockUsers);\n" +
      "    });\n\n" +
      "    const req = httpMock.expectOne('/api/users');\n" +
      "    expect(req.request.method).toBe('GET');\n" +
      "    req.flush(mockUsers);\n" +
      "  });\n" +
      "});\n" +
      "```\n\n" +
      "**Async Testing:**\n\n" +
      "```typescript\n" +
      "import { fakeAsync, tick, flush } from '@angular/core/testing';\n\n" +
      "// fakeAsync - control time\n" +
      "it('should debounce search', fakeAsync(() => {\n" +
      "  component.search('test');\n" +
      "  tick(299); // Just before debounce\n" +
      "  expect(component.results).toEqual([]);\n" +
      "  \n" +
      "  tick(1); // After 300ms debounce\n" +
      "  expect(component.results.length).toBeGreaterThan(0);\n" +
      "}));\n\n" +
      "// waitForAsync - handle async operations\n" +
      "it('should load data', waitForAsync(() => {\n" +
      "  component.ngOnInit();\n" +
      "  fixture.whenStable().then(() => {\n" +
      "    expect(component.data).toBeDefined();\n" +
      "  });\n" +
      "}));\n" +
      "```",
    category: "Testing",
    difficulty: "hard",
    tags: ["testing", "testbed", "jasmine", "async", "http-testing"],
  },
  {
    id: 21,
    question:
      "Explain RxJS higher-order operators: switchMap, mergeMap, concatMap, exhaustMap. When to use each?",
    answer:
      "Higher-order operators handle observables that emit observables (flattening).\n\n" +
      "**switchMap - Cancel Previous:**\n\n" +
      "```typescript\n" +
      "// Search - cancel old search when new query arrives\n" +
      "searchControl.valueChanges.pipe(\n" +
      "  debounceTime(300),\n" +
      "  switchMap(query => this.searchService.search(query))\n" +
      ").subscribe(results => this.results = results);\n\n" +
      "// Query: 'ang' → starts search\n" +
      "// Query: 'angu' → CANCELS 'ang' search, starts new\n" +
      "// Query: 'angular' → CANCELS 'angu', starts new\n" +
      "// Only last search completes\n" +
      "```\n\n" +
      "**mergeMap - Run All Concurrently:**\n\n" +
      "```typescript\n" +
      "// Process all items in parallel\n" +
      "from([1, 2, 3]).pipe(\n" +
      "  mergeMap(id => this.http.get(`/api/user/${id}`))\n" +
      ").subscribe(user => console.log(user));\n\n" +
      "// All 3 requests run simultaneously\n" +
      "// Results arrive in completion order (not input order)\n" +
      "```\n\n" +
      "**concatMap - Run Sequentially:**\n\n" +
      "```typescript\n" +
      "// Process one at a time, in order\n" +
      "from([1, 2, 3]).pipe(\n" +
      "  concatMap(id => this.http.get(`/api/user/${id}`))\n" +
      ").subscribe(user => console.log(user));\n\n" +
      "// Waits for request 1 to complete before starting 2\n" +
      "// Maintains order\n" +
      "```\n\n" +
      "**exhaustMap - Ignore New Until Current Completes:**\n\n" +
      "```typescript\n" +
      "// Save button - ignore clicks while saving\n" +
      "saveButton.clicks$.pipe(\n" +
      "  exhaustMap(() => this.http.post('/api/save', data))\n" +
      ").subscribe();\n\n" +
      "// Click 1 → starts save\n" +
      "// Click 2 (while saving) → IGNORED\n" +
      "// Click 3 (while saving) → IGNORED\n" +
      "// After save completes, new clicks work\n" +
      "```\n\n" +
      "**Use Cases:**\n" +
      "- switchMap: Search, autocomplete, typeahead\n" +
      "- mergeMap: Parallel independent requests\n" +
      "- concatMap: Sequential operations (upload queue)\n" +
      "- exhaustMap: Prevent duplicate submissions",
    category: "RxJS",
    difficulty: "hard",
    tags: ["rxjs", "operators", "switchmap", "mergemap", "concatmap", "exhaustmap"],
  },
  {
    id: 22,
    question: "How do you implement lazy loading in Angular? What are the benefits?",
    answer:
      "Lazy loading loads feature modules on-demand, reducing initial bundle size.\n\n" +
      "**Lazy Loading with Standalone (Angular 14+):**\n\n" +
      "```typescript\n" +
      "const routes: Routes = [\n" +
      "  {\n" +
      "    path: 'admin',\n" +
      "    loadComponent: () => import('./admin/admin.component')\n" +
      "      .then(m => m.AdminComponent)\n" +
      "  },\n" +
      "  {\n" +
      "    path: 'users',\n" +
      "    loadChildren: () => import('./users/users.routes')\n" +
      "      .then(m => m.USERS_ROUTES)\n" +
      "  }\n" +
      "];\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "1. Smaller initial bundle\n" +
      "2. Faster initial load\n" +
      "3. Load features on-demand\n" +
      "4. Better code splitting\n\n" +
      "**Preloading Strategy:**\n\n" +
      "```typescript\n" +
      "import { PreloadAllModules } from '@angular/router';\n\n" +
      "provideRouter(routes, \n" +
      "  withPreloading(PreloadAllModules) // Preload in background\n" +
      ")\n" +
      "```",
    category: "Performance",
    difficulty: "intermediate",
    tags: ["lazy-loading", "performance", "routing", "code-splitting"],
  },
  {
    id: 23,
    question:
      "What is Angular's inject() function (Angular 14+)? How does it compare to constructor injection?",
    answer:
      "**inject() Function - Modern DI:**\n\n" +
      "```typescript\n" +
      "import { inject } from '@angular/core';\n\n" +
      "// Functional approach\n" +
      "export const authGuard: CanActivateFn = (route, state) => {\n" +
      "  const authService = inject(AuthService); // No constructor!\n" +
      "  const router = inject(Router);\n\n" +
      "  return authService.isAuthenticated() \n" +
      "    ? true \n" +
      "    : router.createUrlTree(['/login']);\n" +
      "};\n\n" +
      "// In components\n" +
      "@Component({...})\n" +
      "export class MyComponent {\n" +
      "  private userService = inject(UserService);\n" +
      "  private router = inject(Router);\n\n" +
      "  // No constructor needed!\n" +
      "}\n" +
      "```\n\n" +
      "**vs Constructor Injection:**\n\n" +
      "```typescript\n" +
      "// Traditional\n" +
      "@Component({...})\n" +
      "export class MyComponent {\n" +
      "  constructor(\n" +
      "    private userService: UserService,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "}\n" +
      "```\n\n" +
      "**Benefits of inject():**\n" +
      "1. Use in functional guards/interceptors\n" +
      "2. Conditional injection\n" +
      "3. Cleaner code\n" +
      "4. Works outside constructors",
    category: "Dependency Injection",
    difficulty: "intermediate",
    tags: ["inject", "di", "angular14+", "functional"],
  },
  {
    id: 24,
    question:
      "What is Zone.js and how does it enable automatic change detection? What is Zoneless Angular?",
    answer:
      "**Zone.js:**\n" +
      "Library that patches browser async APIs to notify Angular of changes.\n\n" +
      "**What it Patches:**\n" +
      "```typescript\n" +
      "// Zone.js intercepts:\n" +
      "- setTimeout/setInterval\n" +
      "- Promise.then\n" +
      "- addEventListener\n" +
      "- XMLHttpRequest/fetch\n" +
      "- requestAnimationFrame\n" +
      "```\n\n" +
      "**How it Works:**\n" +
      "```typescript\n" +
      "// When async completes, Zone.js notifies Angular\n" +
      "button.addEventListener('click', () => {\n" +
      "  this.count++; // Zone detects this\n" +
      "  // Zone triggers change detection automatically\n" +
      "});\n" +
      "```\n\n" +
      "**Zoneless Angular (Angular 18+):**\n\n" +
      "```typescript\n" +
      "// Bootstrap without Zone.js\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideExperimentalZonelessChangeDetection()\n" +
      "  ]\n" +
      "});\n\n" +
      "// Use Signals for reactivity\n" +
      "@Component({...})\n" +
      "export class MyComponent {\n" +
      "  count = signal(0);\n\n" +
      "  increment() {\n" +
      "    this.count.update(c => c + 1); // Auto-updates view\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Benefits of Zoneless:**\n" +
      "- Better performance (no patching overhead)\n" +
      "- Smaller bundle (no Zone.js)\n" +
      "- More predictable\n" +
      "- Explicit reactivity with Signals",
    category: "Core Concepts",
    difficulty: "hard",
    tags: ["zonejs", "change-detection", "zoneless", "signals", "performance"],
  },
  {
    id: 25,
    question: "What is Content Projection (ng-content)? Explain single and multi-slot projection.",
    answer:
      "Content projection allows components to accept and display external content.\n\n" +
      "**Single Slot:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-card',\n" +
      "  template: `\n" +
      '    <div class="card">\n' +
      "      <ng-content></ng-content>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class CardComponent {}\n\n" +
      "// Usage\n" +
      "<app-card>\n" +
      "  <h1>Title</h1>\n" +
      "  <p>Content here</p>\n" +
      "</app-card>\n" +
      "```\n\n" +
      "**Multi-Slot (select attribute):**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-card',\n" +
      "  template: `\n" +
      '    <div class="card">\n' +
      '      <div class="header">\n' +
      '        <ng-content select="[card-header]"></ng-content>\n' +
      "      </div>\n" +
      '      <div class="body">\n' +
      '        <ng-content select="[card-body]"></ng-content>\n' +
      "      </div>\n" +
      '      <div class="footer">\n' +
      '        <ng-content select="[card-footer]"></ng-content>\n' +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class CardComponent {}\n\n" +
      "// Usage\n" +
      "<app-card>\n" +
      "  <div card-header>Header Content</div>\n" +
      "  <div card-body>Body Content</div>\n" +
      "  <div card-footer>Footer Content</div>\n" +
      "</app-card>\n" +
      "```\n\n" +
      "**Use Cases:**\n" +
      "- Reusable layout components\n" +
      "- Custom dialogs\n" +
      "- Tab panels\n" +
      "- Accordion items",
    category: "Component Patterns",
    difficulty: "intermediate",
    tags: ["content-projection", "ng-content", "slots", "composition"],
  },
  {
    id: 26,
    question: "How do you optimize Angular application performance? List key strategies.",
    answer:
      "**Key Optimization Strategies:**\n\n" +
      "**1. OnPush Change Detection:**\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  changeDetection: ChangeDetectionStrategy.OnPush\n" +
      "})\n" +
      "```\n\n" +
      "**2. TrackBy Functions:**\n" +
      "```typescript\n" +
      '<div *ngFor="let item of items; trackBy: trackById">\n' +
      "trackById(index: number, item: Item) {\n" +
      "  return item.id;\n" +
      "}\n" +
      "```\n\n" +
      "**3. Lazy Loading Modules:**\n" +
      "```typescript\n" +
      "loadChildren: () => import('./feature/feature.routes')\n" +
      "```\n\n" +
      "**4. Pure Pipes:**\n" +
      "```typescript\n" +
      "@Pipe({ name: 'filter', pure: true })\n" +
      "```\n\n" +
      "**5. Async Pipe (No Manual Subscriptions):**\n" +
      "```typescript\n" +
      "users$ = this.userService.getUsers();\n" +
      "// Template: {{ users$ | async }}\n" +
      "```\n\n" +
      "**6. Virtual Scrolling:**\n" +
      "```typescript\n" +
      "import { ScrollingModule } from '@angular/cdk/scrolling';\n\n" +
      '<cdk-virtual-scroll-viewport itemSize="50" class="viewport">\n' +
      '  <div *cdkVirtualFor="let item of items" class="item">\n' +
      "    {{ item.name }}\n" +
      "  </div>\n" +
      "</cdk-virtual-scroll-viewport>\n" +
      "```\n\n" +
      "**7. Detach Change Detection:**\n" +
      "```typescript\n" +
      "constructor(private cdr: ChangeDetectorRef) {}\n\n" +
      "ngOnInit() {\n" +
      "  this.cdr.detach();\n" +
      "  // Manually trigger when needed\n" +
      "  this.cdr.detectChanges();\n" +
      "}\n" +
      "```\n\n" +
      "**8. Run Outside Zone:**\n" +
      "```typescript\n" +
      "this.ngZone.runOutsideAngular(() => {\n" +
      "  // Heavy computation\n" +
      "});\n" +
      "```\n\n" +
      "**9. Preload Strategy:**\n" +
      "```typescript\n" +
      "provideRouter(routes, withPreloading(PreloadAllModules))\n" +
      "```\n\n" +
      "**10. Build Optimization:**\n" +
      "```bash\n" +
      "ng build --configuration production\n" +
      "# Enables: AOT, tree-shaking, minification, bundling\n" +
      "```",
    category: "Performance",
    difficulty: "hard",
    tags: ["performance", "optimization", "best-practices", "bundle-size"],
  },
  {
    id: 27,
    question: "What are Custom Validators in Angular? Implement sync and async validators.",
    answer:
      "**Synchronous Validator:**\n\n" +
      "```typescript\n" +
      "import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\n\n" +
      "export function passwordStrength(): ValidatorFn {\n" +
      "  return (control: AbstractControl): ValidationErrors | null => {\n" +
      "    const value = control.value;\n" +
      "    if (!value) return null;\n\n" +
      "    const hasNumber = /[0-9]/.test(value);\n" +
      "    const hasUpper = /[A-Z]/.test(value);\n" +
      "    const hasLower = /[a-z]/.test(value);\n" +
      "    const hasSpecial = /[!@#$%^&*]/.test(value);\n\n" +
      "    const valid = hasNumber && hasUpper && hasLower && hasSpecial;\n" +
      "    return valid ? null : { \n" +
      "      passwordStrength: {\n" +
      "        hasNumber,\n" +
      "        hasUpper,\n" +
      "        hasLower,\n" +
      "        hasSpecial\n" +
      "      }\n" +
      "    };\n" +
      "  };\n" +
      "}\n\n" +
      "// Usage\n" +
      "this.form = this.fb.group({\n" +
      "  password: ['', [Validators.required, passwordStrength()]]\n" +
      "});\n" +
      "```\n\n" +
      "**Async Validator (Check Email Uniqueness):**\n\n" +
      "```typescript\n" +
      "import { AsyncValidatorFn } from '@angular/forms';\n" +
      "import { map, catchError, debounceTime, take } from 'rxjs/operators';\n\n" +
      "export function emailExistsValidator(userService: UserService): AsyncValidatorFn {\n" +
      "  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n" +
      "    if (!control.value) {\n" +
      "      return of(null);\n" +
      "    }\n\n" +
      "    return userService.checkEmailExists(control.value).pipe(\n" +
      "      debounceTime(300), // Wait for user to stop typing\n" +
      "      take(1),\n" +
      "      map(exists => exists ? { emailExists: true } : null),\n" +
      "      catchError(() => of(null))\n" +
      "    );\n" +
      "  };\n" +
      "}\n\n" +
      "// Usage\n" +
      "this.form = this.fb.group({\n" +
      "  email: [\n" +
      "    '',\n" +
      "    [Validators.required, Validators.email], // Sync\n" +
      "    [emailExistsValidator(this.userService)] // Async\n" +
      "  ]\n" +
      "});\n\n" +
      "// Check status\n" +
      "if (this.form.get('email').pending) {\n" +
      "  // Async validation in progress\n" +
      "}\n" +
      "```\n\n" +
      "**Cross-Field Validator:**\n\n" +
      "```typescript\n" +
      "export const passwordMatchValidator: ValidatorFn = (group: AbstractControl): ValidationErrors | null => {\n" +
      "  const password = group.get('password');\n" +
      "  const confirm = group.get('confirmPassword');\n\n" +
      "  return password && confirm && password.value === confirm.value \n" +
      "    ? null \n" +
      "    : { passwordMismatch: true };\n" +
      "};\n\n" +
      "// Apply to FormGroup\n" +
      "this.form = this.fb.group({\n" +
      "  password: [''],\n" +
      "  confirmPassword: ['']\n" +
      "}, { validators: [passwordMatchValidator] });\n" +
      "```",
    category: "Forms",
    difficulty: "intermediate",
    tags: ["validation", "forms", "async-validators", "custom-validators"],
  },
  {
    id: 28,
    question: "How do you handle errors in Angular applications? Implement global error handling.",
    answer:
      "**Global Error Handler:**\n\n" +
      "```typescript\n" +
      "import { ErrorHandler, Injectable, Injector } from '@angular/core';\n\n" +
      "@Injectable()\n" +
      "export class GlobalErrorHandler implements ErrorHandler {\n" +
      "  constructor(private injector: Injector) {}\n\n" +
      "  handleError(error: Error | HttpErrorResponse) {\n" +
      "    const notificationService = this.injector.get(NotificationService);\n\n" +
      "    if (error instanceof HttpErrorResponse) {\n" +
      "      // Server error\n" +
      "      console.error('Server error:', error);\n" +
      "      notificationService.showError(`Server error: ${error.message}`);\n" +
      "    } else {\n" +
      "      // Client error\n" +
      "      console.error('Client error:', error);\n" +
      "      notificationService.showError(`Error: ${error.message}`);\n" +
      "    }\n\n" +
      "    // Log to monitoring service\n" +
      "    this.logError(error);\n" +
      "  }\n\n" +
      "  private logError(error: any) {\n" +
      "    // Send to Sentry, LogRocket, etc.\n" +
      "  }\n" +
      "}\n\n" +
      "// Register\n" +
      "providers: [\n" +
      "  { provide: ErrorHandler, useClass: GlobalErrorHandler }\n" +
      "]\n" +
      "```\n\n" +
      "**HTTP Error Interceptor:**\n\n" +
      "```typescript\n" +
      "export const errorInterceptor: HttpInterceptorFn = (req, next) => {\n" +
      "  return next(req).pipe(\n" +
      "    retry(2),\n" +
      "    catchError((error: HttpErrorResponse) => {\n" +
      "      if (error.status === 401) {\n" +
      "        inject(Router).navigate(['/login']);\n" +
      "      }\n" +
      "      return throwError(() => error);\n" +
      "    })\n" +
      "  );\n" +
      "};\n" +
      "```",
    category: "Error Handling",
    difficulty: "intermediate",
    tags: ["error-handling", "global-error-handler", "http-errors"],
  },
  {
    id: 29,
    question: "What is AOT compilation? How does it differ from JIT and what are the benefits?",
    answer:
      "**AOT (Ahead-of-Time) Compilation:**\n" +
      "Templates compiled during build, before browser downloads code.\n\n" +
      "**JIT (Just-in-Time) Compilation:**\n" +
      "Templates compiled in browser at runtime.\n\n" +
      "**Comparison:**\n\n" +
      "| Feature | AOT | JIT |\n" +
      "|---------|-----|-----|\n" +
      "| Compilation | Build time | Runtime |\n" +
      "| Bundle size | Smaller | Larger (includes compiler) |\n" +
      "| Load time | Faster | Slower |\n" +
      "| Template errors | Build time | Runtime |\n" +
      "| Production | Yes | No |\n" +
      "| Development | Slower builds | Faster builds |\n\n" +
      "**AOT Benefits:**\n\n" +
      "1. **Faster Rendering:** Pre-compiled templates\n" +
      "2. **Smaller Bundles:** No compiler in bundle\n" +
      "3. **Earlier Error Detection:** Template errors at build\n" +
      "4. **Better Security:** No eval() or new Function()\n" +
      "5. **Tree-Shaking:** Unused code removed\n\n" +
      "**Angular CLI:**\n\n" +
      "```bash\n" +
      "# Development (JIT by default)\n" +
      "ng serve\n\n" +
      "# Production (AOT by default)\n" +
      "ng build --configuration production\n" +
      "```",
    category: "Build & Compilation",
    difficulty: "intermediate",
    tags: ["aot", "jit", "compilation", "performance", "build"],
  },
  {
    id: 30,
    question: "What are Angular Animations? Provide basic and advanced examples.",
    answer:
      "**Basic Animation:**\n\n" +
      "```typescript\n" +
      "import { trigger, state, style, transition, animate } from '@angular/animations';\n\n" +
      "@Component({\n" +
      "  animations: [\n" +
      "    trigger('openClose', [\n" +
      "      state('open', style({\n" +
      "        height: '200px',\n" +
      "        opacity: 1\n" +
      "      })),\n" +
      "      state('closed', style({\n" +
      "        height: '100px',\n" +
      "        opacity: 0.5\n" +
      "      })),\n" +
      "      transition('open <=> closed', [\n" +
      "        animate('0.3s ease-in-out')\n" +
      "      ])\n" +
      "    ])\n" +
      "  ]\n" +
      "})\n" +
      "export class AnimatedComponent {\n" +
      "  isOpen = true;\n" +
      "}\n\n" +
      "// Template\n" +
      "<div [@openClose]=\"isOpen ? 'open' : 'closed'\">Content</div>\n" +
      '<button (click)="isOpen = !isOpen">Toggle</button>\n' +
      "```\n\n" +
      "**Enter/Leave Animations:**\n\n" +
      "```typescript\n" +
      "trigger('fadeIn', [\n" +
      "  transition(':enter', [\n" +
      "    style({ opacity: 0 }),\n" +
      "    animate('300ms', style({ opacity: 1 }))\n" +
      "  ]),\n" +
      "  transition(':leave', [\n" +
      "    animate('300ms', style({ opacity: 0 }))\n" +
      "  ])\n" +
      "])\n\n" +
      "// Template\n" +
      '<div *ngIf="isVisible" @fadeIn>Fades in/out</div>\n' +
      "```\n\n" +
      "**List Animations:**\n\n" +
      "```typescript\n" +
      "import { query, stagger } from '@angular/animations';\n\n" +
      "trigger('listAnimation', [\n" +
      "  transition('* => *', [\n" +
      "    query(':enter', [\n" +
      "      style({ opacity: 0, transform: 'translateY(-10px)' }),\n" +
      "      stagger(100, [\n" +
      "        animate('300ms', style({ opacity: 1, transform: 'translateY(0)' }))\n" +
      "      ])\n" +
      "    ], { optional: true })\n" +
      "  ])\n" +
      "])\n\n" +
      '<div *ngFor="let item of items" @listAnimation>{{ item }}</div>\n' +
      "```",
    category: "Animations",
    difficulty: "intermediate",
    tags: ["animations", "transitions", "ui", "user-experience"],
  },
  {
    id: 31,
    question:
      "Explain Dynamic Component Loading in Angular. How do you create and destroy components programmatically?",
    answer:
      "Dynamic components are created programmatically at runtime, not declared in templates.\n\n" +
      "**Dynamic Component Loading:**\n\n" +
      "```typescript\n" +
      "import { Component, ViewChild, ViewContainerRef, ComponentRef } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  selector: 'app-container',\n" +
      "  template: '<ng-container #dynamicContainer></ng-container>'\n" +
      "})\n" +
      "export class ContainerComponent {\n" +
      "  @ViewChild('dynamicContainer', { read: ViewContainerRef }) \n" +
      "  container: ViewContainerRef;\n\n" +
      "  private componentRef: ComponentRef<unknown>;\n\n" +
      "  loadComponent() {\n" +
      "    // Clear existing\n" +
      "    this.container.clear();\n\n" +
      "    // Create component\n" +
      "    this.componentRef = this.container.createComponent(DynamicComponent);\n\n" +
      "    // Set inputs\n" +
      "    this.componentRef.instance.data = { title: 'Dynamic' };\n\n" +
      "    // Subscribe to outputs\n" +
      "    this.componentRef.instance.action.subscribe(event => {\n" +
      "      console.log('Event from dynamic component:', event);\n" +
      "    });\n\n" +
      "    // Trigger change detection\n" +
      "    this.componentRef.changeDetectorRef.detectChanges();\n" +
      "  }\n\n" +
      "  destroyComponent() {\n" +
      "    if (this.componentRef) {\n" +
      "      this.componentRef.destroy();\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Use Cases:**\n" +
      "- Modal dialogs\n" +
      "- Toast notifications\n" +
      "- Dynamic forms\n" +
      "- Plugin architecture\n" +
      "- Dashboard widgets\n\n" +
      "**Modal Service Example:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class ModalService {\n" +
      "  constructor(\n" +
      "    private appRef: ApplicationRef,\n" +
      "    private injector: Injector\n" +
      "  ) {}\n\n" +
      "  open(component: Type<unknown>, data?: unknown): ComponentRef<unknown> {\n" +
      "    // Create component\n" +
      "    const componentRef = createComponent(component, {\n" +
      "      environmentInjector: this.appRef.injector\n" +
      "    });\n\n" +
      "    // Set data\n" +
      "    if (data) {\n" +
      "      Object.assign(componentRef.instance, data);\n" +
      "    }\n\n" +
      "    // Attach to DOM\n" +
      "    this.appRef.attachView(componentRef.hostView);\n" +
      "    const domElem = (componentRef.hostView as EmbeddedViewRef<unknown>).rootNodes[0];\n" +
      "    document.body.appendChild(domElem);\n\n" +
      "    return componentRef;\n" +
      "  }\n\n" +
      "  close(componentRef: ComponentRef<unknown>) {\n" +
      "    this.appRef.detachView(componentRef.hostView);\n" +
      "    componentRef.destroy();\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage\n" +
      "const modalRef = this.modalService.open(ConfirmDialogComponent, {\n" +
      "  message: 'Are you sure?'\n" +
      "});\n\n" +
      "modalRef.instance.confirmed.subscribe(() => {\n" +
      "  console.log('Confirmed!');\n" +
      "  this.modalService.close(modalRef);\n" +
      "});\n" +
      "```",
    category: "Advanced Patterns",
    difficulty: "hard",
    tags: ["dynamic-components", "viewcontainerref", "componentref", "advanced"],
  },
  {
    id: 32,
    question:
      "What is ViewEncapsulation in Angular? Explain Emulated, ShadowDom, and None strategies.",
    answer:
      "ViewEncapsulation controls how component styles are scoped and applied.\n\n" +
      "**Three Strategies:**\n\n" +
      "**1. Emulated (Default):**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-user',\n" +
      "  styles: [`\n" +
      "    h1 { color: blue; }\n" +
      "  `],\n" +
      "  encapsulation: ViewEncapsulation.Emulated // Default\n" +
      "})\n" +
      "export class UserComponent {}\n\n" +
      "// Angular adds unique attributes:\n" +
      "// <h1 _ngcontent-abc-123>Title</h1>\n" +
      "// h1[_ngcontent-abc-123] { color: blue; }\n" +
      "// Styles scoped to component only\n" +
      "```\n\n" +
      "**2. ShadowDom (Native):**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  encapsulation: ViewEncapsulation.ShadowDom\n" +
      "})\n" +
      "// Uses native Shadow DOM\n" +
      "// True style isolation\n" +
      "// Doesn't work in older browsers\n" +
      "```\n\n" +
      "**3. None (Global):**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  encapsulation: ViewEncapsulation.None\n" +
      "})\n" +
      "// Styles applied globally\n" +
      "// Can affect other components\n" +
      "// Use for theme overrides\n" +
      "```\n\n" +
      "**When to Use Each:**\n" +
      "- Emulated: Default, best for most cases\n" +
      "- ShadowDom: True isolation, web components\n" +
      "- None: Global styles, third-party lib overrides",
    category: "Styling",
    difficulty: "intermediate",
    tags: ["view-encapsulation", "styles", "shadow-dom", "css"],
  },
  {
    id: 33,
    question: "What are Template Reference Variables in Angular? How do you use them?",
    answer:
      "Template reference variables (#var) reference DOM elements or components in templates.\n\n" +
      "**Basic Usage:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  template: `\n" +
      "    <!-- Reference input element -->\n" +
      '    <input #nameInput type="text" />\n' +
      '    <button (click)="nameInput.focus()">Focus Input</button>\n' +
      "    <p>Value: {{ nameInput.value }}</p>\n\n" +
      "    <!-- Reference form -->\n" +
      '    <form #myForm="ngForm">\n' +
      '      <input name="email" ngModel required />\n' +
      '      <button [disabled]="myForm.invalid">Submit</button>\n' +
      "      <p>Valid: {{ myForm.valid }}</p>\n" +
      "    </form>\n\n" +
      "    <!-- Reference component -->\n" +
      "    <app-child #childComp></app-child>\n" +
      '    <button (click)="childComp.doSomething()">Call Child Method</button>\n' +
      "  `\n" +
      "})\n" +
      "export class TemplateRefComponent {}\n" +
      "```\n\n" +
      "**Access in Component Class:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  template: '<input #myInput />'\n" +
      "})\n" +
      "export class Component implements AfterViewInit {\n" +
      "  @ViewChild('myInput') input: ElementRef;\n\n" +
      "  ngAfterViewInit() {\n" +
      "    this.input.nativeElement.focus();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Common Patterns:**\n\n" +
      "```typescript\n" +
      "// Pass to child component\n" +
      "<input #searchInput />\n" +
      '<app-search-results [input]="searchInput"></app-search-results>\n\n' +
      "// Call methods\n" +
      '<video #videoPlayer src="movie.mp4"></video>\n' +
      '<button (click)="videoPlayer.play()">Play</button>\n' +
      '<button (click)="videoPlayer.pause()">Pause</button>\n\n' +
      "// Check state\n" +
      '<form #f="ngForm">\n' +
      '  <div *ngIf="f.submitted && f.invalid">\n' +
      "    Please fix errors\n" +
      "  </div>\n" +
      "</form>\n" +
      "```",
    category: "Templates",
    difficulty: "easy",
    tags: ["template-reference", "dom-access", "templates"],
  },
  {
    id: 34,
    question:
      "What is Renderer2 in Angular? Why should you use it instead of direct DOM manipulation?",
    answer:
      "Renderer2 is Angular's abstraction for safe, platform-agnostic DOM manipulation.\n\n" +
      "**Why Not Direct DOM Manipulation:**\n\n" +
      "```typescript\n" +
      "// ❌ BAD - Direct DOM access\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  @ViewChild('div') div: ElementRef;\n\n" +
      "  ngAfterViewInit() {\n" +
      "    // Breaks SSR, Web Workers, doesn't work in all platforms\n" +
      "    this.div.nativeElement.style.color = 'red';\n" +
      "    this.div.nativeElement.addEventListener('click', this.onClick);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**✅ Good - Use Renderer2:**\n\n" +
      "```typescript\n" +
      "import { Renderer2 } from '@angular/core';\n\n" +
      "@Component({...})\n" +
      "export class Component implements AfterViewInit, OnDestroy {\n" +
      "  @ViewChild('div') div: ElementRef;\n" +
      "  private listeners: (() => void)[] = [];\n\n" +
      "  constructor(private renderer: Renderer2) {}\n\n" +
      "  ngAfterViewInit() {\n" +
      "    const el = this.div.nativeElement;\n\n" +
      "    // Set styles\n" +
      "    this.renderer.setStyle(el, 'color', 'red');\n" +
      "    this.renderer.setStyle(el, 'font-size', '20px');\n\n" +
      "    // Add/remove classes\n" +
      "    this.renderer.addClass(el, 'active');\n" +
      "    this.renderer.removeClass(el, 'inactive');\n\n" +
      "    // Set attributes\n" +
      "    this.renderer.setAttribute(el, 'data-id', '123');\n" +
      "    this.renderer.removeAttribute(el, 'disabled');\n\n" +
      "    // Create elements\n" +
      "    const span = this.renderer.createElement('span');\n" +
      "    const text = this.renderer.createText('Hello');\n" +
      "    this.renderer.appendChild(span, text);\n" +
      "    this.renderer.appendChild(el, span);\n\n" +
      "    // Event listeners (returns cleanup function)\n" +
      "    const unlisten = this.renderer.listen(el, 'click', (event) => {\n" +
      "      console.log('Clicked!', event);\n" +
      "    });\n" +
      "    this.listeners.push(unlisten);\n\n" +
      "    // Set properties\n" +
      "    this.renderer.setProperty(el, 'innerHTML', '<strong>Bold</strong>');\n" +
      "  }\n\n" +
      "  ngOnDestroy() {\n" +
      "    // Clean up listeners\n" +
      "    this.listeners.forEach(unlisten => unlisten());\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "1. Platform-agnostic (works in SSR, Web Workers)\n" +
      "2. Safer (prevents XSS when used correctly)\n" +
      "3. Testable\n" +
      "4. Future-proof\n\n" +
      "**Custom Directive with Renderer2:**\n\n" +
      "```typescript\n" +
      "@Directive({\n" +
      "  selector: '[appTooltip]',\n" +
      "  standalone: true\n" +
      "})\n" +
      "export class TooltipDirective implements OnInit, OnDestroy {\n" +
      "  @Input() appTooltip: string;\n" +
      "  private tooltipElement: HTMLElement;\n\n" +
      "  constructor(\n" +
      "    private el: ElementRef,\n" +
      "    private renderer: Renderer2\n" +
      "  ) {}\n\n" +
      "  @HostListener('mouseenter') onMouseEnter() {\n" +
      "    this.show();\n" +
      "  }\n\n" +
      "  @HostListener('mouseleave') onMouseLeave() {\n" +
      "    this.hide();\n" +
      "  }\n\n" +
      "  private show() {\n" +
      "    this.tooltipElement = this.renderer.createElement('div');\n" +
      "    const text = this.renderer.createText(this.appTooltip);\n" +
      "    \n" +
      "    this.renderer.appendChild(this.tooltipElement, text);\n" +
      "    this.renderer.addClass(this.tooltipElement, 'tooltip');\n" +
      "    this.renderer.setStyle(this.tooltipElement, 'position', 'absolute');\n" +
      "    \n" +
      "    this.renderer.appendChild(document.body, this.tooltipElement);\n" +
      "  }\n\n" +
      "  private hide() {\n" +
      "    if (this.tooltipElement) {\n" +
      "      this.renderer.removeChild(document.body, this.tooltipElement);\n" +
      "    }\n" +
      "  }\n\n" +
      "  ngOnDestroy() {\n" +
      "    this.hide();\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "DOM Manipulation",
    difficulty: "hard",
    tags: ["renderer2", "dom", "ssr", "directives", "safe-dom"],
  },
  {
    id: 35,
    question:
      "What is FormArray in Angular? How do you implement dynamic forms with add/remove functionality?",
    answer:
      "FormArray manages a dynamic array of form controls, useful for dynamic forms.\n\n" +
      "**Dynamic Form with FormArray:**\n\n" +
      "```typescript\n" +
      "import { FormBuilder, FormArray, FormGroup, Validators } from '@angular/forms';\n\n" +
      "@Component({\n" +
      "  template: `\n" +
      '    <form [formGroup]="form" (ngSubmit)="onSubmit()">\n' +
      '      <div formArrayName="skills">\n' +
      '        <div *ngFor="let skill of skills.controls; let i = index" [formGroupName]="i">\n' +
      '          <input formControlName="name" placeholder="Skill name" />\n' +
      '          <select formControlName="level">\n' +
      '            <option value="beginner">Beginner</option>\n' +
      '            <option value="intermediate">Intermediate</option>\n' +
      '            <option value="expert">Expert</option>\n' +
      "          </select>\n" +
      '          <input formControlName="years" type="number" placeholder="Years" />\n' +
      '          <button type="button" (click)="removeSkill(i)">Remove</button>\n' +
      "        </div>\n" +
      "      </div>\n" +
      "      \n" +
      '      <button type="button" (click)="addSkill()">Add Skill</button>\n' +
      '      <button type="submit" [disabled]="form.invalid">Submit</button>\n' +
      "    </form>\n" +
      "    \n" +
      "    <pre>{{ form.value | json }}</pre>\n" +
      "  `\n" +
      "})\n" +
      "export class DynamicFormComponent {\n" +
      "  form: FormGroup;\n\n" +
      "  constructor(private fb: FormBuilder) {\n" +
      "    this.form = this.fb.group({\n" +
      "      name: ['', Validators.required],\n" +
      "      skills: this.fb.array([]) // Empty array initially\n" +
      "    });\n" +
      "  }\n\n" +
      "  get skills(): FormArray {\n" +
      "    return this.form.get('skills') as FormArray;\n" +
      "  }\n\n" +
      "  createSkillForm(): FormGroup {\n" +
      "    return this.fb.group({\n" +
      "      name: ['', Validators.required],\n" +
      "      level: ['beginner'],\n" +
      "      years: [0, [Validators.required, Validators.min(0)]]\n" +
      "    });\n" +
      "  }\n\n" +
      "  addSkill() {\n" +
      "    this.skills.push(this.createSkillForm());\n" +
      "  }\n\n" +
      "  removeSkill(index: number) {\n" +
      "    this.skills.removeAt(index);\n" +
      "  }\n\n" +
      "  onSubmit() {\n" +
      "    if (this.form.valid) {\n" +
      "      console.log(this.form.value);\n" +
      "      // Output: { name: 'John', skills: [{ name: 'Angular', level: 'expert', years: 3 }] }\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Validation:**\n\n" +
      "```typescript\n" +
      "// Array-level validation\n" +
      "this.form = this.fb.group({\n" +
      "  skills: this.fb.array([], Validators.minLength(1)) // At least 1 skill\n" +
      "});\n\n" +
      "// Access errors\n" +
      "if (this.skills.hasError('minLength')) {\n" +
      "  console.log('Add at least one skill');\n" +
      "}\n" +
      "```\n\n" +
      "**Patch Values:**\n\n" +
      "```typescript\n" +
      "// Load existing data\n" +
      "ngOnInit() {\n" +
      "  const userData = {\n" +
      "    name: 'John',\n" +
      "    skills: [\n" +
      "      { name: 'Angular', level: 'expert', years: 3 },\n" +
      "      { name: 'TypeScript', level: 'intermediate', years: 2 }\n" +
      "    ]\n" +
      "  };\n\n" +
      "  // Clear and repopulate\n" +
      "  this.skills.clear();\n" +
      "  userData.skills.forEach(skill => {\n" +
      "    this.skills.push(this.fb.group(skill));\n" +
      "  });\n" +
      "}\n" +
      "```",
    category: "Forms",
    difficulty: "hard",
    tags: ["formarray", "dynamic-forms", "reactive-forms", "validation"],
  },
  {
    id: 36,
    question: "Explain @HostListener and @HostBinding decorators. Provide practical examples.",
    answer:
      "@HostListener listens to host element events. @HostBinding binds to host element properties.\n\n" +
      "**@HostListener - Event Handling:**\n\n" +
      "```typescript\n" +
      "@Directive({\n" +
      "  selector: '[appClickOutside]',\n" +
      "  standalone: true\n" +
      "})\n" +
      "export class ClickOutsideDirective {\n" +
      "  @Output() clickOutside = new EventEmitter<void>();\n\n" +
      "  @HostListener('document:click', ['$event'])\n" +
      "  onClick(event: MouseEvent) {\n" +
      "    const clickedInside = this.el.nativeElement.contains(event.target);\n" +
      "    if (!clickedInside) {\n" +
      "      this.clickOutside.emit();\n" +
      "    }\n" +
      "  }\n\n" +
      "  constructor(private el: ElementRef) {}\n" +
      "}\n\n" +
      '// Usage: <div appClickOutside (clickOutside)="closeMenu()">Menu</div>\n' +
      "```\n\n" +
      "**@HostBinding - Property Binding:**\n\n" +
      "```typescript\n" +
      "@Directive({\n" +
      "  selector: '[appHighlight]',\n" +
      "  standalone: true\n" +
      "})\n" +
      "export class HighlightDirective {\n" +
      "  @Input() appHighlight = 'yellow';\n" +
      "  @HostBinding('style.backgroundColor') backgroundColor: string;\n" +
      "  @HostBinding('class.highlighted') isHighlighted = false;\n\n" +
      "  @HostListener('mouseenter')\n" +
      "  onMouseEnter() {\n" +
      "    this.backgroundColor = this.appHighlight;\n" +
      "    this.isHighlighted = true;\n" +
      "  }\n\n" +
      "  @HostListener('mouseleave')\n" +
      "  onMouseLeave() {\n" +
      "    this.backgroundColor = '';\n" +
      "    this.isHighlighted = false;\n" +
      "  }\n" +
      "}\n\n" +
      '// Usage: <div appHighlight="lightblue">Hover me</div>\n' +
      '// Result: <div class="highlighted" style="background-color: lightblue">Hover me</div>\n' +
      "```\n\n" +
      "**Complex Example - Draggable:**\n\n" +
      "```typescript\n" +
      "@Directive({\n" +
      "  selector: '[appDraggable]',\n" +
      "  standalone: true\n" +
      "})\n" +
      "export class DraggableDirective {\n" +
      "  @HostBinding('style.position') position = 'absolute';\n" +
      "  @HostBinding('style.left.px') left = 0;\n" +
      "  @HostBinding('style.top.px') top = 0;\n" +
      "  @HostBinding('style.cursor') cursor = 'move';\n\n" +
      "  private isDragging = false;\n" +
      "  private startX = 0;\n" +
      "  private startY = 0;\n\n" +
      "  @HostListener('mousedown', ['$event'])\n" +
      "  onMouseDown(event: MouseEvent) {\n" +
      "    this.isDragging = true;\n" +
      "    this.startX = event.clientX - this.left;\n" +
      "    this.startY = event.clientY - this.top;\n" +
      "    event.preventDefault();\n" +
      "  }\n\n" +
      "  @HostListener('document:mousemove', ['$event'])\n" +
      "  onMouseMove(event: MouseEvent) {\n" +
      "    if (this.isDragging) {\n" +
      "      this.left = event.clientX - this.startX;\n" +
      "      this.top = event.clientY - this.startY;\n" +
      "    }\n" +
      "  }\n\n" +
      "  @HostListener('document:mouseup')\n" +
      "  onMouseUp() {\n" +
      "    this.isDragging = false;\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage: <div appDraggable>Drag me!</div>\n" +
      "```",
    category: "Directives",
    difficulty: "intermediate",
    tags: ["hostlistener", "hostbinding", "directives", "events"],
  },
  {
    id: 37,
    question: "What is Angular Universal (SSR)? How do you implement server-side rendering?",
    answer:
      "Angular Universal enables server-side rendering (SSR) for faster initial loads and better SEO.\n\n" +
      "**Setup:**\n\n" +
      "```bash\n" +
      "ng add @nguniversal/express-engine\n" +
      "```\n\n" +
      "**Server Configuration:**\n\n" +
      "```typescript\n" +
      "// server.ts\n" +
      "import { APP_BASE_HREF } from '@angular/common';\n" +
      "import { CommonEngine } from '@angular/ssr';\n" +
      "import express from 'express';\n\n" +
      "const app = express();\n" +
      "const commonEngine = new CommonEngine();\n\n" +
      "app.get('*', (req, res) => {\n" +
      "  commonEngine\n" +
      "    .render({\n" +
      "      bootstrap: AppServerModule,\n" +
      "      documentFilePath: indexHtml,\n" +
      "      url: req.url,\n" +
      "      publicPath: distFolder,\n" +
      "      providers: [\n" +
      "        { provide: APP_BASE_HREF, useValue: req.baseUrl }\n" +
      "      ]\n" +
      "    })\n" +
      "    .then(html => res.send(html))\n" +
      "    .catch(err => res.status(500).send(err));\n" +
      "});\n\n" +
      "app.listen(4000, () => {\n" +
      "  console.log('Server listening on http://localhost:4000');\n" +
      "});\n" +
      "```\n\n" +
      "**Platform-Agnostic Code:**\n\n" +
      "```typescript\n" +
      "import { isPlatformBrowser } from '@angular/common';\n" +
      "import { PLATFORM_ID, inject } from '@angular/core';\n\n" +
      "@Component({...})\n" +
      "export class Component implements OnInit {\n" +
      "  private platformId = inject(PLATFORM_ID);\n\n" +
      "  ngOnInit() {\n" +
      "    // ❌ Breaks SSR\n" +
      "    localStorage.setItem('key', 'value');\n" +
      "    window.addEventListener('resize', this.onResize);\n\n" +
      "    // ✅ Check platform first\n" +
      "    if (isPlatformBrowser(this.platformId)) {\n" +
      "      localStorage.setItem('key', 'value');\n" +
      "      window.addEventListener('resize', this.onResize);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "1. Faster First Contentful Paint\n" +
      "2. Better SEO (crawlers see full HTML)\n" +
      "3. Social media preview (og:tags)\n" +
      "4. Works without JavaScript\n\n" +
      "**Challenges:**\n" +
      "- No browser APIs (window, document, localStorage)\n" +
      "- Different lifecycle on server\n" +
      "- Must handle async data carefully\n" +
      "- Increased server costs",
    category: "SSR",
    difficulty: "hard",
    tags: ["ssr", "universal", "seo", "performance", "server"],
  },
  {
    id: 38,
    question:
      "How do you implement internationalization (i18n) in Angular? Explain runtime vs compile-time i18n.",
    answer:
      "**Angular Built-in i18n (Compile-Time):**\n\n" +
      "```html\n" +
      "<!-- Mark text for translation -->\n" +
      "<h1 i18n>Hello</h1>\n" +
      '<p i18n="User greeting">Welcome, {{name}}</p>\n\n' +
      "<!-- With description and meaning -->\n" +
      '<button i18n="Delete button|Button to delete item@@deleteButton">\n' +
      "  Delete\n" +
      "</button>\n\n" +
      "<!-- Attributes -->\n" +
      '<img [src]="logo" i18n-title title="Company Logo" />\n' +
      "```\n\n" +
      "**Extract Messages:**\n\n" +
      "```bash\n" +
      "ng extract-i18n --output-path src/locale\n" +
      "# Generates: messages.xlf (source file)\n" +
      "```\n\n" +
      "**Build for Each Locale:**\n\n" +
      "```bash\n" +
      "ng build --localize\n" +
      "# Builds: dist/en/, dist/fr/, dist/es/\n" +
      "```\n\n" +
      "**Runtime i18n (ngx-translate):**\n\n" +
      "```typescript\n" +
      "import { TranslateModule, TranslateLoader } from '@ngx-translate/core';\n\n" +
      "@Component({\n" +
      "  imports: [TranslateModule],\n" +
      "  template: `\n" +
      "    <h1>{{ 'HELLO' | translate }}</h1>\n" +
      "    <p>{{ 'WELCOME' | translate:{ name: userName } }}</p>\n" +
      "    \n" +
      '    <select (change)="switchLanguage($event)">\n' +
      '      <option value="en">English</option>\n' +
      '      <option value="fr">Français</option>\n' +
      "    </select>\n" +
      "  `\n" +
      "})\n" +
      "export class Component {\n" +
      "  constructor(private translate: TranslateService) {\n" +
      "    translate.setDefaultLang('en');\n" +
      "    translate.use('en');\n" +
      "  }\n\n" +
      "  switchLanguage(event: any) {\n" +
      "    this.translate.use(event.target.value);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Translation Files:**\n\n" +
      "```json\n" +
      "// assets/i18n/en.json\n" +
      "{\n" +
      '  "HELLO": "Hello",\n' +
      '  "WELCOME": "Welcome, {{name}}"\n' +
      "}\n\n" +
      "// assets/i18n/fr.json\n" +
      "{\n" +
      '  "HELLO": "Bonjour",\n' +
      '  "WELCOME": "Bienvenue, {{name}}"\n' +
      "}\n" +
      "```",
    category: "Internationalization",
    difficulty: "intermediate",
    tags: ["i18n", "internationalization", "localization", "translation"],
  },
  {
    id: 39,
    question: "What is the Angular CDK (Component Dev Kit)? Explain key modules and use cases.",
    answer:
      "Angular CDK provides behavior primitives for building UI components without Material Design styling.\n\n" +
      "**Key CDK Modules:**\n\n" +
      "**1. Virtual Scrolling:**\n\n" +
      "```typescript\n" +
      "import { ScrollingModule } from '@angular/cdk/scrolling';\n\n" +
      "@Component({\n" +
      "  imports: [ScrollingModule],\n" +
      "  template: `\n" +
      '    <cdk-virtual-scroll-viewport itemSize="50" class="viewport">\n' +
      '      <div *cdkVirtualFor="let item of items" class="item">\n' +
      "        {{ item.name }}\n" +
      "      </div>\n" +
      "    </cdk-virtual-scroll-viewport>\n" +
      "  `,\n" +
      "  styles: ['.viewport { height: 400px; }']\n" +
      "})\n" +
      "export class VirtualListComponent {\n" +
      "  items = Array.from({ length: 10000 }, (_, i) => ({ \n" +
      "    id: i, \n" +
      "    name: `Item ${i}` \n" +
      "  }));\n" +
      "}\n" +
      "// Only renders visible items - handles 100k+ items smoothly\n" +
      "```\n\n" +
      "**2. Drag and Drop:**\n\n" +
      "```typescript\n" +
      "import { DragDropModule, CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop';\n\n" +
      "@Component({\n" +
      "  imports: [DragDropModule],\n" +
      "  template: `\n" +
      '    <div cdkDropList (cdkDropListDropped)="drop($event)">\n' +
      '      <div *ngFor="let item of items" cdkDrag>\n' +
      "        {{ item }}\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class DragDropComponent {\n" +
      "  items = ['Item 1', 'Item 2', 'Item 3'];\n\n" +
      "  drop(event: CdkDragDrop<string[]>) {\n" +
      "    moveItemInArray(this.items, event.previousIndex, event.currentIndex);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. Overlay (Modals, Dropdowns):**\n\n" +
      "```typescript\n" +
      "import { Overlay, OverlayRef } from '@angular/cdk/overlay';\n" +
      "import { ComponentPortal } from '@angular/cdk/portal';\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class DialogService {\n" +
      "  private overlayRef: OverlayRef;\n\n" +
      "  constructor(private overlay: Overlay) {}\n\n" +
      "  open(component: Type<unknown>) {\n" +
      "    const positionStrategy = this.overlay\n" +
      "      .position()\n" +
      "      .global()\n" +
      "      .centerHorizontally()\n" +
      "      .centerVertically();\n\n" +
      "    this.overlayRef = this.overlay.create({\n" +
      "      hasBackdrop: true,\n" +
      "      backdropClass: 'dark-backdrop',\n" +
      "      positionStrategy\n" +
      "    });\n\n" +
      "    const portal = new ComponentPortal(component);\n" +
      "    this.overlayRef.attach(portal);\n\n" +
      "    // Close on backdrop click\n" +
      "    this.overlayRef.backdropClick().subscribe(() => this.close());\n" +
      "  }\n\n" +
      "  close() {\n" +
      "    this.overlayRef?.dispose();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Other CDK Modules:**\n" +
      "- Accessibility (A11y, FocusTrap)\n" +
      "- Layout (Breakpoint Observer)\n" +
      "- Clipboard\n" +
      "- Platform detection\n" +
      "- Bi-directionality (RTL support)",
    category: "CDK",
    difficulty: "hard",
    tags: ["cdk", "virtual-scroll", "drag-drop", "overlay", "angular-material"],
  },
  {
    id: 40,
    question:
      "How do you implement accessibility (a11y) in Angular applications? Provide ARIA examples.",
    answer:
      "Accessibility ensures your app works for all users, including those using assistive technologies.\n\n" +
      "**ARIA Attributes:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  template: `\n" +
      "    <!-- Semantic HTML first -->\n" +
      '    <button (click)="save()">Save</button> <!-- Better than <div> -->\n\n' +
      "    <!-- ARIA labels -->\n" +
      '    <button aria-label="Close dialog" (click)="close()">\n' +
      '      <span aria-hidden="true">&times;</span>\n' +
      "    </button>\n\n" +
      "    <!-- ARIA roles -->\n" +
      '    <div role="alert" *ngIf="error">{{ error }}</div>\n\n' +
      "    <!-- ARIA live regions -->\n" +
      '    <div aria-live="polite" aria-atomic="true">\n' +
      "      {{ statusMessage }}\n" +
      "    </div>\n\n" +
      "    <!-- Form labels -->\n" +
      '    <label for="email">Email:</label>\n' +
      '    <input id="email" type="email" aria-required="true" />\n' +
      '    <span id="email-error" role="alert">{{ emailError }}</span>\n' +
      '    <input aria-describedby="email-error" />\n\n' +
      "    <!-- Expandable sections -->\n" +
      "    <button \n" +
      '      (click)="toggle()"\n' +
      '      [attr.aria-expanded]="isExpanded"\n' +
      '      aria-controls="content"\n' +
      "    >\n" +
      "      Toggle\n" +
      "    </button>\n" +
      '    <div id="content" [hidden]="!isExpanded">\n' +
      "      Content here\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "```\n\n" +
      "**Focus Management:**\n\n" +
      "```typescript\n" +
      "import { FocusMonitor } from '@angular/cdk/a11y';\n\n" +
      "@Component({...})\n" +
      "export class DialogComponent implements AfterViewInit, OnDestroy {\n" +
      "  @ViewChild('closeButton') closeButton: ElementRef;\n" +
      "  private previousActiveElement: HTMLElement;\n\n" +
      "  constructor(private focusMonitor: FocusMonitor) {}\n\n" +
      "  ngAfterViewInit() {\n" +
      "    // Save currently focused element\n" +
      "    this.previousActiveElement = document.activeElement as HTMLElement;\n\n" +
      "    // Focus first element in modal\n" +
      "    this.closeButton.nativeElement.focus();\n\n" +
      "    // Monitor focus\n" +
      "    this.focusMonitor.monitor(this.closeButton);\n" +
      "  }\n\n" +
      "  ngOnDestroy() {\n" +
      "    // Restore focus\n" +
      "    if (this.previousActiveElement) {\n" +
      "      this.previousActiveElement.focus();\n" +
      "    }\n" +
      "    this.focusMonitor.stopMonitoring(this.closeButton);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Keyboard Navigation:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class MenuComponent {\n" +
      "  selectedIndex = 0;\n\n" +
      "  @HostListener('keydown', ['$event'])\n" +
      "  handleKeyboard(event: KeyboardEvent) {\n" +
      "    switch(event.key) {\n" +
      "      case 'ArrowDown':\n" +
      "        this.selectedIndex++;\n" +
      "        event.preventDefault();\n" +
      "        break;\n" +
      "      case 'ArrowUp':\n" +
      "        this.selectedIndex--;\n" +
      "        event.preventDefault();\n" +
      "        break;\n" +
      "      case 'Enter':\n" +
      "        this.selectItem(this.selectedIndex);\n" +
      "        break;\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Accessibility",
    difficulty: "intermediate",
    tags: ["accessibility", "a11y", "aria", "keyboard", "focus"],
  },
  {
    id: 41,
    question:
      "Explain Angular security best practices. How do you prevent XSS, CSRF, and other attacks?",
    answer:
      "Angular has built-in security features, but you must use them correctly.\n\n" +
      "**XSS Prevention:**\n\n" +
      "```typescript\n" +
      "import { DomSanitizer, SafeHtml } from '@angular/platform-browser';\n\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  userInput: string;\n\n" +
      "  constructor(private sanitizer: DomSanitizer) {}\n\n" +
      "  // ❌ DANGEROUS - XSS vulnerability\n" +
      "  get unsafeHtml() {\n" +
      "    return this.userInput; // If contains <script>, will execute!\n" +
      "  }\n\n" +
      "  // ✅ Safe - Angular auto-sanitizes\n" +
      "  // Template: <div>{{ userInput }}</div>\n" +
      "  // Angular escapes HTML automatically\n\n" +
      "  // If you MUST use innerHTML:\n" +
      "  get safeHtml(): SafeHtml {\n" +
      "    return this.sanitizer.sanitize(SecurityContext.HTML, this.userInput);\n" +
      "  }\n" +
      '  // Template: <div [innerHTML]="safeHtml"></div>\n' +
      "}\n" +
      "```\n\n" +
      "**CSRF Protection:**\n\n" +
      "```typescript\n" +
      "// Angular's HttpClient includes CSRF protection\n" +
      "import { provideHttpClient, withXsrfConfiguration } from '@angular/common/http';\n\n" +
      "providers: [\n" +
      "  provideHttpClient(\n" +
      "    withXsrfConfiguration({\n" +
      "      cookieName: 'XSRF-TOKEN',\n" +
      "      headerName: 'X-XSRF-TOKEN'\n" +
      "    })\n" +
      "  )\n" +
      "]\n\n" +
      "// Server must:\n" +
      "// 1. Set XSRF-TOKEN cookie\n" +
      "// 2. Verify X-XSRF-TOKEN header matches\n" +
      "```\n\n" +
      "**Content Security Policy (CSP):**\n\n" +
      "```html\n" +
      "<!-- index.html -->\n" +
      '<meta http-equiv="Content-Security-Policy" \n' +
      "      content=\"default-src 'self'; \n" +
      "               script-src 'self'; \n" +
      "               style-src 'self' 'unsafe-inline'; \n" +
      "               img-src 'self' data: https:;\">\n" +
      "```\n\n" +
      "**URL Sanitization:**\n\n" +
      "```typescript\n" +
      "// ❌ Dangerous\n" +
      '<a [href]="userProvidedUrl">Link</a>\n\n' +
      "// ✅ Safe\n" +
      "get safeUrl() {\n" +
      "  return this.sanitizer.sanitize(SecurityContext.URL, this.userProvidedUrl);\n" +
      "}\n" +
      "```\n\n" +
      "**Security Checklist:**\n" +
      "1. Never use innerHTML with untrusted content\n" +
      "2. Always sanitize user input\n" +
      "3. Use HttpOnly cookies for tokens\n" +
      "4. Enable CSRF protection\n" +
      "5. Set CSP headers\n" +
      "6. Validate on server AND client\n" +
      "7. Use HTTPS only\n" +
      "8. Keep Angular updated",
    category: "Security",
    difficulty: "hard",
    tags: ["security", "xss", "csrf", "sanitization", "csp"],
  },
  {
    id: 42,
    question:
      "What are RxJS creation operators? Explain of, from, interval, fromEvent with examples.",
    answer:
      "Creation operators create observables from various sources.\n\n" +
      "**of - From Values:**\n\n" +
      "```typescript\n" +
      "import { of } from 'rxjs';\n\n" +
      "// Emit values immediately, then complete\n" +
      "of(1, 2, 3).subscribe(val => console.log(val));\n" +
      "// Output: 1, 2, 3\n\n" +
      "// Use case: Testing, default values\n" +
      "getUser(id: number): Observable<User> {\n" +
      "  if (id === 0) {\n" +
      "    return of({ id: 0, name: 'Guest' }); // Immediate value\n" +
      "  }\n" +
      "  return this.http.get<User>(`/api/users/${id}`);\n" +
      "}\n" +
      "```\n\n" +
      "**from - From Array/Promise:**\n\n" +
      "```typescript\n" +
      "import { from } from 'rxjs';\n\n" +
      "// From array\n" +
      "from([1, 2, 3]).subscribe(val => console.log(val));\n" +
      "// Output: 1, 2, 3 (one at a time)\n\n" +
      "// From Promise\n" +
      "from(fetch('/api/data').then(r => r.json()))\n" +
      "  .subscribe(data => console.log(data));\n\n" +
      "// From async iterator\n" +
      "async function* generate() {\n" +
      "  yield 1;\n" +
      "  yield 2;\n" +
      "}\n" +
      "from(generate()).subscribe(val => console.log(val));\n" +
      "```\n\n" +
      "**interval - Timer:**\n\n" +
      "```typescript\n" +
      "import { interval } from 'rxjs';\n" +
      "import { take } from 'rxjs/operators';\n\n" +
      "// Emit every 1000ms\n" +
      "interval(1000).pipe(\n" +
      "  take(5) // Only 5 emissions\n" +
      ").subscribe(val => console.log(val));\n" +
      "// Output: 0, 1, 2, 3, 4 (one per second)\n\n" +
      "// Use case: Polling\n" +
      "interval(5000).pipe(\n" +
      "  switchMap(() => this.http.get('/api/status'))\n" +
      ").subscribe(status => this.status = status);\n" +
      "```\n\n" +
      "**fromEvent - DOM Events:**\n\n" +
      "```typescript\n" +
      "import { fromEvent } from 'rxjs';\n" +
      "import { debounceTime, map } from 'rxjs/operators';\n\n" +
      "@Component({...})\n" +
      "export class Component implements OnInit, OnDestroy {\n" +
      "  private subscription: Subscription;\n\n" +
      "  ngOnInit() {\n" +
      "    // Window resize\n" +
      "    this.subscription = fromEvent(window, 'resize').pipe(\n" +
      "      debounceTime(300),\n" +
      "      map(() => window.innerWidth)\n" +
      "    ).subscribe(width => {\n" +
      "      console.log('Window width:', width);\n" +
      "    });\n\n" +
      "    // Scroll events\n" +
      "    fromEvent(window, 'scroll').pipe(\n" +
      "      debounceTime(100)\n" +
      "    ).subscribe(() => {\n" +
      "      this.onScroll();\n" +
      "    });\n" +
      "  }\n\n" +
      "  ngOnDestroy() {\n" +
      "    this.subscription.unsubscribe();\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "RxJS",
    difficulty: "intermediate",
    tags: ["rxjs", "creation-operators", "of", "from", "interval", "fromevent"],
  },
  {
    id: 43,
    question:
      "What are RxJS combination operators? Explain combineLatest, forkJoin, merge, concat with use cases.",
    answer:
      "Combination operators combine multiple observables into one.\n\n" +
      "**combineLatest - Latest from All:**\n\n" +
      "```typescript\n" +
      "import { combineLatest } from 'rxjs';\n\n" +
      "// Wait for all to emit at least once, then emit whenever ANY emits\n" +
      "const age$ = of(25);\n" +
      "const name$ = of('John');\n" +
      "const city$ = of('NYC');\n\n" +
      "combineLatest([age$, name$, city$]).subscribe(([age, name, city]) => {\n" +
      "  console.log(`${name}, ${age}, from ${city}`);\n" +
      "});\n\n" +
      "// Use case: Form with multiple dropdowns\n" +
      "combineLatest([\n" +
      "  this.countryControl.valueChanges,\n" +
      "  this.stateControl.valueChanges,\n" +
      "  this.cityControl.valueChanges\n" +
      "]).subscribe(([country, state, city]) => {\n" +
      "  this.updateAddress(country, state, city);\n" +
      "});\n" +
      "```\n\n" +
      "**forkJoin - Wait for All to Complete:**\n\n" +
      "```typescript\n" +
      "import { forkJoin } from 'rxjs';\n\n" +
      "// Like Promise.all - waits for all to complete\n" +
      "forkJoin({\n" +
      "  user: this.http.get('/api/user'),\n" +
      "  posts: this.http.get('/api/posts'),\n" +
      "  comments: this.http.get('/api/comments')\n" +
      "}).subscribe(({ user, posts, comments }) => {\n" +
      "  console.log('All loaded:', user, posts, comments);\n" +
      "});\n\n" +
      "// Use case: Load multiple resources before showing page\n" +
      "ngOnInit() {\n" +
      "  forkJoin([\n" +
      "    this.userService.getUser(id),\n" +
      "    this.postService.getPosts(id),\n" +
      "    this.settingsService.getSettings()\n" +
      "  ]).subscribe(([user, posts, settings]) => {\n" +
      "    this.user = user;\n" +
      "    this.posts = posts;\n" +
      "    this.settings = settings;\n" +
      "    this.loading = false;\n" +
      "  });\n" +
      "}\n" +
      "```\n\n" +
      "**merge - Merge Multiple Streams:**\n\n" +
      "```typescript\n" +
      "import { merge } from 'rxjs';\n\n" +
      "// Emit from any source as soon as it emits\n" +
      "const click$ = fromEvent(button, 'click');\n" +
      "const keypress$ = fromEvent(document, 'keypress');\n\n" +
      "merge(click$, keypress$).subscribe(() => {\n" +
      "  console.log('User interaction!');\n" +
      "});\n" +
      "```\n\n" +
      "**concat - Sequential:**\n\n" +
      "```typescript\n" +
      "import { concat } from 'rxjs';\n\n" +
      "// Subscribe to each in order, wait for complete\n" +
      "concat(\n" +
      "  this.http.post('/api/user', user),\n" +
      "  this.http.post('/api/profile', profile),\n" +
      "  this.http.post('/api/settings', settings)\n" +
      ").subscribe(result => console.log(result));\n" +
      "// Creates user, THEN profile, THEN settings\n" +
      "```",
    category: "RxJS",
    difficulty: "hard",
    tags: ["rxjs", "combinelatest", "forkjoin", "merge", "concat", "combination-operators"],
  },
  {
    id: 44,
    question:
      "What is the difference between providedIn: 'root' vs 'any' vs 'platform'? Explain service scoping.",
    answer:
      "**providedIn Strategies:**\n\n" +
      "**1. 'root' (Singleton):**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class UserService {}\n\n" +
      "// Single instance across entire app\n" +
      "// Tree-shakeable (removed if not used)\n" +
      "// Best for most services\n" +
      "```\n\n" +
      "**2. 'any' (Multiple Instances):**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'any' })\n" +
      "export class LoggerService {}\n\n" +
      "// New instance for each lazy-loaded module\n" +
      "// Each module gets its own instance\n" +
      "// Use for: isolated module state\n" +
      "```\n\n" +
      "**3. 'platform' (Cross-App Singleton):**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'platform' })\n" +
      "export class ConfigService {}\n\n" +
      "// Shared across multiple Angular apps\n" +
      "// Rare use case\n" +
      "```\n\n" +
      "**Component-Level Provider:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-user',\n" +
      "  providers: [UserService] // New instance per component\n" +
      "})\n" +
      "export class UserComponent {}\n\n" +
      "// Each component instance gets new service instance\n" +
      "// Use for: component-specific state\n" +
      "```\n\n" +
      "**When to Use:**\n" +
      "- root: Most services (auth, http, state)\n" +
      "- any: Module-specific services\n" +
      "- platform: Shared across apps (rare)\n" +
      "- Component: Isolated component state",
    category: "Dependency Injection",
    difficulty: "intermediate",
    tags: ["di", "providers", "scoping", "singleton", "services"],
  },
  {
    id: 45,
    question:
      "What are Advanced RxJS operators? Explain switchMap, mergeMap, concatMap, exhaustMap with real-world scenarios.",
    answer:
      "These higher-order operators flatten inner observables differently.\n\n" +
      "**switchMap - Cancel Previous:**\n\n" +
      "```typescript\n" +
      "// Use case: Search (cancel previous search on new input)\n" +
      "this.searchControl.valueChanges.pipe(\n" +
      "  debounceTime(300),\n" +
      "  switchMap(query => this.searchService.search(query))\n" +
      ").subscribe(results => this.results = results);\n\n" +
      '// User types: "ang" -> request1 starts\n' +
      '// User types: "angular" -> request1 CANCELLED, request2 starts\n' +
      "// Only latest request matters\n" +
      "```\n\n" +
      "**mergeMap - Run All Concurrently:**\n\n" +
      "```typescript\n" +
      "// Use case: Load details for multiple items\n" +
      "from([1, 2, 3]).pipe(\n" +
      "  mergeMap(id => this.http.get(`/api/user/${id}`))\n" +
      ").subscribe(user => console.log(user));\n\n" +
      "// All 3 requests run simultaneously\n" +
      "// Results come back in any order\n" +
      "// Good for: parallel operations\n" +
      "```\n\n" +
      "**concatMap - Sequential (Wait for Each):**\n\n" +
      "```typescript\n" +
      "// Use case: Sequential operations (order matters)\n" +
      "from([1, 2, 3]).pipe(\n" +
      "  concatMap(id => this.http.post(`/api/process/${id}`))\n" +
      ").subscribe(result => console.log(result));\n\n" +
      "// Request 1 completes, THEN request 2, THEN request 3\n" +
      "// Maintains order\n" +
      "// Good for: dependent operations, rate limiting\n" +
      "```\n\n" +
      "**exhaustMap - Ignore While Busy:**\n\n" +
      "```typescript\n" +
      "// Use case: Prevent double-submit\n" +
      "@Component({\n" +
      "  template: '<button (click)=\"save$.next()\">Save</button>'\n" +
      "})\n" +
      "export class Component {\n" +
      "  save$ = new Subject<void>();\n\n" +
      "  ngOnInit() {\n" +
      "    this.save$.pipe(\n" +
      "      exhaustMap(() => this.http.post('/api/save', this.data))\n" +
      "    ).subscribe(() => console.log('Saved!'));\n" +
      "  }\n" +
      "}\n\n" +
      "// User clicks 5 times rapidly\n" +
      "// Only first click triggers request\n" +
      "// Other clicks ignored until first completes\n" +
      "```\n\n" +
      "**Decision Matrix:**\n" +
      "- switchMap: Cancel previous (search, autocomplete)\n" +
      "- mergeMap: Run all (independent operations)\n" +
      "- concatMap: Sequential (order matters)\n" +
      "- exhaustMap: Ignore while busy (prevent double-submit)",
    category: "RxJS",
    difficulty: "hard",
    tags: ["rxjs", "switchmap", "mergemap", "concatmap", "exhaustmap", "higher-order"],
  },
  {
    id: 46,
    question: "What is Angular Module Federation? How do you implement micro-frontends in Angular?",
    answer:
      "Module Federation allows loading remote modules at runtime, enabling micro-frontends.\n\n" +
      "**Setup (webpack.config.js):**\n\n" +
      "```javascript\n" +
      "// Host App (Shell)\n" +
      "const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\n" +
      "module.exports = {\n" +
      "  plugins: [\n" +
      "    new ModuleFederationPlugin({\n" +
      "      name: 'host',\n" +
      "      remotes: {\n" +
      "        mfe1: 'mfe1@http://localhost:4201/remoteEntry.js',\n" +
      "        mfe2: 'mfe2@http://localhost:4202/remoteEntry.js'\n" +
      "      },\n" +
      "      shared: {\n" +
      "        '@angular/core': { singleton: true, strictVersion: true },\n" +
      "        '@angular/common': { singleton: true, strictVersion: true },\n" +
      "        '@angular/router': { singleton: true, strictVersion: true }\n" +
      "      }\n" +
      "    })\n" +
      "  ]\n" +
      "};\n\n" +
      "// Remote App (Micro-frontend)\n" +
      "module.exports = {\n" +
      "  plugins: [\n" +
      "    new ModuleFederationPlugin({\n" +
      "      name: 'mfe1',\n" +
      "      filename: 'remoteEntry.js',\n" +
      "      exposes: {\n" +
      "        './Module': './src/app/feature/feature.module.ts'\n" +
      "      },\n" +
      "      shared: {\n" +
      "        '@angular/core': { singleton: true },\n" +
      "        '@angular/common': { singleton: true }\n" +
      "      }\n" +
      "    })\n" +
      "  ]\n" +
      "};\n" +
      "```\n\n" +
      "**Loading Remote Module:**\n\n" +
      "```typescript\n" +
      "// Host routing\n" +
      "const routes: Routes = [\n" +
      "  {\n" +
      "    path: 'mfe1',\n" +
      "    loadChildren: () =>\n" +
      "      import('mfe1/Module').then(m => m.FeatureModule)\n" +
      "  }\n" +
      "];\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "- Independent deployment\n" +
      "- Team autonomy\n" +
      "- Technology diversity\n" +
      "- Faster builds\n\n" +
      "**Challenges:**\n" +
      "- Shared state management\n" +
      "- Version conflicts\n" +
      "- Routing coordination\n" +
      "- Testing complexity",
    category: "Architecture",
    difficulty: "hard",
    tags: ["module-federation", "micro-frontends", "webpack", "architecture"],
  },
  {
    id: 47,
    question:
      "How do you optimize Angular bundle size? Explain tree-shaking, lazy loading, and build optimizations.",
    answer:
      "**1. Lazy Loading:**\n\n" +
      "```typescript\n" +
      "// Instead of eager loading:\n" +
      "import { FeatureModule } from './feature/feature.module';\n\n" +
      "// Use lazy loading:\n" +
      "const routes: Routes = [\n" +
      "  {\n" +
      "    path: 'feature',\n" +
      "    loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule)\n" +
      "  }\n" +
      "];\n" +
      "// Reduces initial bundle size\n" +
      "```\n\n" +
      "**2. Tree-Shaking (Remove Unused Code):**\n\n" +
      "```typescript\n" +
      "// ❌ Bad - imports entire library\n" +
      "import * as _ from 'lodash';\n" +
      "_.debounce(fn, 300);\n\n" +
      "// ✅ Good - imports only needed function\n" +
      "import { debounce } from 'lodash-es';\n" +
      "debounce(fn, 300);\n\n" +
      "// Use standalone components (Angular 14+)\n" +
      "@Component({\n" +
      "  standalone: true,\n" +
      "  imports: [CommonModule] // Only what's needed\n" +
      "})\n" +
      "```\n\n" +
      "**3. Production Build Optimizations:**\n\n" +
      "```bash\n" +
      "ng build --configuration production\n" +
      "\n" +
      "# Enables:\n" +
      "# - AOT compilation\n" +
      "# - Minification\n" +
      "# - Tree-shaking\n" +
      "# - Dead code elimination\n" +
      "# - Bundle compression\n" +
      "```\n\n" +
      "**4. Analyze Bundle:**\n\n" +
      "```bash\n" +
      "npm install -D webpack-bundle-analyzer\n" +
      "ng build --stats-json\n" +
      "npx webpack-bundle-analyzer dist/stats.json\n" +
      "```\n\n" +
      "**5. Optimize Dependencies:**\n\n" +
      "```typescript\n" +
      "// Use CDN for large libs\n" +
      "// Replace moment.js (large) with date-fns (small)\n" +
      "import { format } from 'date-fns'; // 2KB vs 70KB\n\n" +
      "// Remove unused Angular modules\n" +
      "// Use providedIn: 'root' for tree-shakeable services\n" +
      "```\n\n" +
      "**6. Budget Configuration:**\n\n" +
      "```json\n" +
      "// angular.json\n" +
      '"budgets": [\n' +
      "  {\n" +
      '    "type": "initial",\n' +
      '    "maximumWarning": "500kb",\n' +
      '    "maximumError": "1mb"\n' +
      "  }\n" +
      "]\n" +
      "```",
    category: "Performance",
    difficulty: "hard",
    tags: ["bundle-size", "tree-shaking", "lazy-loading", "optimization", "performance"],
  },
  {
    id: 48,
    question: "What are Custom Validators in Angular? How do you create async validators?",
    answer:
      "Custom validators enforce business-specific validation rules.\n\n" +
      "**Sync Custom Validator:**\n\n" +
      "```typescript\n" +
      "import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\n\n" +
      "// Function validator\n" +
      "export function passwordStrengthValidator(): ValidatorFn {\n" +
      "  return (control: AbstractControl): ValidationErrors | null => {\n" +
      "    const value = control.value;\n" +
      "    if (!value) return null;\n\n" +
      "    const hasNumber = /[0-9]/.test(value);\n" +
      "    const hasUpper = /[A-Z]/.test(value);\n" +
      "    const hasLower = /[a-z]/.test(value);\n" +
      "    const hasSpecial = /[!@#$%^&*]/.test(value);\n\n" +
      "    const valid = hasNumber && hasUpper && hasLower && hasSpecial;\n\n" +
      "    return valid ? null : {\n" +
      "      passwordStrength: {\n" +
      "        hasNumber,\n" +
      "        hasUpper,\n" +
      "        hasLower,\n" +
      "        hasSpecial\n" +
      "      }\n" +
      "    };\n" +
      "  };\n" +
      "}\n\n" +
      "// Usage\n" +
      "this.form = this.fb.group({\n" +
      "  password: ['', [Validators.required, passwordStrengthValidator()]]\n" +
      "});\n" +
      "```\n\n" +
      "**Cross-Field Validator:**\n\n" +
      "```typescript\n" +
      "export function passwordMatchValidator(): ValidatorFn {\n" +
      "  return (formGroup: AbstractControl): ValidationErrors | null => {\n" +
      "    const password = formGroup.get('password')?.value;\n" +
      "    const confirmPassword = formGroup.get('confirmPassword')?.value;\n\n" +
      "    return password === confirmPassword ? null : { passwordMismatch: true };\n" +
      "  };\n" +
      "}\n\n" +
      "// Usage\n" +
      "this.form = this.fb.group({\n" +
      "  password: ['', Validators.required],\n" +
      "  confirmPassword: ['', Validators.required]\n" +
      "}, { validators: passwordMatchValidator() });\n" +
      "```\n\n" +
      "**Async Validator (Backend Check):**\n\n" +
      "```typescript\n" +
      "import { AsyncValidatorFn } from '@angular/forms';\n" +
      "import { map, catchError } from 'rxjs/operators';\n" +
      "import { of } from 'rxjs';\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class UsernameValidator {\n" +
      "  constructor(private http: HttpClient) {}\n\n" +
      "  usernameExists(): AsyncValidatorFn {\n" +
      "    return (control: AbstractControl): Observable<ValidationErrors | null> => {\n" +
      "      if (!control.value) {\n" +
      "        return of(null);\n" +
      "      }\n\n" +
      "      return this.http.get(`/api/check-username/${control.value}`).pipe(\n" +
      "        map((exists: boolean) => exists ? { usernameTaken: true } : null),\n" +
      "        catchError(() => of(null))\n" +
      "      );\n" +
      "    };\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage\n" +
      "constructor(private usernameValidator: UsernameValidator) {}\n\n" +
      "this.form = this.fb.group({\n" +
      "  username: ['',\n" +
      "    [Validators.required],\n" +
      "    [this.usernameValidator.usernameExists()] // Async validator\n" +
      "  ]\n" +
      "});\n\n" +
      "// Check status\n" +
      "if (control.pending) console.log('Validating...');\n" +
      "if (control.hasError('usernameTaken')) console.log('Username taken');\n" +
      "```",
    category: "Forms",
    difficulty: "hard",
    tags: ["validators", "custom-validators", "async-validators", "forms"],
  },
  {
    id: 49,
    question:
      "What are Angular Animations? Implement complex animation sequences with state transitions.",
    answer:
      "Angular animations use the Web Animations API for declarative animations.\n\n" +
      "**Basic Animation:**\n\n" +
      "```typescript\n" +
      "import { trigger, state, style, transition, animate } from '@angular/animations';\n\n" +
      "@Component({\n" +
      "  animations: [\n" +
      "    trigger('openClose', [\n" +
      "      state('open', style({\n" +
      "        height: '200px',\n" +
      "        opacity: 1,\n" +
      "        backgroundColor: 'yellow'\n" +
      "      })),\n" +
      "      state('closed', style({\n" +
      "        height: '50px',\n" +
      "        opacity: 0.5,\n" +
      "        backgroundColor: 'green'\n" +
      "      })),\n" +
      "      transition('open => closed', [\n" +
      "        animate('0.3s')\n" +
      "      ]),\n" +
      "      transition('closed => open', [\n" +
      "        animate('0.5s')\n" +
      "      ])\n" +
      "    ])\n" +
      "  ],\n" +
      "  template: `\n" +
      "    <div [@openClose]=\"isOpen ? 'open' : 'closed'\">Content</div>\n" +
      '    <button (click)="toggle()">Toggle</button>\n' +
      "  `\n" +
      "})\n" +
      "export class Component {\n" +
      "  isOpen = true;\n" +
      "  toggle() { this.isOpen = !this.isOpen; }\n" +
      "}\n" +
      "```\n\n" +
      "**Enter/Leave Animations:**\n\n" +
      "```typescript\n" +
      "trigger('fadeIn', [\n" +
      "  transition(':enter', [\n" +
      "    style({ opacity: 0 }),\n" +
      "    animate('300ms', style({ opacity: 1 }))\n" +
      "  ]),\n" +
      "  transition(':leave', [\n" +
      "    animate('300ms', style({ opacity: 0 }))\n" +
      "  ])\n" +
      "])\n\n" +
      "// Template\n" +
      '<div *ngIf="show" @fadeIn>Fading in/out</div>\n' +
      "```\n\n" +
      "**List Animations:**\n\n" +
      "```typescript\n" +
      "import { query, stagger } from '@angular/animations';\n\n" +
      "trigger('listAnimation', [\n" +
      "  transition('* => *', [\n" +
      "    query(':enter', [\n" +
      "      style({ opacity: 0, transform: 'translateY(-20px)' }),\n" +
      "      stagger(100, [\n" +
      "        animate('300ms', style({ opacity: 1, transform: 'translateY(0)' }))\n" +
      "      ])\n" +
      "    ], { optional: true })\n" +
      "  ])\n" +
      "])\n\n" +
      "// Template\n" +
      '<div [@listAnimation]="items.length">\n' +
      '  <div *ngFor="let item of items">{{ item }}</div>\n' +
      "</div>\n" +
      "```\n\n" +
      "**Route Animations:**\n\n" +
      "```typescript\n" +
      "// app.component.ts\n" +
      "prepareRoute(outlet: RouterOutlet) {\n" +
      "  return outlet?.activatedRouteData?.['animation'];\n" +
      "}\n\n" +
      "// Template\n" +
      '<div [@routeAnimations]="prepareRoute(outlet)">\n' +
      '  <router-outlet #outlet="outlet"></router-outlet>\n' +
      "</div>\n" +
      "```",
    category: "Animations",
    difficulty: "hard",
    tags: ["animations", "transitions", "web-animations-api", "ui"],
  },
  {
    id: 50,
    question: "What is Lazy Loading Strategy in Angular? Implement custom preloading strategies.",
    answer:
      "Lazy loading loads modules on-demand. Preloading strategies control when to load them.\n\n" +
      "**Built-in Strategies:**\n\n" +
      "```typescript\n" +
      "import { PreloadAllModules, NoPreloading } from '@angular/router';\n\n" +
      "// Option 1: No preloading (default)\n" +
      "RouterModule.forRoot(routes, {\n" +
      "  preloadingStrategy: NoPreloading\n" +
      "});\n\n" +
      "// Option 2: Preload all lazy modules\n" +
      "RouterModule.forRoot(routes, {\n" +
      "  preloadingStrategy: PreloadAllModules\n" +
      "});\n" +
      "```\n\n" +
      "**Custom Preloading Strategy:**\n\n" +
      "```typescript\n" +
      "import { PreloadingStrategy, Route } from '@angular/router';\n" +
      "import { Observable, of, timer } from 'rxjs';\n" +
      "import { mergeMap } from 'rxjs/operators';\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class SelectivePreloadingStrategy implements PreloadingStrategy {\n" +
      "  preload(route: Route, load: () => Observable<unknown>): Observable<unknown> {\n" +
      "    // Preload if route data has preload: true\n" +
      "    if (route.data && route.data['preload']) {\n" +
      "      console.log('Preloading:', route.path);\n" +
      "      return load();\n" +
      "    }\n" +
      "    return of(null);\n" +
      "  }\n" +
      "}\n\n" +
      "// Routes configuration\n" +
      "const routes: Routes = [\n" +
      "  {\n" +
      "    path: 'admin',\n" +
      "    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),\n" +
      "    data: { preload: false } // Don't preload\n" +
      "  },\n" +
      "  {\n" +
      "    path: 'dashboard',\n" +
      "    loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule),\n" +
      "    data: { preload: true } // Preload this\n" +
      "  }\n" +
      "];\n\n" +
      "// App module\n" +
      "RouterModule.forRoot(routes, {\n" +
      "  preloadingStrategy: SelectivePreloadingStrategy\n" +
      "});\n" +
      "```\n\n" +
      "**Network-Aware Preloading:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class NetworkAwarePreloadingStrategy implements PreloadingStrategy {\n" +
      "  preload(route: Route, load: () => Observable<unknown>): Observable<unknown> {\n" +
      "    const connection = (navigator as any).connection;\n" +
      "    \n" +
      "    // Only preload on fast connections\n" +
      "    if (connection && connection.effectiveType === '4g') {\n" +
      "      return load();\n" +
      "    }\n" +
      "    \n" +
      "    return of(null);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Delayed Preloading:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class DelayedPreloadingStrategy implements PreloadingStrategy {\n" +
      "  preload(route: Route, load: () => Observable<unknown>): Observable<unknown> {\n" +
      "    const delay = route.data?.['preloadDelay'] || 5000;\n" +
      "    \n" +
      "    return timer(delay).pipe(\n" +
      "      mergeMap(() => load())\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Routing",
    difficulty: "hard",
    tags: ["lazy-loading", "preloading", "routing", "performance"],
  },
  {
    id: 51,
    question:
      "How do you implement state management without NgRx? Explain service-based state pattern.",
    answer:
      "Service-based state management uses RxJS BehaviorSubject for simple state needs.\n\n" +
      "**State Service Pattern:**\n\n" +
      "```typescript\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { BehaviorSubject, Observable } from 'rxjs';\n" +
      "import { map } from 'rxjs/operators';\n\n" +
      "export interface AppState {\n" +
      "  user: User | null;\n" +
      "  cart: CartItem[];\n" +
      "  loading: boolean;\n" +
      "}\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class StateService {\n" +
      "  private state = new BehaviorSubject<AppState>({\n" +
      "    user: null,\n" +
      "    cart: [],\n" +
      "    loading: false\n" +
      "  });\n\n" +
      "  // Public observable (read-only)\n" +
      "  state$ = this.state.asObservable();\n\n" +
      "  // Selectors\n" +
      "  user$ = this.state$.pipe(map(state => state.user));\n" +
      "  cart$ = this.state$.pipe(map(state => state.cart));\n" +
      "  cartItemCount$ = this.cart$.pipe(\n" +
      "    map(cart => cart.reduce((sum, item) => sum + item.quantity, 0))\n" +
      "  );\n\n" +
      "  // Actions (update state)\n" +
      "  setUser(user: User) {\n" +
      "    this.state.next({\n" +
      "      ...this.state.value,\n" +
      "      user\n" +
      "    });\n" +
      "  }\n\n" +
      "  addToCart(item: CartItem) {\n" +
      "    const currentCart = this.state.value.cart;\n" +
      "    const existingItem = currentCart.find(i => i.id === item.id);\n\n" +
      "    if (existingItem) {\n" +
      "      existingItem.quantity += item.quantity;\n" +
      "      this.state.next({\n" +
      "        ...this.state.value,\n" +
      "        cart: [...currentCart]\n" +
      "      });\n" +
      "    } else {\n" +
      "      this.state.next({\n" +
      "        ...this.state.value,\n" +
      "        cart: [...currentCart, item]\n" +
      "      });\n" +
      "    }\n" +
      "  }\n\n" +
      "  clearCart() {\n" +
      "    this.state.next({\n" +
      "      ...this.state.value,\n" +
      "      cart: []\n" +
      "    });\n" +
      "  }\n\n" +
      "  // Get current snapshot\n" +
      "  getState(): AppState {\n" +
      "    return this.state.value;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Usage in Component:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  user$ = this.stateService.user$;\n" +
      "  cartCount$ = this.stateService.cartItemCount$;\n\n" +
      "  constructor(private stateService: StateService) {}\n\n" +
      "  addItem(item: CartItem) {\n" +
      "    this.stateService.addToCart(item);\n" +
      "  }\n" +
      "}\n\n" +
      "// Template\n" +
      '<div *ngIf="user$ | async as user">\n' +
      "  Welcome, {{ user.name }}\n" +
      "</div>\n" +
      "<span>Cart: {{ cartCount$ | async }}</span>\n" +
      "```",
    category: "State Management",
    difficulty: "intermediate",
    tags: ["state-management", "rxjs", "behaviorsubject", "patterns"],
  },
  {
    id: 52,
    question:
      "What is Content Projection in Angular? Explain ng-content, ng-template, and ng-container.",
    answer:
      "Content projection (transclusion) allows passing content into components.\n\n" +
      "**Basic ng-content:**\n\n" +
      "```typescript\n" +
      "// card.component.ts\n" +
      "@Component({\n" +
      "  selector: 'app-card',\n" +
      "  template: `\n" +
      '    <div class="card">\n' +
      '      <div class="card-header">\n' +
      '        <ng-content select="[header]"></ng-content>\n' +
      "      </div>\n" +
      '      <div class="card-body">\n' +
      "        <ng-content></ng-content> <!-- Default slot -->\n" +
      "      </div>\n" +
      '      <div class="card-footer">\n' +
      '        <ng-content select="[footer]"></ng-content>\n' +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n\n" +
      "// Usage\n" +
      "<app-card>\n" +
      "  <h2 header>Card Title</h2>\n" +
      "  <p>Card body content goes here.</p>\n" +
      "  <button footer>Action</button>\n" +
      "</app-card>\n" +
      "```\n\n" +
      "**ng-template (Template Reference):**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-tabs',\n" +
      "  template: `\n" +
      '    <div class="tabs">\n' +
      '      <button *ngFor="let tab of tabs" (click)="selectTab(tab)">\n' +
      "        {{ tab.title }}\n" +
      "      </button>\n" +
      "    </div>\n" +
      '    <div class="tab-content">\n' +
      '      <ng-container *ngTemplateOutlet="selectedTab?.content"></ng-container>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class TabsComponent {\n" +
      "  @ContentChildren(TabComponent) tabs: QueryList<TabComponent>;\n" +
      "  selectedTab: TabComponent;\n" +
      "}\n\n" +
      "// Usage\n" +
      "<app-tabs>\n" +
      '  <app-tab title="Tab 1">\n' +
      "    <ng-template>\n" +
      "      Content for tab 1\n" +
      "    </ng-template>\n" +
      "  </app-tab>\n" +
      '  <app-tab title="Tab 2">\n' +
      "    <ng-template>\n" +
      "      Content for tab 2\n" +
      "    </ng-template>\n" +
      "  </app-tab>\n" +
      "</app-tabs>\n" +
      "```\n\n" +
      "**ng-container (No DOM Element):**\n\n" +
      "```typescript\n" +
      "// Grouping without adding DOM element\n" +
      '<ng-container *ngIf="user">\n' +
      "  <h1>{{ user.name }}</h1>\n" +
      "  <p>{{ user.email }}</p>\n" +
      "</ng-container>\n" +
      "// No wrapper div created!\n\n" +
      "// Multiple structural directives\n" +
      '<ng-container *ngIf="show">\n' +
      '  <div *ngFor="let item of items">{{ item }}</div>\n' +
      "</ng-container>\n" +
      "```",
    category: "Templates",
    difficulty: "intermediate",
    tags: ["ng-content", "projection", "templates", "ng-template"],
  },
  {
    id: 53,
    question:
      "What is Zone.js and how does Angular use it? Explain NgZone and running outside Angular zone.",
    answer:
      "Zone.js monkey-patches async operations to trigger change detection.\n\n" +
      "**How Zone.js Works:**\n\n" +
      "```typescript\n" +
      "// Zone.js patches:\n" +
      "// - setTimeout/setInterval\n" +
      "// - Promise.then\n" +
      "// - addEventListener\n" +
      "// - XMLHttpRequest\n\n" +
      "// When any runs, Angular knows to run change detection\n" +
      "setTimeout(() => {\n" +
      "  this.data = 'updated'; // Change detection runs automatically\n" +
      "}, 1000);\n" +
      "```\n\n" +
      "**NgZone API:**\n\n" +
      "```typescript\n" +
      "import { NgZone } from '@angular/core';\n\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  constructor(private ngZone: NgZone) {}\n\n" +
      "  // Run outside Angular zone (skip change detection)\n" +
      "  setupHeavyAnimation() {\n" +
      "    this.ngZone.runOutsideAngular(() => {\n" +
      "      // This code won't trigger change detection\n" +
      "      setInterval(() => {\n" +
      "        // Update canvas, heavy calculations, etc.\n" +
      "        this.updateCanvas();\n" +
      "      }, 16); // 60fps\n" +
      "    });\n" +
      "  }\n\n" +
      "  // Re-enter Angular zone when needed\n" +
      "  updateData() {\n" +
      "    this.ngZone.run(() => {\n" +
      "      this.data = 'updated'; // Change detection runs\n" +
      "    });\n" +
      "  }\n\n" +
      "  // Check if inside Angular zone\n" +
      "  checkZone() {\n" +
      "    console.log(NgZone.isInAngularZone()); // true or false\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Use Cases for runOutsideAngular:**\n\n" +
      "```typescript\n" +
      "// 1. High-frequency events (scroll, mousemove)\n" +
      "ngOnInit() {\n" +
      "  this.ngZone.runOutsideAngular(() => {\n" +
      "    fromEvent(window, 'scroll').pipe(\n" +
      "      throttleTime(100)\n" +
      "    ).subscribe(() => {\n" +
      "      // Update non-Angular stuff\n" +
      "      this.updateScrollPosition();\n" +
      "    });\n" +
      "  });\n" +
      "}\n\n" +
      "// 2. Third-party libraries\n" +
      "initChart() {\n" +
      "  this.ngZone.runOutsideAngular(() => {\n" +
      "    this.chart = new Chart(this.canvas, config);\n" +
      "  });\n" +
      "}\n" +
      "```\n\n" +
      "**Zoneless Angular (Future):**\n\n" +
      "```typescript\n" +
      "// Angular 16+ experimental\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideExperimentalZonelessChangeDetection()\n" +
      "  ]\n" +
      "});\n" +
      "// Uses Signals instead of Zone.js\n" +
      "```",
    category: "Change Detection",
    difficulty: "hard",
    tags: ["zone.js", "ngzone", "change-detection", "performance"],
  },
  {
    id: 54,
    question: "What are Angular Elements? How do you create and use Web Components from Angular?",
    answer:
      "Angular Elements packages Angular components as custom Web Components.\n\n" +
      "**Setup:**\n\n" +
      "```bash\n" +
      "ng add @angular/elements\n" +
      "```\n\n" +
      "**Create Angular Element:**\n\n" +
      "```typescript\n" +
      "import { createCustomElement } from '@angular/elements';\n" +
      "import { Injector } from '@angular/core';\n\n" +
      "// Widget component\n" +
      "@Component({\n" +
      "  selector: 'app-widget',\n" +
      "  template: `\n" +
      '    <div class="widget">\n' +
      "      <h3>{{ title }}</h3>\n" +
      "      <p>{{ content }}</p>\n" +
      '      <button (click)="handleClick()">{{ buttonText }}</button>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class WidgetComponent {\n" +
      "  @Input() title = '';\n" +
      "  @Input() content = '';\n" +
      "  @Input() buttonText = 'Click';\n" +
      "  @Output() clicked = new EventEmitter();\n\n" +
      "  handleClick() {\n" +
      "    this.clicked.emit({ timestamp: Date.now() });\n" +
      "  }\n" +
      "}\n\n" +
      "// Register as custom element\n" +
      "@NgModule({\n" +
      "  declarations: [WidgetComponent],\n" +
      "  imports: [BrowserModule],\n" +
      "  entryComponents: [WidgetComponent] // Important!\n" +
      "})\n" +
      "export class AppModule {\n" +
      "  constructor(private injector: Injector) {\n" +
      "    const widgetElement = createCustomElement(WidgetComponent, { injector });\n" +
      "    customElements.define('my-widget', widgetElement);\n" +
      "  }\n\n" +
      "  ngDoBootstrap() {} // Skip normal bootstrap\n" +
      "}\n" +
      "```\n\n" +
      "**Use in Any HTML:**\n\n" +
      "```html\n" +
      "<!-- Can use in vanilla HTML, React, Vue, etc. -->\n" +
      "<!DOCTYPE html>\n" +
      "<html>\n" +
      "<head>\n" +
      '  <script src="widget.js"></script>\n' +
      "</head>\n" +
      "<body>\n" +
      "  <my-widget\n" +
      '    title="Hello"\n' +
      '    content="This is an Angular Element!"\n' +
      '    button-text="Click Me"\n' +
      "  ></my-widget>\n\n" +
      "  <script>\n" +
      "    const widget = document.querySelector('my-widget');\n" +
      "    widget.addEventListener('clicked', (e) => {\n" +
      "      console.log('Clicked at:', e.detail.timestamp);\n" +
      "    });\n" +
      "  </script>\n" +
      "</body>\n" +
      "</html>\n" +
      "```\n\n" +
      "**Build for Production:**\n\n" +
      "```bash\n" +
      "ng build --configuration production --output-hashing=none\n" +
      "\n" +
      "# Concatenate files\n" +
      "cat dist/widget/{runtime,polyfills,main}.js > widget.js\n" +
      "```\n\n" +
      "**Use Cases:**\n" +
      "- Micro-frontends\n" +
      "- Widget libraries\n" +
      "- CMS integrations\n" +
      "- Framework-agnostic components",
    category: "Web Components",
    difficulty: "hard",
    tags: ["angular-elements", "web-components", "custom-elements", "micro-frontends"],
  },
  {
    id: 55,
    question:
      "What are RxJS error handling operators? Explain catchError, retry, retryWhen with practical examples.",
    answer:
      "Error handling operators gracefully manage errors in observable streams.\n\n" +
      "**catchError - Handle and Recover:**\n\n" +
      "```typescript\n" +
      "import { catchError } from 'rxjs/operators';\n" +
      "import { of, throwError } from 'rxjs';\n\n" +
      "// Return fallback value\n" +
      "this.http.get('/api/data').pipe(\n" +
      "  catchError(error => {\n" +
      "    console.error('Error:', error);\n" +
      "    return of({ data: 'fallback' }); // Continue with fallback\n" +
      "  })\n" +
      ").subscribe(data => console.log(data));\n\n" +
      "// Re-throw error\n" +
      "this.http.get('/api/data').pipe(\n" +
      "  catchError(error => {\n" +
      "    this.logError(error);\n" +
      "    return throwError(() => new Error('Custom error'));\n" +
      "  })\n" +
      ").subscribe({\n" +
      "  next: data => console.log(data),\n" +
      "  error: err => console.error('Handled:', err)\n" +
      "});\n" +
      "```\n\n" +
      "**retry - Retry on Error:**\n\n" +
      "```typescript\n" +
      "import { retry, delay } from 'rxjs/operators';\n\n" +
      "// Simple retry (3 times)\n" +
      "this.http.get('/api/data').pipe(\n" +
      "  retry(3), // Retry up to 3 times\n" +
      "  catchError(error => {\n" +
      "    console.error('Failed after 3 retries');\n" +
      "    return of(null);\n" +
      "  })\n" +
      ").subscribe(data => console.log(data));\n\n" +
      "// With delay\n" +
      "this.http.get('/api/data').pipe(\n" +
      "  retry({ count: 3, delay: 1000 }), // Wait 1s between retries\n" +
      "  catchError(error => of(null))\n" +
      ").subscribe();\n" +
      "```\n\n" +
      "**retryWhen - Conditional Retry:**\n\n" +
      "```typescript\n" +
      "import { retryWhen, scan, delay, tap } from 'rxjs/operators';\n\n" +
      "// Exponential backoff\n" +
      "this.http.get('/api/data').pipe(\n" +
      "  retryWhen(errors => errors.pipe(\n" +
      "    scan((acc, error) => {\n" +
      "      if (acc >= 5) {\n" +
      "        throw error; // Stop after 5 attempts\n" +
      "      }\n" +
      "      return acc + 1;\n" +
      "    }, 0),\n" +
      "    tap(retryCount => console.log(`Retry attempt ${retryCount}`)),\n" +
      "    delay(retryCount => retryCount * 1000) // 1s, 2s, 3s, 4s, 5s\n" +
      "  ))\n" +
      ").subscribe();\n\n" +
      "// Retry only specific errors\n" +
      "this.http.get('/api/data').pipe(\n" +
      "  retryWhen(errors => errors.pipe(\n" +
      "    tap(error => {\n" +
      "      if (error.status === 500) {\n" +
      "        console.log('Server error, retrying...');\n" +
      "      } else {\n" +
      "        throw error; // Don't retry client errors\n" +
      "      }\n" +
      "    }),\n" +
      "    delay(1000)\n" +
      "  ))\n" +
      ").subscribe();\n" +
      "```",
    category: "RxJS",
    difficulty: "hard",
    tags: ["rxjs", "error-handling", "catcherror", "retry", "retrywhen"],
  },
  {
    id: 56,
    question:
      "How do you implement Memory Leak Prevention in Angular? Explain subscription management strategies.",
    answer:
      "Memory leaks occur when subscriptions aren't properly cleaned up.\n\n" +
      "**Problem:**\n\n" +
      "```typescript\n" +
      "// ❌ BAD - Memory leak!\n" +
      "@Component({...})\n" +
      "export class BadComponent implements OnInit {\n" +
      "  ngOnInit() {\n" +
      "    this.dataService.getData().subscribe(data => {\n" +
      "      this.data = data;\n" +
      "    });\n" +
      "    // Subscription never cleaned up!\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Solution 1: Manual Unsubscribe:**\n\n" +
      "```typescript\n" +
      "import { Subscription } from 'rxjs';\n\n" +
      "@Component({...})\n" +
      "export class Component implements OnInit, OnDestroy {\n" +
      "  private subscription = new Subscription();\n\n" +
      "  ngOnInit() {\n" +
      "    this.subscription.add(\n" +
      "      this.dataService.getData().subscribe(data => this.data = data)\n" +
      "    );\n\n" +
      "    this.subscription.add(\n" +
      "      this.userService.getUser().subscribe(user => this.user = user)\n" +
      "    );\n" +
      "  }\n\n" +
      "  ngOnDestroy() {\n" +
      "    this.subscription.unsubscribe(); // Cleans up all\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Solution 2: takeUntil Pattern:**\n\n" +
      "```typescript\n" +
      "import { Subject } from 'rxjs';\n" +
      "import { takeUntil } from 'rxjs/operators';\n\n" +
      "@Component({...})\n" +
      "export class Component implements OnInit, OnDestroy {\n" +
      "  private destroy$ = new Subject<void>();\n\n" +
      "  ngOnInit() {\n" +
      "    this.dataService.getData().pipe(\n" +
      "      takeUntil(this.destroy$)\n" +
      "    ).subscribe(data => this.data = data);\n\n" +
      "    this.userService.getUser().pipe(\n" +
      "      takeUntil(this.destroy$)\n" +
      "    ).subscribe(user => this.user = user);\n" +
      "  }\n\n" +
      "  ngOnDestroy() {\n" +
      "    this.destroy$.next();\n" +
      "    this.destroy$.complete();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Solution 3: Async Pipe (Best):**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  template: `\n" +
      '    <div *ngIf="data$ | async as data">{{ data.name }}</div>\n' +
      '    <div *ngIf="user$ | async as user">{{ user.name }}</div>\n' +
      "  `\n" +
      "})\n" +
      "export class Component {\n" +
      "  data$ = this.dataService.getData();\n" +
      "  user$ = this.userService.getUser();\n" +
      "  // async pipe auto-unsubscribes!\n" +
      "}\n" +
      "```\n\n" +
      "**Solution 4: take(1) for Single Emission:**\n\n" +
      "```typescript\n" +
      "import { take } from 'rxjs/operators';\n\n" +
      "ngOnInit() {\n" +
      "  this.http.get('/api/data').pipe(\n" +
      "    take(1) // Auto-completes after 1 emission\n" +
      "  ).subscribe(data => this.data = data);\n" +
      "}\n" +
      "```",
    category: "Performance",
    difficulty: "hard",
    tags: ["memory-leaks", "subscriptions", "rxjs", "cleanup", "best-practices"],
  },
  {
    id: 57,
    question:
      "What is AOT (Ahead-of-Time) vs JIT (Just-in-Time) compilation? What are the trade-offs?",
    answer:
      "**JIT (Just-in-Time) Compilation:**\n\n" +
      "```typescript\n" +
      "// Development mode (ng serve)\n" +
      "// - Compiles in browser at runtime\n" +
      "// - Slower startup\n" +
      "// - Larger bundle (includes compiler)\n" +
      "// - Better error messages\n" +
      "// - Faster build time\n" +
      "```\n\n" +
      "**AOT (Ahead-of-Time) Compilation:**\n\n" +
      "```typescript\n" +
      "// Production mode (ng build --prod)\n" +
      "// - Pre-compiled during build\n" +
      "// - Faster startup (no compilation in browser)\n" +
      "// - Smaller bundle (no compiler needed)\n" +
      "// - Template errors caught at build time\n" +
      "// - Better security (no eval)\n" +
      "```\n\n" +
      "**Build Commands:**\n\n" +
      "```bash\n" +
      "# JIT (development)\n" +
      "ng serve\n" +
      "ng build\n\n" +
      "# AOT (production)\n" +
      "ng build --configuration production  # AOT by default\n" +
      "```\n\n" +
      "**Benefits of AOT:**\n\n" +
      "```typescript\n" +
      "1. **Faster rendering**: Pre-compiled, no browser compilation\n" +
      "2. **Smaller bundles**: ~40% smaller (no compiler)\n" +
      "3. **Early error detection**: Template errors at build time\n" +
      "4. **Better security**: No eval() or new Function()\n" +
      "5. **Better tree-shaking**: Unused code removed\n" +
      "```\n\n" +
      "**Trade-offs:**\n\n" +
      "```typescript\n" +
      "// JIT\n" +
      "+ Faster development builds\n" +
      "+ Better error messages\n" +
      "- Slower app startup\n" +
      "- Larger bundles\n" +
      "- Runtime errors in templates\n\n" +
      "// AOT\n" +
      "+ Production-ready\n" +
      "+ Faster runtime\n" +
      "+ Smaller bundles\n" +
      "- Slower builds\n" +
      "- Less detailed errors\n" +
      "```",
    category: "Build & Compilation",
    difficulty: "intermediate",
    tags: ["aot", "jit", "compilation", "build", "performance"],
  },
  {
    id: 58,
    question:
      "How do you implement Progressive Web App (PWA) features in Angular? Explain Service Workers.",
    answer:
      "**Setup Angular PWA:**\n\n" +
      "```bash\n" +
      "ng add @angular/pwa\n" +
      "```\n\n" +
      "**Generates:**\n" +
      "- `ngsw-config.json` - Service worker configuration\n" +
      "- `manifest.webmanifest` - App manifest\n" +
      "- Icons in various sizes\n\n" +
      "**Service Worker Configuration:**\n\n" +
      "```json\n" +
      "// ngsw-config.json\n" +
      "{\n" +
      '  "index": "/index.html",\n' +
      '  "assetGroups": [\n' +
      "    {\n" +
      '      "name": "app",\n' +
      '      "installMode": "prefetch",\n' +
      '      "resources": {\n' +
      '        "files": ["/favicon.ico", "/index.html", "/*.css", "/*.js"]\n' +
      "      }\n" +
      "    },\n" +
      "    {\n" +
      '      "name": "assets",\n' +
      '      "installMode": "lazy",\n' +
      '      "updateMode": "prefetch",\n' +
      '      "resources": {\n' +
      '        "files": ["/assets/**"]\n' +
      "      }\n" +
      "    }\n" +
      "  ],\n" +
      '  "dataGroups": [\n' +
      "    {\n" +
      '      "name": "api",\n' +
      '      "urls": ["/api/**"],\n' +
      '      "cacheConfig": {\n' +
      '        "maxSize": 100,\n' +
      '        "maxAge": "1h",\n' +
      '        "strategy": "freshness" // or "performance"\n' +
      "      }\n" +
      "    }\n" +
      "  ]\n" +
      "}\n" +
      "```\n\n" +
      "**Service Worker API:**\n\n" +
      "```typescript\n" +
      "import { SwUpdate, SwPush } from '@angular/service-worker';\n\n" +
      "@Component({...})\n" +
      "export class AppComponent implements OnInit {\n" +
      "  constructor(\n" +
      "    private swUpdate: SwUpdate,\n" +
      "    private swPush: SwPush\n" +
      "  ) {}\n\n" +
      "  ngOnInit() {\n" +
      "    // Check for updates\n" +
      "    if (this.swUpdate.isEnabled) {\n" +
      "      this.swUpdate.versionUpdates.subscribe(event => {\n" +
      "        if (event.type === 'VERSION_READY') {\n" +
      "          if (confirm('New version available. Load?')) {\n" +
      "            window.location.reload();\n" +
      "          }\n" +
      "        }\n" +
      "      });\n\n" +
      "      // Check every 6 hours\n" +
      "      interval(6 * 60 * 60 * 1000).subscribe(() => {\n" +
      "        this.swUpdate.checkForUpdate();\n" +
      "      });\n" +
      "    }\n\n" +
      "    // Push notifications\n" +
      "    if (this.swPush.isEnabled) {\n" +
      "      this.swPush.requestSubscription({\n" +
      "        serverPublicKey: 'YOUR_VAPID_PUBLIC_KEY'\n" +
      "      }).then(sub => {\n" +
      "        console.log('Subscribed:', sub);\n" +
      "      });\n\n" +
      "      this.swPush.messages.subscribe(message => {\n" +
      "        console.log('Push notification:', message);\n" +
      "      });\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Manifest Configuration:**\n\n" +
      "```json\n" +
      "// manifest.webmanifest\n" +
      "{\n" +
      '  "name": "My Angular PWA",\n' +
      '  "short_name": "AngularPWA",\n' +
      '  "theme_color": "#1976d2",\n' +
      '  "background_color": "#fafafa",\n' +
      '  "display": "standalone",\n' +
      '  "scope": "./",\n' +
      '  "start_url": "./",\n' +
      '  "icons": [\n' +
      "    {\n" +
      '      "src": "assets/icons/icon-72x72.png",\n' +
      '      "sizes": "72x72",\n' +
      '      "type": "image/png"\n' +
      "    }\n" +
      "  ]\n" +
      "}\n" +
      "```",
    category: "PWA",
    difficulty: "hard",
    tags: ["pwa", "service-workers", "offline", "push-notifications"],
  },
  {
    id: 59,
    question: "What is the Angular Compiler? Explain Ivy vs View Engine.",
    answer:
      "**Ivy (Angular 9+):**\n\n" +
      "Modern compiler and runtime, enabled by default.\n\n" +
      "```typescript\n" +
      "**Ivy Benefits:**\n\n" +
      "1. **Smaller bundles**: ~40% smaller\n" +
      "2. **Faster compilation**: Incremental compilation\n" +
      "3. **Better debugging**: More readable generated code\n" +
      "4. **Tree-shakeable**: Removes unused Angular code\n" +
      "5. **Backward compatible**: Works with View Engine libs\n" +
      "6. **Locality**: Compiles components independently\n" +
      "```\n\n" +
      "**Ivy Compilation:**\n\n" +
      "```typescript\n" +
      "// Before (View Engine)\n" +
      "@Component({\n" +
      "  template: '<h1>{{ title }}</h1>'\n" +
      "})\n" +
      "// Generated: Large, complex factory functions\n\n" +
      "// After (Ivy)\n" +
      "@Component({\n" +
      "  template: '<h1>{{ title }}</h1>'\n" +
      "})\n" +
      "// Generated: Instruction set (more efficient)\n" +
      "// ɵɵelementStart(0, 'h1');\n" +
      "// ɵɵtext(1, title);\n" +
      "// ɵɵelementEnd();\n" +
      "```\n\n" +
      "**Key Differences:**\n\n" +
      "```typescript\n" +
      "// View Engine (Legacy)\n" +
      "- Global compilation\n" +
      "- Larger bundles\n" +
      "- Complex metadata\n" +
      "- Slower builds\n\n" +
      "// Ivy (Modern)\n" +
      "- Component-level compilation\n" +
      "- Smaller bundles\n" +
      "- Simpler metadata\n" +
      "- Faster builds\n" +
      "- Better tree-shaking\n" +
      "```\n\n" +
      "**Migration:**\n\n" +
      "```bash\n" +
      "# Angular 9+ uses Ivy by default\n" +
      "# Check angular.json\n" +
      "{\n" +
      '  "projects": {\n' +
      '    "app": {\n' +
      '      "architect": {\n' +
      '        "build": {\n' +
      '          "options": {\n' +
      '            "aot": true // Ivy enabled\n' +
      "          }\n" +
      "        }\n" +
      "      }\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Compiler",
    difficulty: "hard",
    tags: ["ivy", "compiler", "view-engine", "angular-internals"],
  },
  {
    id: 60,
    question: "How do you implement Standalone Components? What are the benefits over NgModules?",
    answer:
      "Standalone components (Angular 14+) don't require NgModules.\n\n" +
      "**Basic Standalone Component:**\n\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "import { CommonModule } from '@angular/common';\n" +
      "import { FormsModule } from '@angular/forms';\n\n" +
      "@Component({\n" +
      "  selector: 'app-user',\n" +
      "  standalone: true,\n" +
      "  imports: [CommonModule, FormsModule], // Import directly!\n" +
      "  template: `\n" +
      '    <div *ngIf="user">\n' +
      '      <input [(ngModel)]="user.name" />\n' +
      "      <p>{{ user.name }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class UserComponent {\n" +
      "  user = { name: 'John' };\n" +
      "}\n" +
      "```\n\n" +
      "**Bootstrap Standalone App:**\n\n" +
      "```typescript\n" +
      "// main.ts\n" +
      "import { bootstrapApplication } from '@angular/platform-browser';\n" +
      "import { provideRouter } from '@angular/router';\n" +
      "import { provideHttpClient } from '@angular/common/http';\n\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideRouter(routes),\n" +
      "    provideHttpClient(),\n" +
      "    provideAnimations()\n" +
      "  ]\n" +
      "});\n" +
      "```\n\n" +
      "**Routing with Standalone:**\n\n" +
      "```typescript\n" +
      "// routes.ts\n" +
      "import { Routes } from '@angular/router';\n\n" +
      "export const routes: Routes = [\n" +
      "  {\n" +
      "    path: 'home',\n" +
      "    loadComponent: () => import('./home/home.component').then(m => m.HomeComponent)\n" +
      "  },\n" +
      "  {\n" +
      "    path: 'users',\n" +
      "    loadChildren: () => import('./users/routes').then(m => m.USER_ROUTES)\n" +
      "  }\n" +
      "];\n" +
      "```\n\n" +
      "**Benefits:**\n\n" +
      "```typescript\n" +
      "1. **Simpler**: No NgModule boilerplate\n" +
      "2. **Better tree-shaking**: Only import what you use\n" +
      "3. **Easier lazy loading**: Direct component imports\n" +
      "4. **Less coupling**: Self-contained components\n" +
      "5. **Easier testing**: No module configuration\n" +
      "```\n\n" +
      "**Migration:**\n\n" +
      "```bash\n" +
      "# Angular CLI can migrate automatically\n" +
      "ng generate @angular/core:standalone\n" +
      "```",
    category: "Architecture",
    difficulty: "intermediate",
    tags: ["standalone-components", "angular-14", "modules", "simplification"],
  },
  {
    id: 61,
    question:
      "What is the difference between ViewChild and ContentChild? Explain @ViewChildren vs @ContentChildren.",
    answer:
      "ViewChild/ContentChild query different parts of the component tree.\n\n" +
      "**@ViewChild - Query Own Template:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-parent',\n" +
      "  template: `\n" +
      "    <h1 #title>Title</h1>\n" +
      "    <input #nameInput />\n" +
      "    <app-child #childComp></app-child>\n" +
      "  `\n" +
      "})\n" +
      "export class ParentComponent implements AfterViewInit {\n" +
      "  @ViewChild('title') titleRef: ElementRef;\n" +
      "  @ViewChild('nameInput') inputRef: ElementRef;\n" +
      "  @ViewChild(ChildComponent) child: ChildComponent;\n\n" +
      "  ngAfterViewInit() {\n" +
      "    console.log(this.titleRef.nativeElement.textContent); // 'Title'\n" +
      "    this.inputRef.nativeElement.focus();\n" +
      "    this.child.someMethod();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**@ContentChild - Query Projected Content:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-card',\n" +
      "  template: `\n" +
      '    <div class="card">\n' +
      "      <ng-content></ng-content>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class CardComponent implements AfterContentInit {\n" +
      "  @ContentChild('cardTitle') title: ElementRef;\n\n" +
      "  ngAfterContentInit() {\n" +
      "    console.log(this.title.nativeElement.textContent);\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage\n" +
      "<app-card>\n" +
      "  <h2 #cardTitle>My Title</h2>\n" +
      "  <p>Content here</p>\n" +
      "</app-card>\n" +
      "```\n\n" +
      "**@ViewChildren vs @ContentChildren:**\n\n" +
      "```typescript\n" +
      "import { QueryList } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  template: `\n" +
      '    <app-item *ngFor="let item of items">{{ item }}</app-item>\n' +
      "  `\n" +
      "})\n" +
      "export class ParentComponent implements AfterViewInit {\n" +
      "  // Query ALL in template\n" +
      "  @ViewChildren(ItemComponent) viewItems: QueryList<ItemComponent>;\n\n" +
      "  ngAfterViewInit() {\n" +
      "    console.log(this.viewItems.length); // Number of items\n" +
      "    this.viewItems.forEach(item => item.highlight());\n\n" +
      "    // Listen to changes\n" +
      "    this.viewItems.changes.subscribe(items => {\n" +
      "      console.log('Items changed:', items.length);\n" +
      "    });\n" +
      "  }\n" +
      "}\n\n" +
      "// @ContentChildren - query ALL projected content\n" +
      "@Component({\n" +
      "  selector: 'app-tabs',\n" +
      "  template: '<ng-content></ng-content>'\n" +
      "})\n" +
      "export class TabsComponent implements AfterContentInit {\n" +
      "  @ContentChildren(TabComponent) tabs: QueryList<TabComponent>;\n\n" +
      "  ngAfterContentInit() {\n" +
      "    this.tabs.first.activate(); // Activate first tab\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage\n" +
      "<app-tabs>\n" +
      "  <app-tab>Tab 1</app-tab>\n" +
      "  <app-tab>Tab 2</app-tab>\n" +
      "  <app-tab>Tab 3</app-tab>\n" +
      "</app-tabs>\n" +
      "```\n\n" +
      "**Key Differences:**\n" +
      "- ViewChild: Component's own template\n" +
      "- ContentChild: Projected content (ng-content)\n" +
      "- Timing: AfterViewInit vs AfterContentInit",
    category: "Component Queries",
    difficulty: "intermediate",
    tags: ["viewchild", "contentchild", "queries", "lifecycle"],
  },
  {
    id: 62,
    question: "How do you implement Custom Directives? Create a structural directive example.",
    answer:
      "**Attribute Directive (Modify Element):**\n\n" +
      "```typescript\n" +
      "import { Directive, ElementRef, HostListener, Input } from '@angular/core';\n\n" +
      "@Directive({\n" +
      "  selector: '[appHighlight]',\n" +
      "  standalone: true\n" +
      "})\n" +
      "export class HighlightDirective {\n" +
      "  @Input() appHighlight = 'yellow';\n" +
      "  @Input() defaultColor = 'transparent';\n\n" +
      "  constructor(private el: ElementRef) {\n" +
      "    this.el.nativeElement.style.backgroundColor = this.defaultColor;\n" +
      "  }\n\n" +
      "  @HostListener('mouseenter') onMouseEnter() {\n" +
      "    this.highlight(this.appHighlight);\n" +
      "  }\n\n" +
      "  @HostListener('mouseleave') onMouseLeave() {\n" +
      "    this.highlight(this.defaultColor);\n" +
      "  }\n\n" +
      "  private highlight(color: string) {\n" +
      "    this.el.nativeElement.style.backgroundColor = color;\n" +
      "  }\n" +
      "}\n\n" +
      '// Usage: <p appHighlight="lightblue">Hover me</p>\n' +
      "```\n\n" +
      "**Structural Directive (Modify DOM Structure):**\n\n" +
      "```typescript\n" +
      "import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';\n\n" +
      "// Custom *ngIf\n" +
      "@Directive({\n" +
      "  selector: '[appIf]',\n" +
      "  standalone: true\n" +
      "})\n" +
      "export class IfDirective {\n" +
      "  private hasView = false;\n\n" +
      "  constructor(\n" +
      "    private templateRef: TemplateRef<unknown>,\n" +
      "    private viewContainer: ViewContainerRef\n" +
      "  ) {}\n\n" +
      "  @Input() set appIf(condition: boolean) {\n" +
      "    if (condition && !this.hasView) {\n" +
      "      this.viewContainer.createEmbeddedView(this.templateRef);\n" +
      "      this.hasView = true;\n" +
      "    } else if (!condition && this.hasView) {\n" +
      "      this.viewContainer.clear();\n" +
      "      this.hasView = false;\n" +
      "    }\n" +
      "  }\n" +
      "}\n\n" +
      '// Usage: <div *appIf="show">Content</div>\n' +
      "```\n\n" +
      "**Advanced: Custom *ngFor:**\n\n" +
      "```typescript\n" +
      "@Directive({\n" +
      "  selector: '[appRepeat]',\n" +
      "  standalone: true\n" +
      "})\n" +
      "export class RepeatDirective {\n" +
      "  constructor(\n" +
      "    private templateRef: TemplateRef<unknown>,\n" +
      "    private viewContainer: ViewContainerRef\n" +
      "  ) {}\n\n" +
      "  @Input() set appRepeat(times: number) {\n" +
      "    this.viewContainer.clear();\n" +
      "    for (let i = 0; i < times; i++) {\n" +
      "      this.viewContainer.createEmbeddedView(this.templateRef, {\n" +
      "        $implicit: i,\n" +
      "        index: i\n" +
      "      });\n" +
      "    }\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage:\n" +
      '<div *appRepeat="5; let i = index">\n' +
      "  Item {{ i }}\n" +
      "</div>\n" +
      "// Renders: Item 0, Item 1, Item 2, Item 3, Item 4\n" +
      "```\n\n" +
      "**Permission Directive:**\n\n" +
      "```typescript\n" +
      "@Directive({\n" +
      "  selector: '[appHasPermission]',\n" +
      "  standalone: true\n" +
      "})\n" +
      "export class HasPermissionDirective {\n" +
      "  constructor(\n" +
      "    private templateRef: TemplateRef<unknown>,\n" +
      "    private viewContainer: ViewContainerRef,\n" +
      "    private authService: AuthService\n" +
      "  ) {}\n\n" +
      "  @Input() set appHasPermission(permission: string) {\n" +
      "    if (this.authService.hasPermission(permission)) {\n" +
      "      this.viewContainer.createEmbeddedView(this.templateRef);\n" +
      "    } else {\n" +
      "      this.viewContainer.clear();\n" +
      "    }\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage:\n" +
      "<button *appHasPermission=\"'ADMIN'\">Delete User</button>\n" +
      "```",
    category: "Directives",
    difficulty: "hard",
    tags: ["directives", "structural-directives", "attribute-directives", "advanced"],
  },
  {
    id: 63,
    question:
      "What is the Angular HttpInterceptor chain? How do you implement multiple interceptors?",
    answer:
      "Interceptors form a chain to process HTTP requests/responses.\n\n" +
      "**Basic Interceptor:**\n\n" +
      "```typescript\n" +
      "import { HttpInterceptorFn } from '@angular/common/http';\n\n" +
      "// Functional interceptor (Angular 15+)\n" +
      "export const loggingInterceptor: HttpInterceptorFn = (req, next) => {\n" +
      "  console.log('Request:', req.url);\n" +
      "  return next(req).pipe(\n" +
      "    tap(event => {\n" +
      "      if (event.type === HttpEventType.Response) {\n" +
      "        console.log('Response:', event.status);\n" +
      "      }\n" +
      "    })\n" +
      "  );\n" +
      "};\n" +
      "```\n\n" +
      "**Class-Based Interceptor:**\n\n" +
      "```typescript\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler } from '@angular/common/http';\n\n" +
      "@Injectable()\n" +
      "export class AuthInterceptor implements HttpInterceptor {\n" +
      "  constructor(private authService: AuthService) {}\n\n" +
      "  intercept(req: HttpRequest<unknown>, next: HttpHandler) {\n" +
      "    // Clone and add auth header\n" +
      "    const token = this.authService.getToken();\n" +
      "    if (token) {\n" +
      "      req = req.clone({\n" +
      "        setHeaders: {\n" +
      "          Authorization: `Bearer ${token}`\n" +
      "        }\n" +
      "      });\n" +
      "    }\n" +
      "    return next.handle(req);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Error Handling Interceptor:**\n\n" +
      "```typescript\n" +
      "export const errorInterceptor: HttpInterceptorFn = (req, next) => {\n" +
      "  return next(req).pipe(\n" +
      "    catchError((error: HttpErrorResponse) => {\n" +
      "      if (error.status === 401) {\n" +
      "        // Redirect to login\n" +
      "        this.router.navigate(['/login']);\n" +
      "      } else if (error.status === 500) {\n" +
      "        // Show error message\n" +
      "        this.toastService.error('Server error');\n" +
      "      }\n" +
      "      return throwError(() => error);\n" +
      "    })\n" +
      "  );\n" +
      "};\n" +
      "```\n\n" +
      "**Loading Interceptor:**\n\n" +
      "```typescript\n" +
      "export const loadingInterceptor: HttpInterceptorFn = (req, next) => {\n" +
      "  const loadingService = inject(LoadingService);\n" +
      "  loadingService.show();\n\n" +
      "  return next(req).pipe(\n" +
      "    finalize(() => loadingService.hide())\n" +
      "  );\n" +
      "};\n" +
      "```\n\n" +
      "**Register Interceptors (Order Matters!):**\n\n" +
      "```typescript\n" +
      "// main.ts or app.config.ts\n" +
      "import { provideHttpClient, withInterceptors } from '@angular/common/http';\n\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideHttpClient(\n" +
      "      withInterceptors([\n" +
      "        loggingInterceptor,  // 1st\n" +
      "        authInterceptor,     // 2nd\n" +
      "        loadingInterceptor,  // 3rd\n" +
      "        errorInterceptor     // 4th (last)\n" +
      "      ])\n" +
      "    )\n" +
      "  ]\n" +
      "});\n\n" +
      "// Execution order:\n" +
      "// Request: 1 → 2 → 3 → 4 → Server\n" +
      "// Response: Server → 4 → 3 → 2 → 1\n" +
      "```\n\n" +
      "**Conditional Interceptor:**\n\n" +
      "```typescript\n" +
      "export const cacheInterceptor: HttpInterceptorFn = (req, next) => {\n" +
      "  // Only cache GET requests\n" +
      "  if (req.method !== 'GET') {\n" +
      "    return next(req);\n" +
      "  }\n\n" +
      "  const cached = cache.get(req.url);\n" +
      "  if (cached) {\n" +
      "    return of(cached); // Return cached response\n" +
      "  }\n\n" +
      "  return next(req).pipe(\n" +
      "    tap(response => cache.set(req.url, response))\n" +
      "  );\n" +
      "};\n" +
      "```",
    category: "HTTP",
    difficulty: "hard",
    tags: ["interceptors", "http", "middleware", "request-response"],
  },
  {
    id: 64,
    question:
      "How do you implement Performance Profiling in Angular? Explain Angular DevTools and profiling strategies.",
    answer:
      "**Angular DevTools (Chrome Extension):**\n\n" +
      "```typescript\n" +
      "// Install Angular DevTools extension\n" +
      "// Features:\n" +
      "// 1. Component Explorer - inspect component tree\n" +
      "// 2. Profiler - record performance\n" +
      "// 3. Change Detection - visualize CD cycles\n" +
      "```\n\n" +
      "**Profiling Change Detection:**\n\n" +
      "```typescript\n" +
      "import { enableDebugTools } from '@angular/platform-browser';\n" +
      "import { ApplicationRef } from '@angular/core';\n\n" +
      "// main.ts (development only)\n" +
      "platformBrowserDynamic()\n" +
      "  .bootstrapModule(AppModule)\n" +
      "  .then(moduleRef => {\n" +
      "    const appRef = moduleRef.injector.get(ApplicationRef);\n" +
      "    const comp = appRef.components[0];\n" +
      "    enableDebugTools(comp);\n" +
      "  });\n\n" +
      "// In browser console:\n" +
      "// ng.profiler.timeChangeDetection()\n" +
      "```\n\n" +
      "**Performance Measurement:**\n\n" +
      "```typescript\n" +
      "// Using Performance API\n" +
      "@Component({...})\n" +
      "export class Component implements OnInit {\n" +
      "  ngOnInit() {\n" +
      "    performance.mark('init-start');\n" +
      "    this.heavyOperation();\n" +
      "    performance.mark('init-end');\n" +
      "    performance.measure('init', 'init-start', 'init-end');\n\n" +
      "    const measure = performance.getEntriesByName('init')[0];\n" +
      "    console.log(`Init took ${measure.duration}ms`);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**OnPush Change Detection:**\n\n" +
      "```typescript\n" +
      "import { ChangeDetectionStrategy } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  changeDetection: ChangeDetectionStrategy.OnPush // Optimize!\n" +
      "})\n" +
      "export class Component {\n" +
      "  // Only checks when:\n" +
      "  // 1. @Input() changes (reference)\n" +
      "  // 2. Event fires\n" +
      "  // 3. Observable emits (async pipe)\n" +
      "  // 4. Manual: changeDetectorRef.markForCheck()\n" +
      "}\n" +
      "```\n\n" +
      "**TrackBy for *ngFor:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  template: `\n" +
      '    <div *ngFor="let item of items; trackBy: trackById">\n' +
      "      {{ item.name }}\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class Component {\n" +
      "  items = [...];\n\n" +
      "  // Prevents re-rendering unchanged items\n" +
      "  trackById(index: number, item: any) {\n" +
      "    return item.id; // Unique identifier\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Bundle Analysis:**\n\n" +
      "```bash\n" +
      "# Analyze bundle size\n" +
      "ng build --stats-json\n" +
      "npx webpack-bundle-analyzer dist/stats.json\n\n" +
      "# Or use source-map-explorer\n" +
      "npm install -g source-map-explorer\n" +
      "ng build --source-map\n" +
      "source-map-explorer dist/**/*.js\n" +
      "```",
    category: "Performance",
    difficulty: "hard",
    tags: ["performance", "profiling", "devtools", "optimization", "debugging"],
  },
  {
    id: 65,
    question: "What is Differential Loading in Angular? How does it work?",
    answer:
      "Differential loading serves modern ES2015+ code to modern browsers and ES5 to legacy browsers.\n\n" +
      "**How It Works:**\n\n" +
      "```typescript\n" +
      "// Angular CLI automatically generates two bundles:\n\n" +
      "// 1. Modern bundle (ES2015+):\n" +
      "// - main-es2015.js (smaller, faster)\n" +
      "// - For Chrome, Firefox, Safari, Edge\n\n" +
      "// 2. Legacy bundle (ES5):\n" +
      "// - main-es5.js (larger, includes polyfills)\n" +
      "// - For IE11, older browsers\n" +
      "```\n\n" +
      "**index.html Output:**\n\n" +
      "```html\n" +
      "<!-- Modern browsers load ES2015 -->\n" +
      '<script src="main-es2015.js" type="module"></script>\n\n' +
      "<!-- Legacy browsers load ES5 -->\n" +
      '<script src="main-es5.js" nomodule defer></script>\n\n' +
      '<!-- type="module" = modern browsers only -->\n' +
      "<!-- nomodule = legacy browsers only -->\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "- Smaller bundles for 95% of users\n" +
      "- Better performance on modern browsers\n" +
      "- Still supports legacy browsers\n\n" +
      "**Configuration (tsconfig.json):**\n\n" +
      "```json\n" +
      "{\n" +
      '  "compilerOptions": {\n' +
      '    "target": "ES2015",\n' +
      '    "module": "ES2015"\n' +
      "  }\n" +
      "}\n" +
      "```",
    category: "Build & Optimization",
    difficulty: "intermediate",
    tags: ["differential-loading", "build", "es5", "es2015", "performance"],
  },
  {
    id: 66,
    question:
      "How do you implement Testing strategies in Angular? Explain unit vs integration vs e2e testing.",
    answer:
      "**Unit Testing (Jasmine + Karma):**\n\n" +
      "```typescript\n" +
      "import { ComponentFixture, TestBed } from '@angular/core/testing';\n\n" +
      "describe('UserComponent', () => {\n" +
      "  let component: UserComponent;\n" +
      "  let fixture: ComponentFixture<UserComponent>;\n\n" +
      "  beforeEach(async () => {\n" +
      "    await TestBed.configureTestingModule({\n" +
      "      declarations: [UserComponent],\n" +
      "      providers: [UserService]\n" +
      "    }).compileComponents();\n\n" +
      "    fixture = TestBed.createComponent(UserComponent);\n" +
      "    component = fixture.componentInstance;\n" +
      "  });\n\n" +
      "  it('should create', () => {\n" +
      "    expect(component).toBeTruthy();\n" +
      "  });\n\n" +
      "  it('should display user name', () => {\n" +
      "    component.user = { name: 'John' };\n" +
      "    fixture.detectChanges();\n" +
      "    \n" +
      "    const compiled = fixture.nativeElement;\n" +
      "    expect(compiled.querySelector('h1').textContent).toContain('John');\n" +
      "  });\n\n" +
      "  it('should call service on save', () => {\n" +
      "    const service = TestBed.inject(UserService);\n" +
      "    spyOn(service, 'save');\n" +
      "    \n" +
      "    component.save();\n" +
      "    expect(service.save).toHaveBeenCalled();\n" +
      "  });\n" +
      "});\n" +
      "```\n\n" +
      "**Integration Testing:**\n\n" +
      "```typescript\n" +
      "import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\n\n" +
      "describe('UserService', () => {\n" +
      "  let service: UserService;\n" +
      "  let httpMock: HttpTestingController;\n\n" +
      "  beforeEach(() => {\n" +
      "    TestBed.configureTestingModule({\n" +
      "      imports: [HttpClientTestingModule],\n" +
      "      providers: [UserService]\n" +
      "    });\n\n" +
      "    service = TestBed.inject(UserService);\n" +
      "    httpMock = TestBed.inject(HttpTestingController);\n" +
      "  });\n\n" +
      "  it('should fetch users', () => {\n" +
      "    const mockUsers = [{ id: 1, name: 'John' }];\n\n" +
      "    service.getUsers().subscribe(users => {\n" +
      "      expect(users).toEqual(mockUsers);\n" +
      "    });\n\n" +
      "    const req = httpMock.expectOne('/api/users');\n" +
      "    expect(req.request.method).toBe('GET');\n" +
      "    req.flush(mockUsers);\n" +
      "  });\n\n" +
      "  afterEach(() => {\n" +
      "    httpMock.verify(); // Ensure no outstanding requests\n" +
      "  });\n" +
      "});\n" +
      "```\n\n" +
      "**E2E Testing (Cypress):**\n\n" +
      "```typescript\n" +
      "describe('User Flow', () => {\n" +
      "  beforeEach(() => {\n" +
      "    cy.visit('/users');\n" +
      "  });\n\n" +
      "  it('should add new user', () => {\n" +
      "    cy.get('[data-cy=add-user]').click();\n" +
      "    cy.get('[data-cy=name-input]').type('John Doe');\n" +
      "    cy.get('[data-cy=email-input]').type('john@example.com');\n" +
      "    cy.get('[data-cy=submit]').click();\n\n" +
      "    cy.get('[data-cy=user-list]').should('contain', 'John Doe');\n" +
      "  });\n\n" +
      "  it('should validate form', () => {\n" +
      "    cy.get('[data-cy=add-user]').click();\n" +
      "    cy.get('[data-cy=submit]').click();\n" +
      "    cy.get('[data-cy=error]').should('be.visible');\n" +
      "  });\n" +
      "});\n" +
      "```",
    category: "Testing",
    difficulty: "hard",
    tags: ["testing", "jasmine", "karma", "cypress", "unit-tests", "e2e"],
  },
  {
    id: 67,
    question:
      "What are the differences between Constructor, ngOnInit, and ngAfterViewInit? When to use each?",
    answer:
      "**Constructor - Dependency Injection:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  // ✅ Use constructor for:\n" +
      "  // - Dependency injection\n" +
      "  // - Simple initialization\n" +
      "  // - No DOM access\n" +
      "  // - No @Input() data yet\n\n" +
      "  private userId: number;\n\n" +
      "  constructor(\n" +
      "    private userService: UserService,\n" +
      "    private route: ActivatedRoute\n" +
      "  ) {\n" +
      "    // ❌ BAD - @Input not available yet\n" +
      "    // console.log(this.userId);\n\n" +
      "    // ✅ GOOD - Simple setup\n" +
      "    this.userId = 0;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**ngOnInit - Component Initialization:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class Component implements OnInit {\n" +
      "  @Input() userId: number;\n" +
      "  user: User;\n\n" +
      "  // ✅ Use ngOnInit for:\n" +
      "  // - @Input() values available\n" +
      "  // - HTTP requests\n" +
      "  // - Complex initialization\n" +
      "  // - Setup subscriptions\n\n" +
      "  ngOnInit() {\n" +
      "    // ✅ GOOD - @Input available\n" +
      "    if (this.userId) {\n" +
      "      this.loadUser(this.userId);\n" +
      "    }\n\n" +
      "    // ✅ GOOD - HTTP calls\n" +
      "    this.userService.getUsers().subscribe(users => {\n" +
      "      this.users = users;\n" +
      "    });\n\n" +
      "    // ❌ BAD - ViewChild not available\n" +
      "    // this.inputElement.nativeElement.focus();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**ngAfterViewInit - View Initialization:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class Component implements AfterViewInit {\n" +
      "  @ViewChild('nameInput') inputRef: ElementRef;\n" +
      "  @ViewChild(ChildComponent) child: ChildComponent;\n\n" +
      "  // ✅ Use ngAfterViewInit for:\n" +
      "  // - DOM manipulation\n" +
      "  // - @ViewChild queries\n" +
      "  // - Third-party lib initialization (charts, maps)\n" +
      "  // - Canvas operations\n\n" +
      "  ngAfterViewInit() {\n" +
      "    // ✅ GOOD - ViewChild available\n" +
      "    this.inputRef.nativeElement.focus();\n\n" +
      "    // ✅ GOOD - Access child component\n" +
      "    this.child.initialize();\n\n" +
      "    // ✅ GOOD - Init charts\n" +
      "    this.initChart();\n\n" +
      "    // ⚠️ Avoid change detection in same cycle\n" +
      "    // Use setTimeout or Promise for state changes\n" +
      "  }\n\n" +
      "  private initChart() {\n" +
      "    // Initialize chart library\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Lifecycle Sequence:**\n\n" +
      "```typescript\n" +
      "1. constructor()           // DI, no DOM\n" +
      "2. ngOnChanges()          // @Input changes\n" +
      "3. ngOnInit()             // Initialization\n" +
      "4. ngDoCheck()            // Change detection\n" +
      "5. ngAfterContentInit()   // Projected content\n" +
      "6. ngAfterContentChecked()// After content checked\n" +
      "7. ngAfterViewInit()      // View initialized ✅ DOM ready\n" +
      "8. ngAfterViewChecked()   // After view checked\n" +
      "9. ngOnDestroy()          // Cleanup\n" +
      "```",
    category: "Lifecycle Hooks",
    difficulty: "intermediate",
    tags: ["lifecycle", "constructor", "ngoninit", "ngafterviewinit", "hooks"],
  },
  {
    id: 68,
    question: "What is the Decorator Pattern in Angular? Explain all built-in decorators.",
    answer:
      "Decorators add metadata to classes, properties, methods, and parameters.\n\n" +
      "**Class Decorators:**\n\n" +
      "```typescript\n" +
      "// @Component\n" +
      "@Component({\n" +
      "  selector: 'app-user',\n" +
      "  template: '<h1>User</h1>',\n" +
      "  styles: ['h1 { color: blue; }']\n" +
      "})\n\n" +
      "// @Directive\n" +
      "@Directive({\n" +
      "  selector: '[appHighlight]'\n" +
      "})\n\n" +
      "// @Injectable\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n\n" +
      "// @Pipe\n" +
      "@Pipe({\n" +
      "  name: 'capitalize'\n" +
      "})\n\n" +
      "// @NgModule (deprecated with standalone)\n" +
      "@NgModule({\n" +
      "  declarations: [AppComponent],\n" +
      "  imports: [BrowserModule],\n" +
      "  bootstrap: [AppComponent]\n" +
      "})\n" +
      "```\n\n" +
      "**Property Decorators:**\n\n" +
      "```typescript\n" +
      "export class Component {\n" +
      "  // Input/Output\n" +
      "  @Input() userId: number;\n" +
      "  @Output() userChanged = new EventEmitter<User>();\n\n" +
      "  // View Queries\n" +
      "  @ViewChild('nameInput') input: ElementRef;\n" +
      "  @ViewChildren(ChildComponent) children: QueryList<ChildComponent>;\n\n" +
      "  // Content Queries\n" +
      "  @ContentChild('header') header: ElementRef;\n" +
      "  @ContentChildren(TabComponent) tabs: QueryList<TabComponent>;\n\n" +
      "  // Host Binding\n" +
      "  @HostBinding('class.active') isActive = true;\n" +
      "  @HostBinding('attr.role') role = 'button';\n" +
      "}\n" +
      "```\n\n" +
      "**Method Decorators:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  // Host Listener\n" +
      "  @HostListener('click', ['$event'])\n" +
      "  onClick(event: MouseEvent) {\n" +
      "    console.log('Clicked:', event);\n" +
      "  }\n\n" +
      "  @HostListener('window:resize', ['$event'])\n" +
      "  onResize(event: Event) {\n" +
      "    console.log('Window resized');\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Parameter Decorators:**\n\n" +
      "```typescript\n" +
      "import { Optional, Self, SkipSelf, Host, Inject } from '@angular/core';\n\n" +
      "export class Component {\n" +
      "  constructor(\n" +
      "    // @Optional - Service might not exist\n" +
      "    @Optional() private logger: LoggerService,\n\n" +
      "    // @Self - Only from this component's injector\n" +
      "    @Self() private localService: LocalService,\n\n" +
      "    // @SkipSelf - Skip this component, look in parent\n" +
      "    @SkipSelf() private parentService: ParentService,\n\n" +
      "    // @Host - Only look in host component\n" +
      "    @Host() private hostService: HostService,\n\n" +
      "    // @Inject - Inject token\n" +
      "    @Inject(CONFIG_TOKEN) private config: AppConfig\n" +
      "  ) {}\n" +
      "}\n" +
      "```\n\n" +
      "**Custom Decorator Example:**\n\n" +
      "```typescript\n" +
      "// Simple method decorator\n" +
      "export function Log() {\n" +
      "  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n" +
      "    const original = descriptor.value;\n" +
      "    \n" +
      "    descriptor.value = function(...args: unknown[]) {\n" +
      "      console.log(`Calling ${propertyKey} with`, args);\n" +
      "      const result = original.apply(this, args);\n" +
      "      console.log(`Result:`, result);\n" +
      "      return result;\n" +
      "    };\n" +
      "    \n" +
      "    return descriptor;\n" +
      "  };\n" +
      "}\n\n" +
      "// Usage\n" +
      "export class Component {\n" +
      "  @Log()\n" +
      "  saveUser(user: User) {\n" +
      "    return this.http.post('/api/users', user);\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Decorators",
    difficulty: "hard",
    tags: ["decorators", "metadata", "typescript", "advanced"],
  },
  {
    id: 69,
    question: "How do you implement Multi-Provider Pattern in Angular? Explain use cases.",
    answer:
      "Multi-providers allow multiple values for a single token.\n\n" +
      "**HTTP Interceptors (Built-in Multi-Provider):**\n\n" +
      "```typescript\n" +
      "// Each interceptor adds to the array\n" +
      "providers: [\n" +
      "  { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },\n" +
      "  { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true },\n" +
      "  { provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true }\n" +
      "]\n" +
      "// Angular calls all interceptors in order\n" +
      "```\n\n" +
      "**Custom Multi-Provider - Plugin System:**\n\n" +
      "```typescript\n" +
      "// Define interface\n" +
      "export interface Plugin {\n" +
      "  name: string;\n" +
      "  execute(): void;\n" +
      "}\n\n" +
      "// Create token\n" +
      "export const PLUGINS = new InjectionToken<Plugin[]>('plugins');\n\n" +
      "// Implement plugins\n" +
      "@Injectable()\n" +
      "export class LoggingPlugin implements Plugin {\n" +
      "  name = 'Logging';\n" +
      "  execute() {\n" +
      "    console.log('Logging plugin executed');\n" +
      "  }\n" +
      "}\n\n" +
      "@Injectable()\n" +
      "export class AnalyticsPlugin implements Plugin {\n" +
      "  name = 'Analytics';\n" +
      "  execute() {\n" +
      "    console.log('Analytics plugin executed');\n" +
      "  }\n" +
      "}\n\n" +
      "// Register plugins\n" +
      "providers: [\n" +
      "  { provide: PLUGINS, useClass: LoggingPlugin, multi: true },\n" +
      "  { provide: PLUGINS, useClass: AnalyticsPlugin, multi: true }\n" +
      "]\n\n" +
      "// Use plugins\n" +
      "@Component({...})\n" +
      "export class AppComponent implements OnInit {\n" +
      "  constructor(@Inject(PLUGINS) private plugins: Plugin[]) {}\n\n" +
      "  ngOnInit() {\n" +
      "    // Execute all plugins\n" +
      "    this.plugins.forEach(plugin => {\n" +
      "      console.log(`Running ${plugin.name}`);\n" +
      "      plugin.execute();\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Validation Rules Example:**\n\n" +
      "```typescript\n" +
      "export interface ValidationRule {\n" +
      "  validate(value: any): boolean;\n" +
      "  message: string;\n" +
      "}\n\n" +
      "export const VALIDATION_RULES = new InjectionToken<ValidationRule[]>('validation-rules');\n\n" +
      "@Injectable()\n" +
      "export class RequiredRule implements ValidationRule {\n" +
      "  message = 'This field is required';\n" +
      "  validate(value: any) {\n" +
      "    return !!value;\n" +
      "  }\n" +
      "}\n\n" +
      "@Injectable()\n" +
      "export class EmailRule implements ValidationRule {\n" +
      "  message = 'Invalid email format';\n" +
      "  validate(value: string) {\n" +
      "    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value);\n" +
      "  }\n" +
      "}\n\n" +
      "// Register\n" +
      "providers: [\n" +
      "  { provide: VALIDATION_RULES, useClass: RequiredRule, multi: true },\n" +
      "  { provide: VALIDATION_RULES, useClass: EmailRule, multi: true }\n" +
      "]\n\n" +
      "// Validator Service\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class ValidatorService {\n" +
      "  constructor(@Inject(VALIDATION_RULES) private rules: ValidationRule[]) {}\n\n" +
      "  validate(value: any): string[] {\n" +
      "    const errors: string[] = [];\n" +
      "    this.rules.forEach(rule => {\n" +
      "      if (!rule.validate(value)) {\n" +
      "        errors.push(rule.message);\n" +
      "      }\n" +
      "    });\n" +
      "    return errors;\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Dependency Injection",
    difficulty: "hard",
    tags: ["multi-provider", "di", "injection-token", "patterns", "advanced"],
  },
  {
    id: 70,
    question: "What is the RxJS shareReplay operator? How does it differ from share?",
    answer:
      "shareReplay caches and replays emissions to late subscribers.\n\n" +
      "**Problem (Without shareReplay):**\n\n" +
      "```typescript\n" +
      "// ❌ Each subscription triggers new HTTP request\n" +
      "const user$ = this.http.get('/api/user');\n\n" +
      "user$.subscribe(u => console.log('Sub 1:', u)); // Request 1\n" +
      "user$.subscribe(u => console.log('Sub 2:', u)); // Request 2 (duplicate!)\n" +
      "```\n\n" +
      "**Solution: shareReplay:**\n\n" +
      "```typescript\n" +
      "import { shareReplay } from 'rxjs/operators';\n\n" +
      "// ✅ Single request, cached result\n" +
      "const user$ = this.http.get('/api/user').pipe(\n" +
      "  shareReplay({ bufferSize: 1, refCount: true })\n" +
      ");\n\n" +
      "user$.subscribe(u => console.log('Sub 1:', u)); // Request\n" +
      "user$.subscribe(u => console.log('Sub 2:', u)); // From cache!\n" +
      "```\n\n" +
      "**shareReplay Options:**\n\n" +
      "```typescript\n" +
      "shareReplay({\n" +
      "  bufferSize: 1,     // How many values to cache\n" +
      "  refCount: true,    // Unsubscribe when no subscribers (cleanup)\n" +
      "  windowTime: 5000   // Cache expiration (ms)\n" +
      "})\n\n" +
      "// Common patterns:\n\n" +
      "// Cache forever\n" +
      "shareReplay(1)\n\n" +
      "// Cache with cleanup\n" +
      "shareReplay({ bufferSize: 1, refCount: true })\n\n" +
      "// Cache with expiration\n" +
      "shareReplay({ bufferSize: 1, windowTime: 5000 })\n" +
      "```\n\n" +
      "**vs share() operator:**\n\n" +
      "```typescript\n" +
      "// share() - No replay to late subscribers\n" +
      "const data$ = this.http.get('/api/data').pipe(share());\n\n" +
      "data$.subscribe(d => console.log('Sub 1:', d)); // Gets data\n" +
      "// ... time passes, request completes ...\n" +
      "data$.subscribe(d => console.log('Sub 2:', d)); // Gets nothing!\n\n" +
      "// shareReplay() - Replays to late subscribers\n" +
      "const data$ = this.http.get('/api/data').pipe(shareReplay(1));\n\n" +
      "data$.subscribe(d => console.log('Sub 1:', d)); // Gets data\n" +
      "// ... time passes, request completes ...\n" +
      "data$.subscribe(d => console.log('Sub 2:', d)); // Gets cached data!\n" +
      "```\n\n" +
      "**Service Example:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class UserService {\n" +
      "  private currentUser$ = this.http.get<User>('/api/user').pipe(\n" +
      "    shareReplay({ bufferSize: 1, refCount: true })\n" +
      "  );\n\n" +
      "  constructor(private http: HttpClient) {}\n\n" +
      "  getCurrentUser(): Observable<User> {\n" +
      "    return this.currentUser$;\n" +
      "  }\n\n" +
      "  // Multiple components can subscribe without duplicate requests\n" +
      "}\n" +
      "```",
    category: "RxJS",
    difficulty: "hard",
    tags: ["rxjs", "sharereplay", "share", "caching", "multicasting"],
  },
  {
    id: 71,
    question: "What is Micro-frontend Architecture? How do you implement it with Angular?",
    answer:
      "Micro-frontends break monolithic frontends into smaller, independent apps.\n\n" +
      "**Architecture:**\n\n" +
      "```typescript\n" +
      "// Shell App (Container)\n" +
      "// - Routing\n" +
      "// - Navigation\n" +
      "// - Authentication\n\n" +
      "// Micro-frontend 1 (Products)\n" +
      "// - Product list\n" +
      "// - Product details\n\n" +
      "// Micro-frontend 2 (Cart)\n" +
      "// - Shopping cart\n" +
      "// - Checkout\n\n" +
      "// Micro-frontend 3 (User)\n" +
      "// - Profile\n" +
      "// - Settings\n" +
      "```\n\n" +
      "**Module Federation Setup:**\n\n" +
      "```javascript\n" +
      "// webpack.config.js (Micro-frontend)\n" +
      "const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\n" +
      "module.exports = {\n" +
      "  plugins: [\n" +
      "    new ModuleFederationPlugin({\n" +
      "      name: 'products',\n" +
      "      filename: 'remoteEntry.js',\n" +
      "      exposes: {\n" +
      "        './ProductsModule': './src/app/products/products.module.ts'\n" +
      "      },\n" +
      "      shared: {\n" +
      "        '@angular/core': { singleton: true, strictVersion: true },\n" +
      "        '@angular/common': { singleton: true, strictVersion: true }\n" +
      "      }\n" +
      "    })\n" +
      "  ]\n" +
      "};\n\n" +
      "// webpack.config.js (Shell)\n" +
      "module.exports = {\n" +
      "  plugins: [\n" +
      "    new ModuleFederationPlugin({\n" +
      "      name: 'shell',\n" +
      "      remotes: {\n" +
      "        products: 'products@http://localhost:4201/remoteEntry.js',\n" +
      "        cart: 'cart@http://localhost:4202/remoteEntry.js'\n" +
      "      },\n" +
      "      shared: {\n" +
      "        '@angular/core': { singleton: true },\n" +
      "        '@angular/common': { singleton: true }\n" +
      "      }\n" +
      "    })\n" +
      "  ]\n" +
      "};\n" +
      "```\n\n" +
      "**Shell Routing:**\n\n" +
      "```typescript\n" +
      "const routes: Routes = [\n" +
      "  {\n" +
      "    path: 'products',\n" +
      "    loadChildren: () =>\n" +
      "      import('products/ProductsModule').then(m => m.ProductsModule)\n" +
      "  },\n" +
      "  {\n" +
      "    path: 'cart',\n" +
      "    loadChildren: () =>\n" +
      "      import('cart/CartModule').then(m => m.CartModule)\n" +
      "  }\n" +
      "];\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "- Independent deployment\n" +
      "- Team autonomy\n" +
      "- Technology diversity\n" +
      "- Faster builds\n" +
      "- Scalability\n\n" +
      "**Challenges:**\n" +
      "- Shared state\n" +
      "- Cross-app communication\n" +
      "- Version management\n" +
      "- Testing complexity\n" +
      "- Performance overhead",
    category: "Architecture",
    difficulty: "hard",
    tags: ["micro-frontends", "module-federation", "architecture", "scalability"],
  },
  {
    id: 72,
    question:
      "How do you implement Real-time Communication in Angular? Compare WebSockets, SSE, and Polling.",
    answer:
      "**1. WebSockets (Full-Duplex):**\n\n" +
      "```typescript\n" +
      "import { webSocket, WebSocketSubject } from 'rxjs/webSocket';\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class WebSocketService {\n" +
      "  private socket$: WebSocketSubject<unknown>;\n\n" +
      "  connect(): Observable<unknown> {\n" +
      "    if (!this.socket$ || this.socket$.closed) {\n" +
      "      this.socket$ = webSocket({\n" +
      "        url: 'ws://localhost:8080',\n" +
      "        openObserver: {\n" +
      "          next: () => console.log('Connected')\n" +
      "        },\n" +
      "        closeObserver: {\n" +
      "          next: () => console.log('Disconnected')\n" +
      "        }\n" +
      "      });\n" +
      "    }\n" +
      "    return this.socket$;\n" +
      "  }\n\n" +
      "  send(message: any) {\n" +
      "    this.socket$.next(message);\n" +
      "  }\n\n" +
      "  close() {\n" +
      "    this.socket$.complete();\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage\n" +
      "ngOnInit() {\n" +
      "  this.wsService.connect().subscribe(message => {\n" +
      "    console.log('Received:', message);\n" +
      "  });\n\n" +
      "  this.wsService.send({ type: 'subscribe', channel: 'chat' });\n" +
      "}\n" +
      "```\n\n" +
      "**2. Server-Sent Events (SSE) (Server → Client):**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class SSEService {\n" +
      "  getServerEvents(url: string): Observable<unknown> {\n" +
      "    return new Observable(observer => {\n" +
      "      const eventSource = new EventSource(url);\n\n" +
      "      eventSource.onmessage = (event) => {\n" +
      "        observer.next(JSON.parse(event.data));\n" +
      "      };\n\n" +
      "      eventSource.onerror = (error) => {\n" +
      "        observer.error(error);\n" +
      "      };\n\n" +
      "      // Cleanup\n" +
      "      return () => eventSource.close();\n" +
      "    });\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage\n" +
      "ngOnInit() {\n" +
      "  this.sseService.getServerEvents('/api/events').subscribe(event => {\n" +
      "    console.log('Event:', event);\n" +
      "  });\n" +
      "}\n" +
      "```\n\n" +
      "**3. Long Polling:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class PollingService {\n" +
      "  poll(url: string, interval: number = 5000): Observable<unknown> {\n" +
      "    return timer(0, interval).pipe(\n" +
      "      switchMap(() => this.http.get(url)),\n" +
      "      retry({ delay: 1000 })\n" +
      "    );\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage\n" +
      "ngOnInit() {\n" +
      "  this.pollingService.poll('/api/notifications', 5000)\n" +
      "    .subscribe(data => console.log('Polled data:', data));\n" +
      "}\n" +
      "```\n\n" +
      "**4. SignalR (Microsoft):**\n\n" +
      "```typescript\n" +
      "import * as signalR from '@microsoft/signalr';\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class SignalRService {\n" +
      "  private connection: signalR.HubConnection;\n\n" +
      "  startConnection() {\n" +
      "    this.connection = new signalR.HubConnectionBuilder()\n" +
      "      .withUrl('/chathub')\n" +
      "      .withAutomaticReconnect()\n" +
      "      .build();\n\n" +
      "    this.connection.start()\n" +
      "      .then(() => console.log('Connected'))\n" +
      "      .catch(err => console.error('Error:', err));\n" +
      "  }\n\n" +
      "  onMessage(callback: (user: string, message: string) => void) {\n" +
      "    this.connection.on('ReceiveMessage', callback);\n" +
      "  }\n\n" +
      "  sendMessage(user: string, message: string) {\n" +
      "    this.connection.invoke('SendMessage', user, message);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Comparison:**\n\n" +
      "| Feature | WebSocket | SSE | Polling |\n" +
      "|---------|-----------|-----|----------|\n" +
      "| Direction | Bi-directional | Server→Client | Client→Server |\n" +
      "| Overhead | Low | Medium | High |\n" +
      "| Browser Support | Modern | Good | All |\n" +
      "| Use Case | Chat, Gaming | Notifications | Simple updates |",
    category: "Real-time",
    difficulty: "hard",
    tags: ["websockets", "sse", "polling", "signalr", "real-time"],
  },
  {
    id: 73,
    question: "What is Angular Schematics? How do you create custom schematics?",
    answer:
      "Schematics are code generators for Angular projects.\n\n" +
      "**Built-in Schematics:**\n\n" +
      "```bash\n" +
      "# Generate component\n" +
      "ng generate component user\n\n" +
      "# Generate service\n" +
      "ng generate service api\n\n" +
      "# Add library\n" +
      "ng add @angular/material\n" +
      "```\n\n" +
      "**Create Custom Schematic:**\n\n" +
      "```bash\n" +
      "# Install schematics CLI\n" +
      "npm install -g @angular-devkit/schematics-cli\n\n" +
      "# Create schematic\n" +
      "schematics blank my-schematic\n" +
      "cd my-schematic\n" +
      "```\n\n" +
      "**Schematic Definition:**\n\n" +
      "```typescript\n" +
      "// src/my-component/index.ts\n" +
      "import {\n" +
      "  Rule,\n" +
      "  SchematicContext,\n" +
      "  Tree,\n" +
      "  apply,\n" +
      "  url,\n" +
      "  template,\n" +
      "  move,\n" +
      "  mergeWith\n" +
      "} from '@angular-devkit/schematics';\n" +
      "import { strings } from '@angular-devkit/core';\n\n" +
      "interface Schema {\n" +
      "  name: string;\n" +
      "  path?: string;\n" +
      "}\n\n" +
      "export function myComponent(options: Schema): Rule {\n" +
      "  return (tree: Tree, context: SchematicContext) => {\n" +
      "    // Create template files\n" +
      "    const templateSource = apply(url('./files'), [\n" +
      "      template({\n" +
      "        ...strings,\n" +
      "        ...options,\n" +
      "        name: strings.dasherize(options.name)\n" +
      "      }),\n" +
      "      move(options.path || '')\n" +
      "    ]);\n\n" +
      "    return mergeWith(templateSource)(tree, context);\n" +
      "  };\n" +
      "}\n" +
      "```\n\n" +
      "**Template Files:**\n\n" +
      "```typescript\n" +
      "// src/my-component/files/__name@dasherize__.component.ts.template\n" +
      "import { Component } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  selector: 'app-<%= dasherize(name) %>',\n" +
      "  templateUrl: './<%= dasherize(name) %>.component.html',\n" +
      "  styleUrls: ['./<%= dasherize(name) %>.component.css']\n" +
      "})\n" +
      "export class <%= classify(name) %>Component {\n" +
      "  constructor() { }\n" +
      "}\n" +
      "```\n\n" +
      "**Schema (collection.json):**\n\n" +
      "```json\n" +
      "{\n" +
      '  "$schema": "../node_modules/@angular-devkit/schematics/collection-schema.json",\n' +
      '  "schematics": {\n' +
      '    "my-component": {\n' +
      '      "description": "Generate a custom component",\n' +
      '      "factory": "./my-component/index#myComponent",\n' +
      '      "schema": "./my-component/schema.json"\n' +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Build & Use:**\n\n" +
      "```bash\n" +
      "# Build schematic\n" +
      "npm run build\n\n" +
      "# Test locally\n" +
      "schematics .:my-component --name=user\n\n" +
      "# Publish\n" +
      "npm publish\n\n" +
      "# Use in project\n" +
      "ng generate my-schematic:my-component user\n" +
      "```",
    category: "Tooling",
    difficulty: "hard",
    tags: ["schematics", "code-generation", "cli", "tooling"],
  },
  {
    id: 74,
    question:
      "What are Angular Workspace Configurations? Explain projects, libraries, and applications.",
    answer:
      "Angular workspace can contain multiple projects (apps & libraries).\n\n" +
      "**Workspace Structure:**\n\n" +
      "```typescript\n" +
      "my-workspace/\n" +
      "├── angular.json        # Workspace config\n" +
      "├── package.json\n" +
      "├── projects/\n" +
      "│   ├── app1/           # Application 1\n" +
      "│   ├── app2/           # Application 2\n" +
      "│   ├── shared-lib/     # Shared library\n" +
      "│   └── ui-components/  # Component library\n" +
      "└── tsconfig.json\n" +
      "```\n\n" +
      "**Create Library:**\n\n" +
      "```bash\n" +
      "# Generate library\n" +
      "ng generate library shared-lib\n\n" +
      "# Generate component in library\n" +
      "ng generate component button --project=shared-lib\n" +
      "```\n\n" +
      "**Library Structure:**\n\n" +
      "```typescript\n" +
      "projects/shared-lib/\n" +
      "├── src/\n" +
      "│   ├── lib/\n" +
      "│   │   ├── shared-lib.module.ts\n" +
      "│   │   ├── components/\n" +
      "│   │   ├── services/\n" +
      "│   │   └── utils/\n" +
      "│   └── public-api.ts        # Public exports\n" +
      "├── ng-package.json\n" +
      "└── package.json\n" +
      "```\n\n" +
      "**Public API (Exports):**\n\n" +
      "```typescript\n" +
      "// projects/shared-lib/src/public-api.ts\n" +
      "export * from './lib/shared-lib.module';\n" +
      "export * from './lib/components/button/button.component';\n" +
      "export * from './lib/services/logger.service';\n" +
      "```\n\n" +
      "**Use Library in App:**\n\n" +
      "```typescript\n" +
      "// Import from library\n" +
      "import { SharedLibModule, LoggerService } from 'shared-lib';\n\n" +
      "@Component({\n" +
      "  imports: [SharedLibModule]\n" +
      "})\n" +
      "export class AppComponent {\n" +
      "  constructor(private logger: LoggerService) {}\n" +
      "}\n" +
      "```\n\n" +
      "**Build Library:**\n\n" +
      "```bash\n" +
      "# Build library\n" +
      "ng build shared-lib\n\n" +
      "# Output: dist/shared-lib/\n\n" +
      "# Publish to npm\n" +
      "cd dist/shared-lib\n" +
      "npm publish\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "- Code reusability\n" +
      "- Modular architecture\n" +
      "- Separate versioning\n" +
      "- Easier testing\n" +
      "- Team collaboration",
    category: "Workspace",
    difficulty: "intermediate",
    tags: ["workspace", "libraries", "monorepo", "architecture"],
  },
  {
    id: 75,
    question:
      "How do you implement Error Tracking and Monitoring in Angular? Explain Sentry integration.",
    answer:
      "**Global Error Handler:**\n\n" +
      "```typescript\n" +
      "import { ErrorHandler, Injectable } from '@angular/core';\n\n" +
      "@Injectable()\n" +
      "export class GlobalErrorHandler implements ErrorHandler {\n" +
      "  constructor(private loggingService: LoggingService) {}\n\n" +
      "  handleError(error: Error) {\n" +
      "    // Log to console\n" +
      "    console.error('Global error:', error);\n\n" +
      "    // Log to service\n" +
      "    this.loggingService.logError({\n" +
      "      message: error.message,\n" +
      "      stack: error.stack,\n" +
      "      timestamp: new Date(),\n" +
      "      userAgent: navigator.userAgent\n" +
      "    });\n\n" +
      "    // Show user-friendly message\n" +
      "    this.showErrorToast('Something went wrong. Please try again.');\n" +
      "  }\n" +
      "}\n\n" +
      "// Register\n" +
      "providers: [\n" +
      "  { provide: ErrorHandler, useClass: GlobalErrorHandler }\n" +
      "]\n" +
      "```\n\n" +
      "**Sentry Integration:**\n\n" +
      "```bash\n" +
      "npm install @sentry/angular @sentry/tracing\n" +
      "```\n\n" +
      "```typescript\n" +
      "// main.ts\n" +
      "import * as Sentry from '@sentry/angular';\n" +
      "import { BrowserTracing } from '@sentry/tracing';\n\n" +
      "Sentry.init({\n" +
      "  dsn: 'YOUR_SENTRY_DSN',\n" +
      "  integrations: [\n" +
      "    new BrowserTracing({\n" +
      "      tracingOrigins: ['localhost', 'https://yourserver.com'],\n" +
      "      routingInstrumentation: Sentry.routingInstrumentation\n" +
      "    })\n" +
      "  ],\n" +
      "  tracesSampleRate: 1.0,\n" +
      "  environment: environment.production ? 'production' : 'development'\n" +
      "});\n\n" +
      "// App config\n" +
      "import { APP_INITIALIZER, ErrorHandler } from '@angular/core';\n" +
      "import { Router } from '@angular/router';\n\n" +
      "providers: [\n" +
      "  {\n" +
      "    provide: ErrorHandler,\n" +
      "    useValue: Sentry.createErrorHandler({\n" +
      "      showDialog: false\n" +
      "    })\n" +
      "  },\n" +
      "  {\n" +
      "    provide: Sentry.TraceService,\n" +
      "    deps: [Router]\n" +
      "  },\n" +
      "  {\n" +
      "    provide: APP_INITIALIZER,\n" +
      "    useFactory: () => () => {},\n" +
      "    deps: [Sentry.TraceService],\n" +
      "    multi: true\n" +
      "  }\n" +
      "]\n" +
      "```\n\n" +
      "**Custom Logging:**\n\n" +
      "```typescript\n" +
      "import * as Sentry from '@sentry/angular';\n\n" +
      "// Capture exception\n" +
      "try {\n" +
      "  riskyOperation();\n" +
      "} catch (error) {\n" +
      "  Sentry.captureException(error);\n" +
      "}\n\n" +
      "// Log message\n" +
      "Sentry.captureMessage('User completed checkout', 'info');\n\n" +
      "// Add context\n" +
      "Sentry.setUser({ id: '123', email: 'user@example.com' });\n" +
      "Sentry.setContext('order', { orderId: '456', total: 99.99 });\n\n" +
      "// Breadcrumbs\n" +
      "Sentry.addBreadcrumb({\n" +
      "  category: 'navigation',\n" +
      "  message: 'User navigated to checkout',\n" +
      "  level: 'info'\n" +
      "});\n" +
      "```",
    category: "Monitoring",
    difficulty: "hard",
    tags: ["error-tracking", "sentry", "monitoring", "logging"],
  },
  {
    id: 76,
    question: "What is the Angular Compiler API? How do you use it programmatically?",
    answer:
      "The Compiler API allows programmatic compilation of Angular code.\n\n" +
      "**Use Cases:**\n" +
      "- Custom build tools\n" +
      "- Code generation\n" +
      "- Template compilation\n" +
      "- Dynamic module loading\n\n" +
      "**Basic Example:**\n\n" +
      "```typescript\n" +
      "import { Compiler, Component, NgModule } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  selector: 'dynamic-comp',\n" +
      "  template: '<h1>{{ title }}</h1>'\n" +
      "})\n" +
      "class DynamicComponent {\n" +
      "  title = 'Dynamic!';\n" +
      "}\n\n" +
      "@NgModule({\n" +
      "  declarations: [DynamicComponent]\n" +
      "})\n" +
      "class DynamicModule {}\n\n" +
      "// Compile and load dynamically\n" +
      "export class AppComponent {\n" +
      "  constructor(\n" +
      "    private compiler: Compiler,\n" +
      "    private viewContainerRef: ViewContainerRef\n" +
      "  ) {}\n\n" +
      "  async loadDynamic() {\n" +
      "    const module = await this.compiler.compileModuleAsync(DynamicModule);\n" +
      "    const moduleRef = module.create(this.viewContainerRef.injector);\n" +
      "    const factory = moduleRef.componentFactoryResolver.resolveComponentFactory(DynamicComponent);\n" +
      "    this.viewContainerRef.createComponent(factory);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Note:** With Ivy, dynamic compilation is less common. Use Angular Elements or Module Federation instead.",
    category: "Compiler",
    difficulty: "hard",
    tags: ["compiler", "api", "dynamic", "advanced"],
  },
  {
    id: 77,
    question: "How do you implement Feature Flags in Angular?",
    answer:
      "Feature flags enable/disable features without redeployment.\n\n" +
      "**Service Implementation:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class FeatureFlagService {\n" +
      "  private flags: Record<string, boolean> = {};\n\n" +
      "  constructor(private http: HttpClient) {}\n\n" +
      "  loadFlags(): Observable<void> {\n" +
      "    return this.http.get<Record<string, boolean>>('/api/feature-flags').pipe(\n" +
      "      tap(flags => this.flags = flags),\n" +
      "      map(() => undefined)\n" +
      "    );\n" +
      "  }\n\n" +
      "  isEnabled(flag: string): boolean {\n" +
      "    return this.flags[flag] === true;\n" +
      "  }\n" +
      "}\n\n" +
      "// Initialize in app\n" +
      "export const appInitializer = (featureService: FeatureFlagService) => {\n" +
      "  return () => featureService.loadFlags().toPromise();\n" +
      "};\n\n" +
      "providers: [\n" +
      "  {\n" +
      "    provide: APP_INITIALIZER,\n" +
      "    useFactory: appInitializer,\n" +
      "    deps: [FeatureFlagService],\n" +
      "    multi: true\n" +
      "  }\n" +
      "]\n" +
      "```\n\n" +
      "**Directive:**\n\n" +
      "```typescript\n" +
      "@Directive({\n" +
      "  selector: '[featureFlag]',\n" +
      "  standalone: true\n" +
      "})\n" +
      "export class FeatureFlagDirective implements OnInit {\n" +
      "  @Input() featureFlag: string;\n\n" +
      "  constructor(\n" +
      "    private templateRef: TemplateRef<unknown>,\n" +
      "    private viewContainer: ViewContainerRef,\n" +
      "    private featureService: FeatureFlagService\n" +
      "  ) {}\n\n" +
      "  ngOnInit() {\n" +
      "    if (this.featureService.isEnabled(this.featureFlag)) {\n" +
      "      this.viewContainer.createEmbeddedView(this.templateRef);\n" +
      "    } else {\n" +
      "      this.viewContainer.clear();\n" +
      "    }\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage\n" +
      "<div *featureFlag=\"'new-checkout'\">New checkout flow</div>\n" +
      "```\n\n" +
      "**Route Guard:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class FeatureFlagGuard implements CanActivate {\n" +
      "  constructor(private featureService: FeatureFlagService) {}\n\n" +
      "  canActivate(route: ActivatedRouteSnapshot): boolean {\n" +
      "    const flag = route.data['featureFlag'];\n" +
      "    return this.featureService.isEnabled(flag);\n" +
      "  }\n" +
      "}\n\n" +
      "// Route\n" +
      "{\n" +
      "  path: 'beta',\n" +
      "  component: BetaComponent,\n" +
      "  canActivate: [FeatureFlagGuard],\n" +
      "  data: { featureFlag: 'beta-features' }\n" +
      "}\n" +
      "```",
    category: "Patterns",
    difficulty: "intermediate",
    tags: ["feature-flags", "patterns", "deployment"],
  },
  {
    id: 78,
    question: "What is Angular's Hydration? How does it improve SSR performance?",
    answer:
      "Hydration reuses server-rendered DOM instead of re-rendering on client.\n\n" +
      "**Problem (Without Hydration):**\n\n" +
      "```typescript\n" +
      "// 1. Server renders HTML\n" +
      "// 2. Client receives HTML (displayed immediately)\n" +
      "// 3. Angular loads and RE-RENDERS everything (flicker!)\n" +
      "// 4. Event listeners attached\n" +
      "```\n\n" +
      "**Solution (With Hydration):**\n\n" +
      "```typescript\n" +
      "// 1. Server renders HTML + state\n" +
      "// 2. Client receives HTML (displayed)\n" +
      "// 3. Angular REUSES existing DOM (no re-render!)\n" +
      "// 4. Event listeners attached\n" +
      "```\n\n" +
      "**Enable Hydration:**\n\n" +
      "```typescript\n" +
      "// main.ts\n" +
      "import { provideClientHydration } from '@angular/platform-browser';\n\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideClientHydration() // Enable hydration!\n" +
      "  ]\n" +
      "});\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "- No flicker on load\n" +
      "- Faster Time to Interactive (TTI)\n" +
      "- Better user experience\n" +
      "- Reduced bandwidth\n\n" +
      "**Available since:** Angular 16+",
    category: "SSR",
    difficulty: "hard",
    tags: ["hydration", "ssr", "performance", "angular-16"],
  },
  {
    id: 79,
    question: "What are Input/Output Transforms in Angular? How do you use them?",
    answer:
      "Input/Output transforms automatically convert values.\n\n" +
      "**Input Transforms (Angular 16+):**\n\n" +
      "```typescript\n" +
      "import { Component, Input, booleanAttribute, numberAttribute } from '@angular/core';\n\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  // Transform string to boolean\n" +
      "  @Input({ transform: booleanAttribute }) disabled: boolean = false;\n" +
      "  // <comp disabled></comp> → disabled = true\n" +
      "  // <comp></comp> → disabled = false\n\n" +
      "  // Transform string to number\n" +
      "  @Input({ transform: numberAttribute }) count: number = 0;\n" +
      '  // <comp count="5"></comp> → count = 5 (number)\n\n' +
      "  // Custom transform\n" +
      "  @Input({ transform: trimString }) name: string = '';\n" +
      "}\n\n" +
      "// Custom transform function\n" +
      "function trimString(value: string | undefined): string {\n" +
      "  return value?.trim() ?? '';\n" +
      "}\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "- Type safety\n" +
      "- Cleaner code\n" +
      "- Automatic conversion\n" +
      "- Less boilerplate",
    category: "Components",
    difficulty: "intermediate",
    tags: ["inputs", "transforms", "angular-16", "type-safety"],
  },
  {
    id: 80,
    question: "What is the Self-Documenting Code principle? How do you apply it in Angular?",
    answer:
      "Self-documenting code is clear without extensive comments.\n\n" +
      "**Naming Conventions:**\n\n" +
      "```typescript\n" +
      "// ❌ BAD\n" +
      "getUserData(id) {}\n" +
      "const d = new Date();\n\n" +
      "// ✅ GOOD\n" +
      "async fetchUserProfileById(userId: number): Promise<UserProfile> {}\n" +
      "const currentDate = new Date();\n" +
      "```\n\n" +
      "**Component Organization:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class UserProfileComponent {\n" +
      "  // 1. Inputs/Outputs\n" +
      "  @Input() userId: number;\n" +
      "  @Output() profileUpdated = new EventEmitter<User>();\n\n" +
      "  // 2. Public properties\n" +
      "  user$: Observable<User>;\n" +
      "  isLoading = false;\n\n" +
      "  // 3. Private properties\n" +
      "  private destroy$ = new Subject<void>();\n\n" +
      "  // 4. Constructor\n" +
      "  constructor(private userService: UserService) {}\n\n" +
      "  // 5. Lifecycle hooks\n" +
      "  ngOnInit() {}\n" +
      "  ngOnDestroy() {}\n\n" +
      "  // 6. Public methods\n" +
      "  async saveProfile() {}\n\n" +
      "  // 7. Private methods\n" +
      "  private validateProfile() {}\n" +
      "}\n" +
      "```\n\n" +
      "**Use RxJS Declaratively:**\n\n" +
      "```typescript\n" +
      "// ✅ GOOD - Intent is clear\n" +
      "activeUsers$ = this.users$.pipe(\n" +
      "  map(users => users.filter(user => user.isActive)),\n" +
      "  shareReplay(1)\n" +
      ");\n" +
      "```",
    category: "Best Practices",
    difficulty: "intermediate",
    tags: ["clean-code", "best-practices", "naming", "organization"],
  },
  {
    id: 81,
    question:
      "What is NgRx Store Architecture? Explain the complete data flow from component to store and back.",
    answer:
      "NgRx implements Redux pattern with RxJS for Angular.\n\n" +
      "**Store Architecture Diagram:**\n\n" +
      "```typescript\n" +
      "Component → dispatch(Action) → Reducer → New State → Store → Selector → Component\n" +
      "                    ↓\n" +
      "                 Effect (side effects like HTTP)\n" +
      "                    ↓\n" +
      "             New Action → Reducer\n" +
      "```\n\n" +
      "**Complete Flow Example:**\n\n" +
      "```typescript\n" +
      "// 1. Component dispatches action\n" +
      "@Component({...})\n" +
      "export class UsersComponent {\n" +
      "  users$ = this.store.select(selectAllUsers);\n\n" +
      "  constructor(private store: Store) {}\n\n" +
      "  ngOnInit() {\n" +
      "    // Dispatch: Component → Store\n" +
      "    this.store.dispatch(loadUsers());\n" +
      "  }\n" +
      "}\n\n" +
      "// 2. Effect catches action, performs side effect\n" +
      "@Injectable()\n" +
      "export class UsersEffects {\n" +
      "  loadUsers$ = createEffect(() =>\n" +
      "    this.actions$.pipe(\n" +
      "      ofType(loadUsers),\n" +
      "      switchMap(() =>\n" +
      "        this.http.get<User[]>('/api/users').pipe(\n" +
      "          // Success: dispatch new action\n" +
      "          map(users => loadUsersSuccess({ users })),\n" +
      "          // Error: dispatch error action\n" +
      "          catchError(error => of(loadUsersFailure({ error })))\n" +
      "        )\n" +
      "      )\n" +
      "    )\n" +
      "  );\n\n" +
      "  constructor(private actions$: Actions, private http: HttpClient) {}\n" +
      "}\n\n" +
      "// 3. Reducer updates state\n" +
      "export const usersReducer = createReducer(\n" +
      "  initialState,\n" +
      "  on(loadUsers, state => ({ ...state, loading: true })),\n" +
      "  on(loadUsersSuccess, (state, { users }) => ({\n" +
      "    ...state,\n" +
      "    users,\n" +
      "    loading: false,\n" +
      "    error: null\n" +
      "  }))\n" +
      ");\n\n" +
      "// 4. Selector retrieves data\n" +
      "export const selectAllUsers = createSelector(\n" +
      "  selectUsersState,\n" +
      "  state => state.users\n" +
      ");\n\n" +
      "// 5. Component receives update via observable\n" +
      "// users$ automatically updates when store changes\n" +
      "```\n\n" +
      "**Key Principles:**\n" +
      "1. Single source of truth (Store)\n" +
      "2. State is read-only (immutable)\n" +
      "3. Changes via pure functions (Reducers)\n" +
      "4. Side effects isolated (Effects)\n" +
      "5. Predictable state updates",
    category: "NgRx Architecture",
    difficulty: "hard",
    tags: ["ngrx", "store", "architecture", "redux", "state-management"],
  },
  {
    id: 82,
    question:
      "What are NgRx Actions and Action Creators? Explain props, createAction, and action groups.",
    answer:
      "Actions are events that trigger state changes.\n\n" +
      "**Basic Actions:**\n\n" +
      "```typescript\n" +
      "import { createAction, props } from '@ngrx/store';\n\n" +
      "// Simple action (no payload)\n" +
      "export const increment = createAction('[Counter] Increment');\n" +
      "export const decrement = createAction('[Counter] Decrement');\n" +
      "export const reset = createAction('[Counter] Reset');\n\n" +
      "// Action with payload\n" +
      "export const setCount = createAction(\n" +
      "  '[Counter] Set Count',\n" +
      "  props<{ count: number }>()\n" +
      ");\n\n" +
      "// Dispatch\n" +
      "this.store.dispatch(increment());\n" +
      "this.store.dispatch(setCount({ count: 10 }));\n" +
      "```\n\n" +
      "**Action Groups (Organized):**\n\n" +
      "```typescript\n" +
      "import { createActionGroup, props, emptyProps } from '@ngrx/store';\n\n" +
      "// Group related actions\n" +
      "export const UsersActions = createActionGroup({\n" +
      "  source: 'Users',\n" +
      "  events: {\n" +
      "    // Auto-generates: [Users] Load Users\n" +
      "    'Load Users': emptyProps(),\n" +
      "    \n" +
      "    // Auto-generates: [Users] Load Users Success\n" +
      "    'Load Users Success': props<{ users: User[] }>(),\n" +
      "    \n" +
      "    'Load Users Failure': props<{ error: string }>(),\n" +
      "    'Add User': props<{ user: User }>(),\n" +
      "    'Update User': props<{ id: number; changes: Partial<User> }>(),\n" +
      "    'Delete User': props<{ id: number }>()\n" +
      "  }\n" +
      "});\n\n" +
      "// Usage\n" +
      "this.store.dispatch(UsersActions.loadUsers());\n" +
      "this.store.dispatch(UsersActions.addUser({ user: newUser }));\n" +
      "```\n\n" +
      "**Action Naming Convention:**\n\n" +
      "```typescript\n" +
      "// Pattern: [Source] Event\n" +
      "[Users Page] Load Users\n" +
      "[Users API] Load Users Success\n" +
      "[Users API] Load Users Failure\n" +
      "[Login Page] Login\n" +
      "[Auth API] Login Success\n" +
      "[Auth Guard] Logout\n\n" +
      "// Good naming:\n" +
      "export const loginSuccess = createAction(\n" +
      "  '[Auth API] Login Success',\n" +
      "  props<{ user: User; token: string }>()\n" +
      ");\n\n" +
      "// Bad naming:\n" +
      "export const login = createAction('login'); // No source!\n" +
      "```\n\n" +
      "**Multiple Props:**\n\n" +
      "```typescript\n" +
      "export const updateUser = createAction(\n" +
      "  '[Users] Update User',\n" +
      "  props<{ id: number; name: string; email: string }>()\n" +
      ");\n\n" +
      "// Or use interface\n" +
      "export interface UpdateUserProps {\n" +
      "  id: number;\n" +
      "  changes: Partial<User>;\n" +
      "}\n\n" +
      "export const updateUser = createAction(\n" +
      "  '[Users] Update User',\n" +
      "  props<UpdateUserProps>()\n" +
      ");\n" +
      "```",
    category: "NgRx Actions",
    difficulty: "hard",
    tags: ["ngrx", "actions", "action-creators", "action-groups"],
  },
  {
    id: 83,
    question: "What are NgRx Reducers? Explain pure functions, immutability, and on() handlers.",
    answer:
      "Reducers are pure functions that transform state based on actions.\n\n" +
      "**Basic Reducer:**\n\n" +
      "```typescript\n" +
      "import { createReducer, on } from '@ngrx/store';\n\n" +
      "export interface CounterState {\n" +
      "  count: number;\n" +
      "  lastUpdated: Date | null;\n" +
      "}\n\n" +
      "const initialState: CounterState = {\n" +
      "  count: 0,\n" +
      "  lastUpdated: null\n" +
      "};\n\n" +
      "export const counterReducer = createReducer(\n" +
      "  initialState,\n" +
      "  // Handle increment\n" +
      "  on(increment, state => ({\n" +
      "    ...state,\n" +
      "    count: state.count + 1,\n" +
      "    lastUpdated: new Date()\n" +
      "  })),\n" +
      "  // Handle decrement\n" +
      "  on(decrement, state => ({\n" +
      "    ...state,\n" +
      "    count: state.count - 1,\n" +
      "    lastUpdated: new Date()\n" +
      "  })),\n" +
      "  // Handle set with payload\n" +
      "  on(setCount, (state, { count }) => ({\n" +
      "    ...state,\n" +
      "    count,\n" +
      "    lastUpdated: new Date()\n" +
      "  })),\n" +
      "  // Handle reset\n" +
      "  on(reset, state => initialState)\n" +
      ");\n" +
      "```\n\n" +
      "**Multiple Actions, Same Handler:**\n\n" +
      "```typescript\n" +
      "// Handle multiple actions with same logic\n" +
      "on(\n" +
      "  loadUsers,\n" +
      "  refreshUsers,\n" +
      "  state => ({ ...state, loading: true })\n" +
      ")\n" +
      "```\n\n" +
      "**Complex State Update:**\n\n" +
      "```typescript\n" +
      "export interface UsersState {\n" +
      "  entities: { [id: number]: User };\n" +
      "  ids: number[];\n" +
      "  selectedUserId: number | null;\n" +
      "  loading: boolean;\n" +
      "  error: string | null;\n" +
      "}\n\n" +
      "export const usersReducer = createReducer(\n" +
      "  initialState,\n" +
      "  // Load users success\n" +
      "  on(loadUsersSuccess, (state, { users }) => {\n" +
      "    const entities = users.reduce((acc, user) => ({\n" +
      "      ...acc,\n" +
      "      [user.id]: user\n" +
      "    }), {});\n" +
      "    const ids = users.map(u => u.id);\n\n" +
      "    return {\n" +
      "      ...state,\n" +
      "      entities,\n" +
      "      ids,\n" +
      "      loading: false,\n" +
      "      error: null\n" +
      "    };\n" +
      "  }),\n" +
      "  // Update user\n" +
      "  on(updateUserSuccess, (state, { user }) => ({\n" +
      "    ...state,\n" +
      "    entities: {\n" +
      "      ...state.entities,\n" +
      "      [user.id]: user\n" +
      "    }\n" +
      "  })),\n" +
      "  // Delete user\n" +
      "  on(deleteUserSuccess, (state, { id }) => {\n" +
      "    const { [id]: removed, ...entities } = state.entities;\n" +
      "    return {\n" +
      "      ...state,\n" +
      "      entities,\n" +
      "      ids: state.ids.filter(i => i !== id)\n" +
      "    };\n" +
      "  })\n" +
      ");\n" +
      "```\n\n" +
      "**Reducer Rules:**\n" +
      "1. Pure functions (no side effects)\n" +
      "2. Immutable updates (spread operator)\n" +
      "3. Return new state object\n" +
      "4. No API calls, no mutations\n" +
      "5. Synchronous only",
    category: "NgRx Reducers",
    difficulty: "hard",
    tags: ["ngrx", "reducers", "pure-functions", "immutability"],
  },
  {
    id: 84,
    question:
      "What are NgRx Effects? Explain how to handle HTTP calls, errors, and chained effects.",
    answer:
      "Effects handle side effects (HTTP, localStorage, etc.) outside reducers.\n\n" +
      "**Basic Effect:**\n\n" +
      "```typescript\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { Actions, createEffect, ofType } from '@ngrx/effects';\n" +
      "import { of } from 'rxjs';\n" +
      "import { map, catchError, switchMap, tap } from 'rxjs/operators';\n\n" +
      "@Injectable()\n" +
      "export class UsersEffects {\n" +
      "  // Load users effect\n" +
      "  loadUsers$ = createEffect(() =>\n" +
      "    this.actions$.pipe(\n" +
      "      ofType(UsersActions.loadUsers),\n" +
      "      switchMap(() =>\n" +
      "        this.http.get<User[]>('/api/users').pipe(\n" +
      "          map(users => UsersActions.loadUsersSuccess({ users })),\n" +
      "          catchError(error =>\n" +
      "            of(UsersActions.loadUsersFailure({ error: error.message }))\n" +
      "          )\n" +
      "        )\n" +
      "      )\n" +
      "    )\n" +
      "  );\n\n" +
      "  constructor(\n" +
      "    private actions$: Actions,\n" +
      "    private http: HttpClient\n" +
      "  ) {}\n" +
      "}\n" +
      "```\n\n" +
      "**Create/Update/Delete Effects:**\n\n" +
      "```typescript\n" +
      "@Injectable()\n" +
      "export class UsersEffects {\n" +
      "  // Create\n" +
      "  createUser$ = createEffect(() =>\n" +
      "    this.actions$.pipe(\n" +
      "      ofType(UsersActions.addUser),\n" +
      "      switchMap(({ user }) =>\n" +
      "        this.http.post<User>('/api/users', user).pipe(\n" +
      "          map(newUser => UsersActions.addUserSuccess({ user: newUser })),\n" +
      "          catchError(error => of(UsersActions.addUserFailure({ error })))\n" +
      "        )\n" +
      "      )\n" +
      "    )\n" +
      "  );\n\n" +
      "  // Update\n" +
      "  updateUser$ = createEffect(() =>\n" +
      "    this.actions$.pipe(\n" +
      "      ofType(UsersActions.updateUser),\n" +
      "      switchMap(({ id, changes }) =>\n" +
      "        this.http.put<User>(`/api/users/${id}`, changes).pipe(\n" +
      "          map(user => UsersActions.updateUserSuccess({ user })),\n" +
      "          catchError(error => of(UsersActions.updateUserFailure({ error })))\n" +
      "        )\n" +
      "      )\n" +
      "    )\n" +
      "  );\n\n" +
      "  // Delete\n" +
      "  deleteUser$ = createEffect(() =>\n" +
      "    this.actions$.pipe(\n" +
      "      ofType(UsersActions.deleteUser),\n" +
      "      switchMap(({ id }) =>\n" +
      "        this.http.delete(`/api/users/${id}`).pipe(\n" +
      "          map(() => UsersActions.deleteUserSuccess({ id })),\n" +
      "          catchError(error => of(UsersActions.deleteUserFailure({ error })))\n" +
      "        )\n" +
      "      )\n" +
      "    )\n" +
      "  );\n" +
      "}\n" +
      "```\n\n" +
      "**Non-Dispatching Effect (Side Effects Only):**\n\n" +
      "```typescript\n" +
      "// Show toast on success\n" +
      "showSuccessToast$ = createEffect(\n" +
      "  () =>\n" +
      "    this.actions$.pipe(\n" +
      "      ofType(UsersActions.addUserSuccess),\n" +
      "      tap(() => this.toastService.success('User added!'))\n" +
      "    ),\n" +
      "  { dispatch: false } // Don't dispatch new action\n" +
      ");\n\n" +
      "// Save to localStorage\n" +
      "saveToLocalStorage$ = createEffect(\n" +
      "  () =>\n" +
      "    this.actions$.pipe(\n" +
      "      ofType(UsersActions.loadUsersSuccess),\n" +
      "      tap(({ users }) => localStorage.setItem('users', JSON.stringify(users)))\n" +
      "    ),\n" +
      "  { dispatch: false }\n" +
      ");\n" +
      "```\n\n" +
      "**Chained Effects:**\n\n" +
      "```typescript\n" +
      "// After login success, load user profile\n" +
      "loadProfileAfterLogin$ = createEffect(() =>\n" +
      "  this.actions$.pipe(\n" +
      "    ofType(AuthActions.loginSuccess),\n" +
      "    map(({ userId }) => ProfileActions.loadProfile({ userId }))\n" +
      "  )\n" +
      ");\n" +
      "```",
    category: "NgRx Effects",
    difficulty: "hard",
    tags: ["ngrx", "effects", "side-effects", "http", "rxjs"],
  },
  {
    id: 85,
    question:
      "What are NgRx Selectors? Explain createSelector, memoization, and selector composition.",
    answer:
      "Selectors efficiently retrieve and derive data from the store.\n\n" +
      "**Basic Selectors:**\n\n" +
      "```typescript\n" +
      "import { createFeatureSelector, createSelector } from '@ngrx/store';\n\n" +
      "// Feature selector\n" +
      "export const selectUsersState = createFeatureSelector<UsersState>('users');\n\n" +
      "// Property selectors\n" +
      "export const selectAllUsers = createSelector(\n" +
      "  selectUsersState,\n" +
      "  state => state.users\n" +
      ");\n\n" +
      "export const selectLoading = createSelector(\n" +
      "  selectUsersState,\n" +
      "  state => state.loading\n" +
      ");\n\n" +
      "export const selectError = createSelector(\n" +
      "  selectUsersState,\n" +
      "  state => state.error\n" +
      ");\n" +
      "```\n\n" +
      "**Composed Selectors (Memoized):**\n\n" +
      "```typescript\n" +
      "// Derive data from other selectors\n" +
      "export const selectActiveUsers = createSelector(\n" +
      "  selectAllUsers,\n" +
      "  users => users.filter(u => u.active)\n" +
      ");\n\n" +
      "export const selectUserCount = createSelector(\n" +
      "  selectAllUsers,\n" +
      "  users => users.length\n" +
      ");\n\n" +
      "export const selectActiveUserCount = createSelector(\n" +
      "  selectActiveUsers,\n" +
      "  activeUsers => activeUsers.length\n" +
      ");\n\n" +
      "// Multi-selector composition\n" +
      "export const selectUserStats = createSelector(\n" +
      "  selectUserCount,\n" +
      "  selectActiveUserCount,\n" +
      "  (total, active) => ({\n" +
      "    total,\n" +
      "    active,\n" +
      "    inactive: total - active\n" +
      "  })\n" +
      ");\n" +
      "```\n\n" +
      "**Selectors with Parameters:**\n\n" +
      "```typescript\n" +
      "// Select user by ID\n" +
      "export const selectUserById = (id: number) => createSelector(\n" +
      "  selectAllUsers,\n" +
      "  users => users.find(u => u.id === id)\n" +
      ");\n\n" +
      "// Usage in component\n" +
      "user$ = this.store.select(selectUserById(5));\n\n" +
      "// Or dynamically\n" +
      "this.route.params.pipe(\n" +
      "  switchMap(params => this.store.select(selectUserById(+params.id)))\n" +
      ").subscribe(user => this.user = user);\n" +
      "```\n\n" +
      "**Memoization (Performance):**\n\n" +
      "```typescript\n" +
      "// Selector only recalculates if input changes\n" +
      "export const selectExpensiveComputation = createSelector(\n" +
      "  selectAllUsers,\n" +
      "  users => {\n" +
      "    console.log('Computing...'); // Only runs when users change\n" +
      "    return users.map(u => expensiveTransform(u));\n" +
      "  }\n" +
      ");\n\n" +
      "// Multiple subscriptions share same computation\n" +
      "this.data1$ = this.store.select(selectExpensiveComputation);\n" +
      "this.data2$ = this.store.select(selectExpensiveComputation);\n" +
      "// Computation runs ONCE, both get same result\n" +
      "```",
    category: "NgRx Selectors",
    difficulty: "hard",
    tags: ["ngrx", "selectors", "memoization", "performance"],
  },
  {
    id: 86,
    question:
      "How do you implement Authentication with NgRx? Show complete auth flow with JWT, guards, and interceptors.",
    answer:
      "**Complete NgRx Auth Implementation:**\n\n" +
      "**1. Auth State:**\n\n" +
      "```typescript\n" +
      "// auth.state.ts\n" +
      "export interface AuthState {\n" +
      "  user: User | null;\n" +
      "  token: string | null;\n" +
      "  loading: boolean;\n" +
      "  error: string | null;\n" +
      "}\n" +
      "```\n\n" +
      "**2. Auth Actions:**\n\n" +
      "```typescript\n" +
      "// auth.actions.ts\n" +
      "export const AuthActions = createActionGroup({\n" +
      "  source: 'Auth',\n" +
      "  events: {\n" +
      "    Login: props<{ email: string; password: string }>(),\n" +
      "    'Login Success': props<{ user: User; token: string }>(),\n" +
      "    'Login Failure': props<{ error: string }>(),\n" +
      "    Logout: emptyProps(),\n" +
      "    'Check Auth': emptyProps()\n" +
      "  }\n" +
      "});\n" +
      "```\n\n" +
      "**3. Auth Reducer:**\n\n" +
      "```typescript\n" +
      "// auth.reducer.ts\n" +
      "export const authReducer = createReducer(\n" +
      "  initialState,\n" +
      "  on(AuthActions.login, state => ({\n" +
      "    ...state,\n" +
      "    loading: true,\n" +
      "    error: null\n" +
      "  })),\n" +
      "  on(AuthActions.loginSuccess, (state, { user, token }) => ({\n" +
      "    ...state,\n" +
      "    user,\n" +
      "    token,\n" +
      "    loading: false,\n" +
      "    error: null\n" +
      "  })),\n" +
      "  on(AuthActions.logout, () => initialState)\n" +
      ");\n" +
      "```\n\n" +
      "**4. Auth Effects:**\n\n" +
      "```typescript\n" +
      "// auth.effects.ts\n" +
      "@Injectable()\n" +
      "export class AuthEffects {\n" +
      "  login$ = createEffect(() =>\n" +
      "    this.actions$.pipe(\n" +
      "      ofType(AuthActions.login),\n" +
      "      switchMap(({ email, password }) =>\n" +
      "        this.http.post<{ user: User; token: string }>('/api/login', { email, password }).pipe(\n" +
      "          map(response => AuthActions.loginSuccess(response)),\n" +
      "          catchError(error => of(AuthActions.loginFailure({ error: error.message })))\n" +
      "        )\n" +
      "      )\n" +
      "    )\n" +
      "  );\n\n" +
      "  // Save token to localStorage\n" +
      "  saveToken$ = createEffect(\n" +
      "    () =>\n" +
      "      this.actions$.pipe(\n" +
      "        ofType(AuthActions.loginSuccess),\n" +
      "        tap(({ token }) => localStorage.setItem('token', token))\n" +
      "      ),\n" +
      "    { dispatch: false }\n" +
      "  );\n\n" +
      "  // Navigate after login\n" +
      "  navigateAfterLogin$ = createEffect(\n" +
      "    () =>\n" +
      "      this.actions$.pipe(\n" +
      "        ofType(AuthActions.loginSuccess),\n" +
      "        tap(() => this.router.navigate(['/dashboard']))\n" +
      "      ),\n" +
      "    { dispatch: false }\n" +
      "  );\n\n" +
      "  // Clear token on logout\n" +
      "  logout$ = createEffect(\n" +
      "    () =>\n" +
      "      this.actions$.pipe(\n" +
      "        ofType(AuthActions.logout),\n" +
      "        tap(() => {\n" +
      "          localStorage.removeItem('token');\n" +
      "          this.router.navigate(['/login']);\n" +
      "        })\n" +
      "      ),\n" +
      "    { dispatch: false }\n" +
      "  );\n\n" +
      "  constructor(\n" +
      "    private actions$: Actions,\n" +
      "    private http: HttpClient,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "}\n" +
      "```\n\n" +
      "**5. Auth Selectors:**\n\n" +
      "```typescript\n" +
      "// auth.selectors.ts\n" +
      "export const selectAuthState = createFeatureSelector<AuthState>('auth');\n\n" +
      "export const selectUser = createSelector(\n" +
      "  selectAuthState,\n" +
      "  state => state.user\n" +
      ");\n\n" +
      "export const selectToken = createSelector(\n" +
      "  selectAuthState,\n" +
      "  state => state.token\n" +
      ");\n\n" +
      "export const selectIsAuthenticated = createSelector(\n" +
      "  selectUser,\n" +
      "  user => !!user\n" +
      ");\n\n" +
      "export const selectIsAdmin = createSelector(\n" +
      "  selectUser,\n" +
      "  user => user?.role === 'admin'\n" +
      ");\n" +
      "```\n\n" +
      "**6. Auth Guard:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class AuthGuard implements CanActivate {\n" +
      "  constructor(private store: Store, private router: Router) {}\n\n" +
      "  canActivate(): Observable<boolean> {\n" +
      "    return this.store.select(selectIsAuthenticated).pipe(\n" +
      "      take(1),\n" +
      "      map(isAuth => {\n" +
      "        if (!isAuth) {\n" +
      "          this.router.navigate(['/login']);\n" +
      "          return false;\n" +
      "        }\n" +
      "        return true;\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**7. Auth Interceptor:**\n\n" +
      "```typescript\n" +
      "export const authInterceptor: HttpInterceptorFn = (req, next) => {\n" +
      "  const store = inject(Store);\n" +
      "  let token: string | null = null;\n\n" +
      "  store.select(selectToken).pipe(take(1)).subscribe(t => token = t);\n\n" +
      "  if (token) {\n" +
      "    req = req.clone({\n" +
      "      setHeaders: { Authorization: `Bearer ${token}` }\n" +
      "    });\n" +
      "  }\n\n" +
      "  return next(req);\n" +
      "};\n" +
      "```",
    category: "NgRx Authentication",
    difficulty: "hard",
    tags: ["ngrx", "authentication", "jwt", "guards", "interceptors"],
  },
  {
    id: 87,
    question: "What is NgRx Entity? Explain EntityAdapter and how it simplifies entity management.",
    answer:
      "NgRx Entity provides utilities for managing entity collections.\n\n" +
      "**Setup with Entity:**\n\n" +
      "```typescript\n" +
      "import { createEntityAdapter, EntityAdapter, EntityState } from '@ngrx/entity';\n\n" +
      "export interface User {\n" +
      "  id: number;\n" +
      "  name: string;\n" +
      "  email: string;\n" +
      "}\n\n" +
      "// Entity state includes: ids[], entities{}\n" +
      "export interface UsersState extends EntityState<User> {\n" +
      "  selectedUserId: number | null;\n" +
      "  loading: boolean;\n" +
      "  error: string | null;\n" +
      "}\n\n" +
      "// Create adapter\n" +
      "export const usersAdapter: EntityAdapter<User> = createEntityAdapter<User>({\n" +
      "  selectId: (user: User) => user.id, // Default: entity.id\n" +
      "  sortComparer: (a, b) => a.name.localeCompare(b.name) // Optional sorting\n" +
      "});\n\n" +
      "// Initial state\n" +
      "export const initialState: UsersState = usersAdapter.getInitialState({\n" +
      "  selectedUserId: null,\n" +
      "  loading: false,\n" +
      "  error: null\n" +
      "});\n" +
      "```\n\n" +
      "**Reducer with Entity Methods:**\n\n" +
      "```typescript\n" +
      "export const usersReducer = createReducer(\n" +
      "  initialState,\n" +
      "  // Load all users\n" +
      "  on(UsersActions.loadUsersSuccess, (state, { users }) =>\n" +
      "    usersAdapter.setAll(users, { ...state, loading: false })\n" +
      "  ),\n" +
      "  // Add one\n" +
      "  on(UsersActions.addUserSuccess, (state, { user }) =>\n" +
      "    usersAdapter.addOne(user, state)\n" +
      "  ),\n" +
      "  // Add many\n" +
      "  on(UsersActions.addUsersSuccess, (state, { users }) =>\n" +
      "    usersAdapter.addMany(users, state)\n" +
      "  ),\n" +
      "  // Update one\n" +
      "  on(UsersActions.updateUserSuccess, (state, { user }) =>\n" +
      "    usersAdapter.updateOne({ id: user.id, changes: user }, state)\n" +
      "  ),\n" +
      "  // Update many\n" +
      "  on(UsersActions.updateUsersSuccess, (state, { users }) =>\n" +
      "    usersAdapter.updateMany(\n" +
      "      users.map(u => ({ id: u.id, changes: u })),\n" +
      "      state\n" +
      "    )\n" +
      "  ),\n" +
      "  // Upsert (update if exists, add if not)\n" +
      "  on(UsersActions.upsertUser, (state, { user }) =>\n" +
      "    usersAdapter.upsertOne(user, state)\n" +
      "  ),\n" +
      "  // Delete one\n" +
      "  on(UsersActions.deleteUserSuccess, (state, { id }) =>\n" +
      "    usersAdapter.removeOne(id, state)\n" +
      "  ),\n" +
      "  // Delete many\n" +
      "  on(UsersActions.deleteUsersSuccess, (state, { ids }) =>\n" +
      "    usersAdapter.removeMany(ids, state)\n" +
      "  ),\n" +
      "  // Clear all\n" +
      "  on(UsersActions.clearUsers, state =>\n" +
      "    usersAdapter.removeAll({ ...state, selectedUserId: null })\n" +
      "  )\n" +
      ");\n" +
      "```\n\n" +
      "**Entity Selectors:**\n\n" +
      "```typescript\n" +
      "// Get entity selectors from adapter\n" +
      "const { selectIds, selectEntities, selectAll, selectTotal } = usersAdapter.getSelectors();\n\n" +
      "export const selectUsersState = createFeatureSelector<UsersState>('users');\n\n" +
      "// Apply selectors to feature state\n" +
      "export const selectAllUsers = createSelector(selectUsersState, selectAll);\n" +
      "export const selectUserEntities = createSelector(selectUsersState, selectEntities);\n" +
      "export const selectUserIds = createSelector(selectUsersState, selectIds);\n" +
      "export const selectUserTotal = createSelector(selectUsersState, selectTotal);\n\n" +
      "// Custom selector\n" +
      "export const selectUserById = (id: number) => createSelector(\n" +
      "  selectUserEntities,\n" +
      "  entities => entities[id]\n" +
      ");\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "- Less boilerplate\n" +
      "- Built-in CRUD operations\n" +
      "- Optimized performance\n" +
      "- Normalized state structure",
    category: "NgRx Entity",
    difficulty: "hard",
    tags: ["ngrx", "entity", "entity-adapter", "crud", "normalization"],
  },
  {
    id: 88,
    question: "What are NgRx DevTools? Explain Time-Travelling Debugger and how to use it.",
    answer:
      "NgRx DevTools provide powerful debugging capabilities.\n\n" +
      "**Setup:**\n\n" +
      "```bash\n" +
      "npm install @ngrx/store-devtools\n" +
      "```\n\n" +
      "**Configuration:**\n\n" +
      "```typescript\n" +
      "import { provideStoreDevtools } from '@ngrx/store-devtools';\n\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideStore({ users: usersReducer }),\n" +
      "    provideStoreDevtools({\n" +
      "      maxAge: 25, // Retain last 25 states\n" +
      "      logOnly: environment.production, // Restrict in prod\n" +
      "      autoPause: true, // Pause when window loses focus\n" +
      "      trace: true, // Include stack trace\n" +
      "      traceLimit: 75 // Max stack trace frames\n" +
      "    })\n" +
      "  ]\n" +
      "});\n" +
      "```\n\n" +
      "**Time-Travelling Debugger Features:**\n\n" +
      "```typescript\n" +
      "// Chrome DevTools → Redux tab\n\n" +
      "1. **Action History**\n" +
      "   - See all dispatched actions\n" +
      "   - View action payloads\n" +
      "   - Jump to any action\n\n" +
      "2. **State Inspection**\n" +
      "   - View current state\n" +
      "   - See state at any point in time\n" +
      "   - Diff between states\n\n" +
      "3. **Time Travel**\n" +
      "   - Jump to previous state\n" +
      "   - Skip actions\n" +
      "   - Replay actions\n\n" +
      "4. **Export/Import**\n" +
      "   - Export state snapshot\n" +
      "   - Import saved state\n" +
      "   - Share debugging scenarios\n\n" +
      "5. **Action Filtering**\n" +
      "   - Filter by action type\n" +
      "   - Search actions\n" +
      "   - Ignore specific actions\n" +
      "```\n\n" +
      "**Custom Action Sanitization:**\n\n" +
      "```typescript\n" +
      "provideStoreDevtools({\n" +
      "  actionSanitizer: (action, id) => {\n" +
      "    // Hide sensitive data\n" +
      "    if (action.type === '[Auth] Login') {\n" +
      "      return {\n" +
      "        ...action,\n" +
      "        password: '***HIDDEN***'\n" +
      "      };\n" +
      "    }\n" +
      "    return action;\n" +
      "  },\n" +
      "  stateSanitizer: (state, index) => {\n" +
      "    // Hide sensitive state\n" +
      "    return {\n" +
      "      ...state,\n" +
      "      auth: {\n" +
      "        ...state.auth,\n" +
      "        token: state.auth.token ? '***TOKEN***' : null\n" +
      "      }\n" +
      "    };\n" +
      "  }\n" +
      "})\n" +
      "```\n\n" +
      "**Debugging Workflow:**\n\n" +
      "```typescript\n" +
      "1. Open Redux DevTools in Chrome\n" +
      "2. Dispatch actions in your app\n" +
      "3. See actions appear in timeline\n" +
      "4. Click action to see:\n" +
      "   - Action payload\n" +
      "   - State before\n" +
      "   - State after\n" +
      "   - Diff\n" +
      "5. Use slider to time-travel through states\n" +
      "6. Export state to reproduce bugs\n" +
      "```",
    category: "NgRx DevTools",
    difficulty: "intermediate",
    tags: ["ngrx", "devtools", "debugging", "time-travel"],
  },
  {
    id: 89,
    question:
      "What are NgRx Runtime Checks? Explain store immutability, action serializability, and strict action checks.",
    answer:
      "Runtime checks enforce NgRx best practices during development.\n\n" +
      "**Enable Runtime Checks:**\n\n" +
      "```typescript\n" +
      "import { provideStore } from '@ngrx/store';\n\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideStore(\n" +
      "      { users: usersReducer },\n" +
      "      {\n" +
      "        runtimeChecks: {\n" +
      "          strictStateImmutability: true,\n" +
      "          strictActionImmutability: true,\n" +
      "          strictStateSerializability: true,\n" +
      "          strictActionSerializability: true,\n" +
      "          strictActionWithinNgZone: true,\n" +
      "          strictActionTypeUniqueness: true\n" +
      "        }\n" +
      "      }\n" +
      "    )\n" +
      "  ]\n" +
      "});\n" +
      "```\n\n" +
      "**1. State Immutability Check:**\n\n" +
      "```typescript\n" +
      "// ❌ BAD - Mutation detected!\n" +
      "on(updateUser, (state, { user }) => {\n" +
      "  state.users.push(user); // ERROR: Mutating state!\n" +
      "  return state;\n" +
      "})\n\n" +
      "// ✅ GOOD - Immutable update\n" +
      "on(updateUser, (state, { user }) => ({\n" +
      "  ...state,\n" +
      "  users: [...state.users, user]\n" +
      "}))\n" +
      "```\n\n" +
      "**2. Action Immutability Check:**\n\n" +
      "```typescript\n" +
      "// ❌ BAD - Modifying action\n" +
      "myEffect$ = createEffect(() =>\n" +
      "  this.actions$.pipe(\n" +
      "    ofType(someAction),\n" +
      "    tap(action => {\n" +
      "      action.timestamp = Date.now(); // ERROR: Mutating action!\n" +
      "    })\n" +
      "  )\n" +
      ");\n\n" +
      "// ✅ GOOD - Create new action\n" +
      "myEffect$ = createEffect(() =>\n" +
      "  this.actions$.pipe(\n" +
      "    ofType(someAction),\n" +
      "    map(action => newAction({ ...action.payload, timestamp: Date.now() }))\n" +
      "  )\n" +
      ");\n" +
      "```\n\n" +
      "**3. Serializability Check:**\n\n" +
      "```typescript\n" +
      "// ❌ BAD - Non-serializable in state\n" +
      "export interface AppState {\n" +
      "  date: Date; // ERROR: Dates not serializable\n" +
      "  callback: Function; // ERROR: Functions not serializable\n" +
      "  component: ComponentRef; // ERROR: Complex objects\n" +
      "}\n\n" +
      "// ✅ GOOD - Serializable types only\n" +
      "export interface AppState {\n" +
      "  dateString: string; // Use ISO string\n" +
      "  userId: number; // Primitive types\n" +
      "  settings: { theme: string }; // Plain objects\n" +
      "}\n" +
      "```\n\n" +
      "**4. Action Type Uniqueness:**\n\n" +
      "```typescript\n" +
      "// ❌ BAD - Duplicate action types\n" +
      "export const load = createAction('[Users] Load');\n" +
      "export const load2 = createAction('[Users] Load'); // ERROR: Duplicate!\n\n" +
      "// ✅ GOOD - Unique types\n" +
      "export const loadUsers = createAction('[Users Page] Load');\n" +
      "export const loadUsersFromCache = createAction('[Users Cache] Load');\n" +
      "```\n\n" +
      "**Disable Checks in Production:**\n\n" +
      "```typescript\n" +
      "provideStore(\n" +
      "  reducers,\n" +
      "  {\n" +
      "    runtimeChecks: {\n" +
      "      strictStateImmutability: !environment.production,\n" +
      "      strictActionImmutability: !environment.production\n" +
      "    }\n" +
      "  }\n" +
      ")\n" +
      "```",
    category: "NgRx Runtime Checks",
    difficulty: "hard",
    tags: ["ngrx", "runtime-checks", "immutability", "serializability"],
  },
  {
    id: 90,
    question: "What is NgRx Router Store? How do you connect routing to NgRx state?",
    answer:
      "Router Store syncs Angular Router state with NgRx Store.\n\n" +
      "**Setup:**\n\n" +
      "```bash\n" +
      "npm install @ngrx/router-store\n" +
      "```\n\n" +
      "**Configuration:**\n\n" +
      "```typescript\n" +
      "import { provideRouterStore, routerReducer } from '@ngrx/router-store';\n\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideStore({\n" +
      "      router: routerReducer // Add router reducer\n" +
      "    }),\n" +
      "    provideRouterStore() // Connect router to store\n" +
      "  ]\n" +
      "});\n" +
      "```\n\n" +
      "**Custom Router State Serializer:**\n\n" +
      "```typescript\n" +
      "import { RouterStateSerializer } from '@ngrx/router-store';\n" +
      "import { RouterStateSnapshot } from '@angular/router';\n\n" +
      "export interface RouterStateUrl {\n" +
      "  url: string;\n" +
      "  params: any;\n" +
      "  queryParams: any;\n" +
      "}\n\n" +
      "export class CustomRouterStateSerializer\n" +
      "  implements RouterStateSerializer<RouterStateUrl> {\n" +
      "  \n" +
      "  serialize(routerState: RouterStateSnapshot): RouterStateUrl {\n" +
      "    let route = routerState.root;\n\n" +
      "    while (route.firstChild) {\n" +
      "      route = route.firstChild;\n" +
      "    }\n\n" +
      "    const { url } = routerState;\n" +
      "    const { queryParams } = routerState.root;\n" +
      "    const { params } = route;\n\n" +
      "    return { url, params, queryParams };\n" +
      "  }\n" +
      "}\n\n" +
      "// Register\n" +
      "providers: [\n" +
      "  provideRouterStore({\n" +
      "    serializer: CustomRouterStateSerializer\n" +
      "  })\n" +
      "]\n" +
      "```\n\n" +
      "**Router Selectors:**\n\n" +
      "```typescript\n" +
      "import { getRouterSelectors } from '@ngrx/router-store';\n\n" +
      "export const {\n" +
      "  selectCurrentRoute,\n" +
      "  selectQueryParams,\n" +
      "  selectQueryParam,\n" +
      "  selectRouteParams,\n" +
      "  selectRouteParam,\n" +
      "  selectRouteData,\n" +
      "  selectUrl\n" +
      "} = getRouterSelectors();\n\n" +
      "// Usage in component\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  url$ = this.store.select(selectUrl);\n" +
      "  userId$ = this.store.select(selectRouteParam('id'));\n" +
      "  searchQuery$ = this.store.select(selectQueryParam('q'));\n" +
      "}\n" +
      "```\n\n" +
      "**Navigate from Effect:**\n\n" +
      "```typescript\n" +
      "import { ROUTER_NAVIGATION } from '@ngrx/router-store';\n\n" +
      "@Injectable()\n" +
      "export class RouterEffects {\n" +
      "  // Listen to navigation\n" +
      "  logNavigation$ = createEffect(\n" +
      "    () =>\n" +
      "      this.actions$.pipe(\n" +
      "        ofType(ROUTER_NAVIGATION),\n" +
      "        tap(action => console.log('Navigated to:', action.payload.routerState.url))\n" +
      "      ),\n" +
      "    { dispatch: false }\n" +
      "  );\n\n" +
      "  // Navigate on action\n" +
      "  navigateToUser$ = createEffect(\n" +
      "    () =>\n" +
      "      this.actions$.pipe(\n" +
      "        ofType(UsersActions.selectUser),\n" +
      "        tap(({ userId }) => this.router.navigate(['/users', userId]))\n" +
      "      ),\n" +
      "    { dispatch: false }\n" +
      "  );\n\n" +
      "  constructor(private actions$: Actions, private router: Router) {}\n" +
      "}\n" +
      "```",
    category: "NgRx Router Store",
    difficulty: "hard",
    tags: ["ngrx", "router-store", "routing", "navigation"],
  },
  {
    id: 91,
    question: "What is NgRx ComponentStore? How does it differ from global Store?",
    answer:
      "ComponentStore manages local component state with NgRx patterns.\n\n" +
      "**When to Use:**\n" +
      "- Local component state (not global)\n" +
      "- Temporary UI state\n" +
      "- Form state\n" +
      "- Component-specific data\n\n" +
      "**Setup:**\n\n" +
      "```bash\n" +
      "npm install @ngrx/component-store\n" +
      "```\n\n" +
      "**Create Component Store:**\n\n" +
      "```typescript\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { ComponentStore } from '@ngrx/component-store';\n\n" +
      "interface UsersState {\n" +
      "  users: User[];\n" +
      "  loading: boolean;\n" +
      "  filter: string;\n" +
      "}\n\n" +
      "@Injectable()\n" +
      "export class UsersComponentStore extends ComponentStore<UsersState> {\n" +
      "  constructor(private http: HttpClient) {\n" +
      "    super({ users: [], loading: false, filter: '' });\n" +
      "  }\n\n" +
      "  // Selectors\n" +
      "  readonly users$ = this.select(state => state.users);\n" +
      "  readonly loading$ = this.select(state => state.loading);\n" +
      "  readonly filter$ = this.select(state => state.filter);\n\n" +
      "  // Composed selector\n" +
      "  readonly filteredUsers$ = this.select(\n" +
      "    this.users$,\n" +
      "    this.filter$,\n" +
      "    (users, filter) => users.filter(u => u.name.includes(filter))\n" +
      "  );\n\n" +
      "  // Updaters (sync state updates)\n" +
      "  readonly setLoading = this.updater((state, loading: boolean) => ({\n" +
      "    ...state,\n" +
      "    loading\n" +
      "  }));\n\n" +
      "  readonly setFilter = this.updater((state, filter: string) => ({\n" +
      "    ...state,\n" +
      "    filter\n" +
      "  }));\n\n" +
      "  readonly addUser = this.updater((state, user: User) => ({\n" +
      "    ...state,\n" +
      "    users: [...state.users, user]\n" +
      "  }));\n\n" +
      "  // Effects (async operations)\n" +
      "  readonly loadUsers = this.effect((trigger$: Observable<void>) =>\n" +
      "    trigger$.pipe(\n" +
      "      tap(() => this.setLoading(true)),\n" +
      "      switchMap(() =>\n" +
      "        this.http.get<User[]>('/api/users').pipe(\n" +
      "          tapResponse(\n" +
      "            users => this.patchState({ users, loading: false }),\n" +
      "            error => this.patchState({ loading: false })\n" +
      "          )\n" +
      "        )\n" +
      "      )\n" +
      "    )\n" +
      "  );\n" +
      "}\n" +
      "```\n\n" +
      "**Use in Component:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  providers: [UsersComponentStore], // Scoped to component\n" +
      "  template: `\n" +
      '    <input (input)="store.setFilter($event.target.value)" />\n\n' +
      "    @if (store.loading$ | async) {\n" +
      "      <p>Loading...</p>\n" +
      "    }\n\n" +
      "    @for (user of store.filteredUsers$ | async; track user.id) {\n" +
      "      <div>{{ user.name }}</div>\n" +
      "    }\n" +
      "  `\n" +
      "})\n" +
      "export class UsersComponent implements OnInit {\n" +
      "  constructor(public store: UsersComponentStore) {}\n\n" +
      "  ngOnInit() {\n" +
      "    this.store.loadUsers(); // Trigger effect\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**ComponentStore vs Global Store:**\n\n" +
      "| Feature | ComponentStore | Global Store |\n" +
      "|---------|----------------|-------------|\n" +
      "| Scope | Component | Application |\n" +
      "| Lifecycle | Component lifetime | App lifetime |\n" +
      "| Boilerplate | Less | More (actions, reducers) |\n" +
      "| DevTools | Limited | Full support |\n" +
      "| Use Case | Local UI state | Shared state |",
    category: "NgRx ComponentStore",
    difficulty: "hard",
    tags: ["ngrx", "component-store", "local-state", "scoped-state"],
  },
  {
    id: 92,
    question:
      "What are NgRx Best Practices? Explain folder structure, naming conventions, and patterns.",
    answer:
      "**Folder Structure:**\n\n" +
      "```typescript\n" +
      "src/app/\n" +
      "├── state/\n" +
      "│   ├── index.ts              // Root state, reducers\n" +
      "│   ├── users/\n" +
      "│   │   ├── users.actions.ts\n" +
      "│   │   ├── users.reducer.ts\n" +
      "│   │   ├── users.effects.ts\n" +
      "│   │   ├── users.selectors.ts\n" +
      "│   │   ├── users.models.ts\n" +
      "│   │   └── index.ts          // Public API\n" +
      "│   ├── auth/\n" +
      "│   └── products/\n" +
      "```\n\n" +
      "**Naming Conventions:**\n\n" +
      "```typescript\n" +
      "// Actions: [Source] Event\n" +
      "[Users Page] Load Users\n" +
      "[Users API] Load Users Success\n" +
      "[Users API] Load Users Failure\n" +
      "[Users Page] Search Users\n" +
      "[Users Page] Select User\n\n" +
      "// Selectors: select + Feature + Property\n" +
      "selectUsersState\n" +
      "selectAllUsers\n" +
      "selectUsersLoading\n" +
      "selectUserById\n\n" +
      "// Effects: action + $\n" +
      "loadUsers$\n" +
      "createUser$\n" +
      "deleteUser$\n\n" +
      "// Reducers: feature + Reducer\n" +
      "usersReducer\n" +
      "authReducer\n" +
      "```\n\n" +
      "**Best Practices:**\n\n" +
      "```typescript\n" +
      "1. **One Feature, One Folder**\n" +
      "   - Keep related code together\n" +
      "   - Clear boundaries\n\n" +
      "2. **Use Action Groups**\n" +
      "   export const UsersActions = createActionGroup({ ... });\n\n" +
      "3. **Use Entity Adapter**\n" +
      "   - For collections (users, products)\n" +
      "   - Less boilerplate\n\n" +
      "4. **Compose Selectors**\n" +
      "   - Memoization benefits\n" +
      "   - Reusable logic\n\n" +
      "5. **Handle Errors in Effects**\n" +
      "   loadUsers$ = createEffect(() =>\n" +
      "     this.actions$.pipe(\n" +
      "       ofType(load),\n" +
      "       switchMap(() =>\n" +
      "         this.http.get('/api').pipe(\n" +
      "           map(success),\n" +
      "           catchError(err => of(failure({ err }))) // Always catch!\n" +
      "         )\n" +
      "       )\n" +
      "     )\n" +
      "   );\n\n" +
      "6. **Avoid Nested State**\n" +
      "   // ❌ Bad\n" +
      "   { users: { data: { items: [] } } }\n" +
      "   \n" +
      "   // ✅ Good (flat)\n" +
      "   { users: [] }\n\n" +
      "7. **Use Strongly-Typed Actions**\n" +
      "   props<{ userId: number }>()\n\n" +
      "8. **Loading/Error Pattern**\n" +
      "   interface FeatureState {\n" +
      "     data: Data[];\n" +
      "     loading: boolean;\n" +
      "     error: string | null;\n" +
      "   }\n\n" +
      "9. **Don't Put Everything in Store**\n" +
      "   - Only shared state\n" +
      "   - Not form state (unless shared)\n" +
      "   - Not transient UI state\n\n" +
      "10. **Use Effects for Side Effects**\n" +
      "    - HTTP calls\n" +
      "    - localStorage\n" +
      "    - Navigation\n" +
      "    - Logging\n" +
      "```\n\n" +
      "**Anti-Patterns to Avoid:**\n\n" +
      "```typescript\n" +
      "// ❌ Dispatching in Reducer\n" +
      "on(someAction, state => {\n" +
      "  this.store.dispatch(anotherAction()); // NO!\n" +
      "  return state;\n" +
      "})\n\n" +
      "// ❌ Side Effects in Reducer\n" +
      "on(saveUser, state => {\n" +
      "  localStorage.setItem('user', state.user); // NO!\n" +
      "  return state;\n" +
      "})\n\n" +
      "// ❌ Async in Reducer\n" +
      "on(loadUser, state => {\n" +
      "  this.http.get('/api/user').subscribe(); // NO!\n" +
      "  return state;\n" +
      "})\n" +
      "```",
    category: "NgRx Best Practices",
    difficulty: "hard",
    tags: ["ngrx", "best-practices", "patterns", "architecture"],
  },
  {
    id: 93,
    question: "What is NgRx Data (Entity Data Service)? How does it simplify CRUD operations?",
    answer:
      "NgRx Data automates entity CRUD operations without writing actions/reducers/effects.\n\n" +
      "**Setup:**\n\n" +
      "```bash\n" +
      "npm install @ngrx/data\n" +
      "```\n\n" +
      "**Define Entity Metadata:**\n\n" +
      "```typescript\n" +
      "import { EntityMetadataMap } from '@ngrx/data';\n\n" +
      "const entityMetadata: EntityMetadataMap = {\n" +
      "  User: {\n" +
      "    sortComparer: (a, b) => a.name.localeCompare(b.name)\n" +
      "  },\n" +
      "  Product: {},\n" +
      "  Order: {}\n" +
      "};\n\n" +
      "export const entityConfig = {\n" +
      "  entityMetadata\n" +
      "};\n" +
      "```\n\n" +
      "**Register:**\n\n" +
      "```typescript\n" +
      "import { provideEntityData, withEffects } from '@ngrx/data';\n\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideStore(),\n" +
      "    provideEffects(),\n" +
      "    provideEntityData(entityConfig, withEffects())\n" +
      "  ]\n" +
      "});\n" +
      "```\n\n" +
      "**Create Entity Service:**\n\n" +
      "```typescript\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { EntityCollectionServiceBase, EntityCollectionServiceElementsFactory } from '@ngrx/data';\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class UserService extends EntityCollectionServiceBase<User> {\n" +
      "  constructor(serviceElementsFactory: EntityCollectionServiceElementsFactory) {\n" +
      "    super('User', serviceElementsFactory);\n" +
      "  }\n\n" +
      "  // Automatic methods available:\n" +
      "  // - getAll()\n" +
      "  // - getByKey(id)\n" +
      "  // - add(user)\n" +
      "  // - update(user)\n" +
      "  // - delete(id)\n" +
      "  // - upsert(user)\n" +
      "}\n" +
      "```\n\n" +
      "**Use in Component:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class UsersComponent implements OnInit {\n" +
      "  users$ = this.userService.entities$;\n" +
      "  loading$ = this.userService.loading$;\n\n" +
      "  constructor(private userService: UserService) {}\n\n" +
      "  ngOnInit() {\n" +
      "    this.userService.getAll(); // Auto HTTP GET /api/users\n" +
      "  }\n\n" +
      "  addUser(user: User) {\n" +
      "    this.userService.add(user); // Auto HTTP POST /api/users\n" +
      "  }\n\n" +
      "  updateUser(user: User) {\n" +
      "    this.userService.update(user); // Auto HTTP PUT /api/users/:id\n" +
      "  }\n\n" +
      "  deleteUser(id: number) {\n" +
      "    this.userService.delete(id); // Auto HTTP DELETE /api/users/:id\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Custom Data Service:**\n\n" +
      "```typescript\n" +
      "import { DefaultDataService, HttpUrlGenerator } from '@ngrx/data';\n\n" +
      "@Injectable()\n" +
      "export class CustomUserDataService extends DefaultDataService<User> {\n" +
      "  constructor(http: HttpClient, httpUrlGenerator: HttpUrlGenerator) {\n" +
      "    super('User', http, httpUrlGenerator);\n" +
      "  }\n\n" +
      "  // Override getAll to use different endpoint\n" +
      "  override getAll(): Observable<User[]> {\n" +
      "    return this.http.get<User[]>('/custom/api/users');\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Benefits:**\n" +
      "- No actions/reducers/effects boilerplate\n" +
      "- Automatic CRUD operations\n" +
      "- Optimistic updates\n" +
      "- Cache management\n" +
      "- Perfect for standard REST APIs",
    category: "NgRx Data",
    difficulty: "hard",
    tags: ["ngrx", "ngrx-data", "entity-services", "crud", "automation"],
  },
  {
    id: 94,
    question: "What are Meta-Reducers in NgRx? Provide logging and undo/redo examples.",
    answer:
      "Meta-reducers intercept actions before they reach regular reducers.\n\n" +
      "**Logging Meta-Reducer:**\n\n" +
      "```typescript\n" +
      "import { ActionReducer, MetaReducer } from '@ngrx/store';\n\n" +
      "export function logger(reducer: ActionReducer<unknown>): ActionReducer<unknown> {\n" +
      "  return (state, action) => {\n" +
      "    console.log('State before:', state);\n" +
      "    console.log('Action:', action);\n\n" +
      "    const nextState = reducer(state, action);\n\n" +
      "    console.log('State after:', nextState);\n" +
      "    return nextState;\n" +
      "  };\n" +
      "}\n\n" +
      "// Register\n" +
      "export const metaReducers: MetaReducer<AppState>[] = [\n" +
      "  logger\n" +
      "];\n\n" +
      "provideStore(\n" +
      "  reducers,\n" +
      "  { metaReducers }\n" +
      ");\n" +
      "```\n\n" +
      "**LocalStorage Sync Meta-Reducer:**\n\n" +
      "```typescript\n" +
      "export function localStorageSync(reducer: ActionReducer<AppState>): ActionReducer<AppState> {\n" +
      "  return (state, action) => {\n" +
      "    // Run reducer\n" +
      "    const nextState = reducer(state, action);\n\n" +
      "    // Save to localStorage\n" +
      "    if (action.type !== '@ngrx/store/init') {\n" +
      "      localStorage.setItem('appState', JSON.stringify(nextState));\n" +
      "    }\n\n" +
      "    return nextState;\n" +
      "  };\n" +
      "}\n\n" +
      "// Load from localStorage on init\n" +
      "export function getInitialState(): AppState {\n" +
      "  const saved = localStorage.getItem('appState');\n" +
      "  return saved ? JSON.parse(saved) : undefined;\n" +
      "}\n\n" +
      "provideStore(\n" +
      "  reducers,\n" +
      "  {\n" +
      "    metaReducers: [localStorageSync],\n" +
      "    initialState: getInitialState()\n" +
      "  }\n" +
      ");\n" +
      "```\n\n" +
      "**Undo/Redo Meta-Reducer:**\n\n" +
      "```typescript\n" +
      "interface UndoableState<T> {\n" +
      "  past: T[];\n" +
      "  present: T;\n" +
      "  future: T[];\n" +
      "}\n\n" +
      "export function undoable<T>(reducer: ActionReducer<T>): ActionReducer<UndoableState<T>> {\n" +
      "  const initialState: UndoableState<T> = {\n" +
      "    past: [],\n" +
      "    present: reducer(undefined, { type: '@ngrx/store/init' }),\n" +
      "    future: []\n" +
      "  };\n\n" +
      "  return (state = initialState, action) => {\n" +
      "    const { past, present, future } = state;\n\n" +
      "    switch (action.type) {\n" +
      "      case 'UNDO':\n" +
      "        if (past.length === 0) return state;\n" +
      "        return {\n" +
      "          past: past.slice(0, past.length - 1),\n" +
      "          present: past[past.length - 1],\n" +
      "          future: [present, ...future]\n" +
      "        };\n\n" +
      "      case 'REDO':\n" +
      "        if (future.length === 0) return state;\n" +
      "        return {\n" +
      "          past: [...past, present],\n" +
      "          present: future[0],\n" +
      "          future: future.slice(1)\n" +
      "        };\n\n" +
      "      default:\n" +
      "        const nextPresent = reducer(present, action);\n" +
      "        if (present === nextPresent) return state;\n\n" +
      "        return {\n" +
      "          past: [...past, present],\n" +
      "          present: nextPresent,\n" +
      "          future: []\n" +
      "        };\n" +
      "    }\n" +
      "  };\n" +
      "}\n" +
      "```",
    category: "NgRx Meta-Reducers",
    difficulty: "hard",
    tags: ["ngrx", "meta-reducers", "undo-redo", "middleware"],
  },
  {
    id: 95,
    question:
      "How do you test NgRx? Provide examples for Actions, Reducers, Effects, and Selectors.",
    answer:
      "**Testing Reducers:**\n\n" +
      "```typescript\n" +
      "import { usersReducer, initialState } from './users.reducer';\n" +
      "import { UsersActions } from './users.actions';\n\n" +
      "describe('UsersReducer', () => {\n" +
      "  it('should return initial state', () => {\n" +
      "    const state = usersReducer(undefined, { type: 'Unknown' });\n" +
      "    expect(state).toEqual(initialState);\n" +
      "  });\n\n" +
      "  it('should set loading on loadUsers', () => {\n" +
      "    const action = UsersActions.loadUsers();\n" +
      "    const state = usersReducer(initialState, action);\n\n" +
      "    expect(state.loading).toBe(true);\n" +
      "    expect(state.error).toBeNull();\n" +
      "  });\n\n" +
      "  it('should add users on loadUsersSuccess', () => {\n" +
      "    const users = [{ id: 1, name: 'John' }];\n" +
      "    const action = UsersActions.loadUsersSuccess({ users });\n" +
      "    const state = usersReducer(initialState, action);\n\n" +
      "    expect(state.users).toEqual(users);\n" +
      "    expect(state.loading).toBe(false);\n" +
      "  });\n" +
      "});\n" +
      "```\n\n" +
      "**Testing Selectors:**\n\n" +
      "```typescript\n" +
      "import { selectAllUsers, selectActiveUsers } from './users.selectors';\n\n" +
      "describe('Users Selectors', () => {\n" +
      "  const state = {\n" +
      "    users: {\n" +
      "      users: [\n" +
      "        { id: 1, name: 'John', active: true },\n" +
      "        { id: 2, name: 'Jane', active: false }\n" +
      "      ]\n" +
      "    }\n" +
      "  };\n\n" +
      "  it('should select all users', () => {\n" +
      "    const result = selectAllUsers(state);\n" +
      "    expect(result.length).toBe(2);\n" +
      "  });\n\n" +
      "  it('should select active users', () => {\n" +
      "    const result = selectActiveUsers(state);\n" +
      "    expect(result.length).toBe(1);\n" +
      "    expect(result[0].name).toBe('John');\n" +
      "  });\n" +
      "});\n" +
      "```\n\n" +
      "**Testing Effects:**\n\n" +
      "```typescript\n" +
      "import { TestBed } from '@angular/core/testing';\n" +
      "import { provideMockActions } from '@ngrx/effects/testing';\n" +
      "import { Observable, of, throwError } from 'rxjs';\n" +
      "import { UsersEffects } from './users.effects';\n\n" +
      "describe('UsersEffects', () => {\n" +
      "  let actions$: Observable<unknown>;\n" +
      "  let effects: UsersEffects;\n" +
      "  let httpMock: jasmine.SpyObj<HttpClient>;\n\n" +
      "  beforeEach(() => {\n" +
      "    httpMock = jasmine.createSpyObj('HttpClient', ['get', 'post']);\n\n" +
      "    TestBed.configureTestingModule({\n" +
      "      providers: [\n" +
      "        UsersEffects,\n" +
      "        provideMockActions(() => actions$),\n" +
      "        { provide: HttpClient, useValue: httpMock }\n" +
      "      ]\n" +
      "    });\n\n" +
      "    effects = TestBed.inject(UsersEffects);\n" +
      "  });\n\n" +
      "  it('should return loadUsersSuccess on success', (done) => {\n" +
      "    const users = [{ id: 1, name: 'John' }];\n" +
      "    httpMock.get.and.returnValue(of(users));\n\n" +
      "    actions$ = of(UsersActions.loadUsers());\n\n" +
      "    effects.loadUsers$.subscribe(action => {\n" +
      "      expect(action).toEqual(UsersActions.loadUsersSuccess({ users }));\n" +
      "      done();\n" +
      "    });\n" +
      "  });\n\n" +
      "  it('should return loadUsersFailure on error', (done) => {\n" +
      "    const error = new Error('Failed');\n" +
      "    httpMock.get.and.returnValue(throwError(() => error));\n\n" +
      "    actions$ = of(UsersActions.loadUsers());\n\n" +
      "    effects.loadUsers$.subscribe(action => {\n" +
      "      expect(action.type).toBe('[Users API] Load Users Failure');\n" +
      "      done();\n" +
      "    });\n" +
      "  });\n" +
      "});\n" +
      "```\n\n" +
      "**Testing with MockStore:**\n\n" +
      "```typescript\n" +
      "import { provideMockStore, MockStore } from '@ngrx/store/testing';\n\n" +
      "describe('UsersComponent', () => {\n" +
      "  let store: MockStore;\n" +
      "  const initialState = { users: [] };\n\n" +
      "  beforeEach(() => {\n" +
      "    TestBed.configureTestingModule({\n" +
      "      providers: [provideMockStore({ initialState })]\n" +
      "    });\n\n" +
      "    store = TestBed.inject(MockStore);\n" +
      "  });\n\n" +
      "  it('should dispatch loadUsers on init', () => {\n" +
      "    spyOn(store, 'dispatch');\n" +
      "    const component = new UsersComponent(store);\n" +
      "    component.ngOnInit();\n\n" +
      "    expect(store.dispatch).toHaveBeenCalledWith(UsersActions.loadUsers());\n" +
      "  });\n" +
      "});\n" +
      "```",
    category: "NgRx Testing",
    difficulty: "hard",
    tags: ["ngrx", "testing", "unit-tests", "jasmine"],
  },
  {
    id: 96,
    question:
      "What are Angular Signals? Explain signal(), computed(), and effect() with signal-based change detection.",
    answer:
      "Signals are Angular's new reactive primitives for fine-grained reactivity.\n\n" +
      "**Basic Signals:**\n\n" +
      "```typescript\n" +
      "import { Component, signal, computed, effect } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  template: `\n" +
      "    <p>Count: {{ count() }}</p>\n" +
      "    <p>Double: {{ doubleCount() }}</p>\n" +
      '    <button (click)="increment()">+1</button>\n' +
      '    <button (click)="reset()">Reset</button>\n' +
      "  `\n" +
      "})\n" +
      "export class CounterComponent {\n" +
      "  // Writable signal\n" +
      "  count = signal(0);\n\n" +
      "  // Computed signal (derived, read-only)\n" +
      "  doubleCount = computed(() => this.count() * 2);\n" +
      "  isEven = computed(() => this.count() % 2 === 0);\n\n" +
      "  // Effect (side effects)\n" +
      "  constructor() {\n" +
      "    effect(() => {\n" +
      "      console.log('Count changed to:', this.count());\n" +
      "      // Runs automatically when count changes\n" +
      "    });\n" +
      "  }\n\n" +
      "  // Update signal\n" +
      "  increment() {\n" +
      "    this.count.update(value => value + 1);\n" +
      "  }\n\n" +
      "  // Set signal\n" +
      "  reset() {\n" +
      "    this.count.set(0);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Signal-Based Change Detection:**\n\n" +
      "```typescript\n" +
      "// Traditional (Zone.js)\n" +
      "- Checks entire component tree on every event\n" +
      "- Uses monkey-patched async operations\n" +
      "- Can be inefficient\n\n" +
      "// Signal-Based (Angular 16+)\n" +
      "- Only updates dependent components\n" +
      "- Fine-grained reactivity\n" +
      "- No Zone.js needed\n" +
      "- Better performance\n" +
      "```\n\n" +
      "**Complex Computed Signals:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  firstName = signal('John');\n" +
      "  lastName = signal('Doe');\n" +
      "  age = signal(25);\n\n" +
      "  // Computed from multiple signals\n" +
      "  fullName = computed(() => `${this.firstName()} ${this.lastName()}`);\n\n" +
      "  // Conditional computed\n" +
      "  canVote = computed(() => this.age() >= 18);\n" +
      "  status = computed(() => \n" +
      "    this.age() < 18 ? 'Minor' : \n" +
      "    this.age() < 65 ? 'Adult' : 'Senior'\n" +
      "  );\n" +
      "}\n" +
      "```\n\n" +
      "**Effects with Cleanup:**\n\n" +
      "```typescript\n" +
      "import { effect } from '@angular/core';\n\n" +
      "constructor() {\n" +
      "  effect((onCleanup) => {\n" +
      "    const count = this.count();\n" +
      "    \n" +
      "    // Set up side effect\n" +
      "    const timer = setInterval(() => {\n" +
      "      console.log('Current count:', count);\n" +
      "    }, 1000);\n\n" +
      "    // Cleanup\n" +
      "    onCleanup(() => clearInterval(timer));\n" +
      "  });\n" +
      "}\n" +
      "```",
    category: "Signals Basics",
    difficulty: "hard",
    tags: ["signals", "computed", "effect", "angular-16", "reactivity"],
  },
  {
    id: 97,
    question:
      "What are Signal Inputs and Outputs? Explain input(), input.required(), and output().",
    answer:
      "Signal inputs/outputs provide type-safe, signal-based component communication.\n\n" +
      "**Signal Inputs (Angular 17.1+):**\n\n" +
      "```typescript\n" +
      "import { Component, input, computed } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  selector: 'app-user-card',\n" +
      "  template: `\n" +
      '    <div class="card">\n' +
      "      <h2>{{ fullName() }}</h2>\n" +
      "      <p>{{ email() }}</p>\n" +
      '      <span [class.active]="isActive()">Status</span>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class UserCardComponent {\n" +
      "  // Required input\n" +
      "  userId = input.required<number>();\n" +
      "  firstName = input.required<string>();\n" +
      "  lastName = input.required<string>();\n\n" +
      "  // Optional input with default\n" +
      "  email = input('no-email@example.com');\n" +
      "  isActive = input(false);\n\n" +
      "  // Computed from inputs\n" +
      "  fullName = computed(() => `${this.firstName()} ${this.lastName()}`);\n" +
      "  displayName = computed(() => \n" +
      "    `${this.fullName()} (ID: ${this.userId()})`\n" +
      "  );\n" +
      "}\n\n" +
      "// Parent usage\n" +
      "<app-user-card\n" +
      '  [userId]="123"\n' +
      "  [firstName]=\"'John'\"\n" +
      "  [lastName]=\"'Doe'\"\n" +
      "  [email]=\"'john@example.com'\"\n" +
      '  [isActive]="true" />\n' +
      "```\n\n" +
      "**Signal Outputs:**\n\n" +
      "```typescript\n" +
      "import { Component, input, output } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  selector: 'app-delete-button',\n" +
      "  template: `\n" +
      '    <button (click)="handleClick()">\n' +
      "      Delete {{ itemName() }}\n" +
      "    </button>\n" +
      "  `\n" +
      "})\n" +
      "export class DeleteButtonComponent {\n" +
      "  // Input\n" +
      "  itemId = input.required<number>();\n" +
      "  itemName = input('item');\n\n" +
      "  // Output (type-safe event emitter)\n" +
      "  deleted = output<number>();\n" +
      "  cancelled = output<void>();\n\n" +
      "  handleClick() {\n" +
      "    if (confirm(`Delete ${this.itemName()}?`)) {\n" +
      "      this.deleted.emit(this.itemId());\n" +
      "    } else {\n" +
      "      this.cancelled.emit();\n" +
      "    }\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage\n" +
      "<app-delete-button\n" +
      '  [itemId]="user.id"\n' +
      '  [itemName]="user.name"\n' +
      '  (deleted)="deleteUser($event)"\n' +
      '  (cancelled)="onCancel()" />\n' +
      "```\n\n" +
      "**Input Transforms:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  // Transform input automatically\n" +
      "  count = input(0, {\n" +
      "    transform: (value: string | number) => +value\n" +
      "  });\n" +
      '  // <comp count="5" /> → count() = 5 (number)\n\n' +
      "  // Alias\n" +
      "  userName = input('', { alias: 'name' });\n" +
      "  // <comp name=\"John\" /> → userName() = 'John'\n" +
      "}\n" +
      "```",
    category: "Signal Inputs/Outputs",
    difficulty: "hard",
    tags: ["signals", "inputs", "outputs", "angular-17", "component-api"],
  },
  {
    id: 98,
    question: "What is the model() API? Explain bi-directional binding with signals.",
    answer:
      "model() creates two-way bindable signals for forms and components.\n\n" +
      "**Basic model() Usage:**\n\n" +
      "```typescript\n" +
      "import { Component, model } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  selector: 'app-counter',\n" +
      "  template: `\n" +
      '    <button (click)="decrement()">-</button>\n' +
      "    <span>{{ value() }}</span>\n" +
      '    <button (click)="increment()">+</button>\n' +
      "  `\n" +
      "})\n" +
      "export class CounterComponent {\n" +
      "  // Two-way bindable signal\n" +
      "  value = model(0);\n\n" +
      "  increment() {\n" +
      "    this.value.update(v => v + 1);\n" +
      "    // Automatically emits valueChange event\n" +
      "  }\n\n" +
      "  decrement() {\n" +
      "    this.value.update(v => v - 1);\n" +
      "  }\n" +
      "}\n\n" +
      "// Parent component\n" +
      "@Component({\n" +
      "  template: `\n" +
      "    <p>Parent count: {{ count() }}</p>\n" +
      '    <app-counter [(value)]="count" />\n' +
      "    <!-- Equivalent to: -->\n" +
      '    <app-counter [value]="count()" (valueChange)="count.set($event)" />\n' +
      "  `\n" +
      "})\n" +
      "export class ParentComponent {\n" +
      "  count = signal(5);\n" +
      "}\n" +
      "```\n\n" +
      "**Form Control with model():**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-search',\n" +
      "  template: `\n" +
      '    <input [value]="query()" (input)="query.set($any($event.target).value)" />\n' +
      "    <p>Searching for: {{ query() }}</p>\n" +
      "    <p>Results: {{ results().length }}</p>\n" +
      "  `\n" +
      "})\n" +
      "export class SearchComponent {\n" +
      "  // Two-way bound query\n" +
      "  query = model('');\n\n" +
      "  // Computed results (auto-updates when query changes)\n" +
      "  results = computed(() => {\n" +
      "    const q = this.query().toLowerCase();\n" +
      "    return this.items.filter(item => item.name.toLowerCase().includes(q));\n" +
      "  });\n\n" +
      "  items = [{ name: 'Angular' }, { name: 'React' }, { name: 'Vue' }];\n" +
      "}\n\n" +
      "// Parent can bind\n" +
      '<app-search [(query)]="searchQuery" />\n' +
      "```\n\n" +
      "**Complex Two-Way Binding:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-user-form',\n" +
      "  template: `\n" +
      "    <input \n" +
      '      [value]="user().name" \n' +
      '      (input)="updateName($any($event.target).value)" />\n' +
      "    <input \n" +
      '      [value]="user().email" \n' +
      '      (input)="updateEmail($any($event.target).value)" />\n' +
      "  `\n" +
      "})\n" +
      "export class UserFormComponent {\n" +
      "  user = model<User>({ name: '', email: '' });\n\n" +
      "  updateName(name: string) {\n" +
      "    this.user.update(u => ({ ...u, name }));\n" +
      "  }\n\n" +
      "  updateEmail(email: string) {\n" +
      "    this.user.update(u => ({ ...u, email }));\n" +
      "  }\n" +
      "}\n\n" +
      "// Parent\n" +
      '<app-user-form [(user)]="currentUser" />\n' +
      "```",
    category: "Signal Model API",
    difficulty: "hard",
    tags: ["signals", "model", "two-way-binding", "forms", "angular-17"],
  },
  {
    id: 99,
    question:
      "What are Signal-based View Queries? Explain viewChild(), viewChildren(), contentChild(), contentChildren().",
    answer:
      "Signal-based queries return signals instead of requiring lifecycle hooks.\n\n" +
      "**viewChild() - Single Element:**\n\n" +
      "```typescript\n" +
      "import { Component, viewChild, ElementRef, AfterViewInit } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  template: `\n" +
      '    <input #nameInput placeholder="Name" />\n' +
      "    <app-child-component />\n" +
      '    <button (click)="focusInput()">Focus</button>\n' +
      "  `\n" +
      "})\n" +
      "export class Component implements AfterViewInit {\n" +
      "  // Query returns Signal<ElementRef | undefined>\n" +
      "  nameInput = viewChild<ElementRef>('nameInput');\n\n" +
      "  // Query component\n" +
      "  childComponent = viewChild(ChildComponent);\n\n" +
      "  ngAfterViewInit() {\n" +
      "    // Signal is available, no undefined checks needed!\n" +
      "    this.nameInput()?.nativeElement.focus();\n" +
      "  }\n\n" +
      "  focusInput() {\n" +
      "    this.nameInput()?.nativeElement.focus();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**viewChildren() - Multiple Elements:**\n\n" +
      "```typescript\n" +
      "import { viewChildren, QueryList } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  template: `\n" +
      "    @for (item of items; track item.id) {\n" +
      '      <app-item [data]="item" />\n' +
      "    }\n" +
      '    <button (click)="highlightAll()">Highlight All</button>\n' +
      "  `\n" +
      "})\n" +
      "export class Component {\n" +
      "  items = [{ id: 1 }, { id: 2 }, { id: 3 }];\n\n" +
      "  // Returns Signal<ReadonlyArray<ItemComponent>>\n" +
      "  itemComponents = viewChildren(ItemComponent);\n\n" +
      "  highlightAll() {\n" +
      "    this.itemComponents().forEach(item => item.highlight());\n" +
      "  }\n\n" +
      "  // Computed from query\n" +
      "  itemCount = computed(() => this.itemComponents().length);\n" +
      "}\n" +
      "```\n\n" +
      "**contentChild() / contentChildren() - Projected Content:**\n\n" +
      "```typescript\n" +
      "import { contentChild, contentChildren } from '@angular/core';\n\n" +
      "@Component({\n" +
      "  selector: 'app-tabs',\n" +
      "  template: `\n" +
      '    <div class="tabs">\n' +
      "      @for (tab of tabs(); track tab; let i = $index) {\n" +
      '        <button (click)="selectTab(i)">{{ tab.title }}</button>\n' +
      "      }\n" +
      "    </div>\n" +
      '    <div class="content">\n' +
      "      <ng-content></ng-content>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class TabsComponent {\n" +
      "  // Query projected content\n" +
      "  tabs = contentChildren(TabComponent);\n" +
      "  firstTab = contentChild(TabComponent);\n\n" +
      "  selectedIndex = signal(0);\n\n" +
      "  selectTab(index: number) {\n" +
      "    this.selectedIndex.set(index);\n" +
      "    this.tabs()[index].activate();\n" +
      "  }\n\n" +
      "  // Computed\n" +
      "  tabCount = computed(() => this.tabs().length);\n" +
      "}\n\n" +
      "// Usage\n" +
      "<app-tabs>\n" +
      '  <app-tab title="Tab 1">Content 1</app-tab>\n' +
      '  <app-tab title="Tab 2">Content 2</app-tab>\n' +
      "</app-tabs>\n" +
      "```\n\n" +
      "**Benefits vs Old API:**\n" +
      "- Always defined (returns Signal)\n" +
      "- No @ViewChild decorator\n" +
      "- Can use in computed signals\n" +
      "- Type-safe\n" +
      "- No lifecycle timing issues",
    category: "Signal View Queries",
    difficulty: "hard",
    tags: ["signals", "viewchild", "contentchild", "queries", "angular-17"],
  },
  {
    id: 100,
    question:
      "How do you implement complete CRUD with Signals? Show service and component integration.",
    answer:
      "**Signal-based CRUD Service:**\n\n" +
      "```typescript\n" +
      "import { Injectable, signal, computed } from '@angular/core';\n" +
      "import { HttpClient } from '@angular/common/http';\n" +
      "import { catchError, finalize } from 'rxjs/operators';\n" +
      "import { of } from 'rxjs';\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class UserSignalService {\n" +
      "  private http = inject(HttpClient);\n\n" +
      "  // State signals\n" +
      "  private usersState = signal<User[]>([]);\n" +
      "  private loadingState = signal(false);\n" +
      "  private errorState = signal<string | null>(null);\n" +
      "  private selectedIdState = signal<number | null>(null);\n\n" +
      "  // Public read-only\n" +
      "  users = this.usersState.asReadonly();\n" +
      "  loading = this.loadingState.asReadonly();\n" +
      "  error = this.errorState.asReadonly();\n\n" +
      "  // Computed\n" +
      "  userCount = computed(() => this.users().length);\n" +
      "  hasUsers = computed(() => this.users().length > 0);\n" +
      "  selectedUser = computed(() => {\n" +
      "    const id = this.selectedIdState();\n" +
      "    return this.users().find(u => u.id === id);\n" +
      "  });\n\n" +
      "  // CREATE\n" +
      "  createUser(user: Partial<User>) {\n" +
      "    this.loadingState.set(true);\n" +
      "    this.errorState.set(null);\n\n" +
      "    this.http.post<User>('/api/users', user)\n" +
      "      .pipe(\n" +
      "        catchError(error => {\n" +
      "          this.errorState.set(error.message);\n" +
      "          return of(null);\n" +
      "        }),\n" +
      "        finalize(() => this.loadingState.set(false))\n" +
      "      )\n" +
      "      .subscribe(newUser => {\n" +
      "        if (newUser) {\n" +
      "          this.usersState.update(users => [...users, newUser]);\n" +
      "        }\n" +
      "      });\n" +
      "  }\n\n" +
      "  // READ\n" +
      "  loadUsers() {\n" +
      "    this.loadingState.set(true);\n" +
      "    this.errorState.set(null);\n\n" +
      "    this.http.get<User[]>('/api/users')\n" +
      "      .pipe(\n" +
      "        catchError(error => {\n" +
      "          this.errorState.set(error.message);\n" +
      "          return of([]);\n" +
      "        }),\n" +
      "        finalize(() => this.loadingState.set(false))\n" +
      "      )\n" +
      "      .subscribe(users => this.usersState.set(users));\n" +
      "  }\n\n" +
      "  // UPDATE\n" +
      "  updateUser(id: number, changes: Partial<User>) {\n" +
      "    this.http.put<User>(`/api/users/${id}`, changes)\n" +
      "      .pipe(catchError(error => {\n" +
      "        this.errorState.set(error.message);\n" +
      "        return of(null);\n" +
      "      }))\n" +
      "      .subscribe(updated => {\n" +
      "        if (updated) {\n" +
      "          this.usersState.update(users =>\n" +
      "            users.map(u => u.id === id ? updated : u)\n" +
      "          );\n" +
      "        }\n" +
      "      });\n" +
      "  }\n\n" +
      "  // DELETE\n" +
      "  deleteUser(id: number) {\n" +
      "    this.http.delete(`/api/users/${id}`)\n" +
      "      .pipe(catchError(error => {\n" +
      "        this.errorState.set(error.message);\n" +
      "        return of(null);\n" +
      "      }))\n" +
      "      .subscribe(() => {\n" +
      "        this.usersState.update(users => users.filter(u => u.id !== id));\n" +
      "      });\n" +
      "  }\n\n" +
      "  selectUser(id: number) {\n" +
      "    this.selectedIdState.set(id);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Component Usage:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  template: `\n" +
      "    @if (service.loading()) {\n" +
      '      <div class="spinner">Loading...</div>\n' +
      "    }\n\n" +
      "    @if (service.error(); as error) {\n" +
      '      <div class="error">{{ error }}</div>\n' +
      "    }\n\n" +
      "    <p>Total: {{ service.userCount() }}</p>\n\n" +
      "    @for (user of service.users(); track user.id) {\n" +
      '      <div class="user-card">\n' +
      "        <h3>{{ user.name }}</h3>\n" +
      "        <button (click)=\"service.updateUser(user.id, { name: 'Updated' })\">Edit</button>\n" +
      '        <button (click)="service.deleteUser(user.id)">Delete</button>\n' +
      "      </div>\n" +
      "    } @empty {\n" +
      "      <p>No users found</p>\n" +
      "    }\n\n" +
      "    <button (click)=\"service.createUser({ name: 'New User' })\">Add User</button>\n" +
      "  `\n" +
      "})\n" +
      "export class UsersComponent {\n" +
      "  service = inject(UserSignalService);\n\n" +
      "  ngOnInit() {\n" +
      "    this.service.loadUsers();\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Signals CRUD",
    difficulty: "hard",
    tags: ["signals", "crud", "http", "state-management"],
  },
  {
    id: 101,
    question: "How do you handle HTTP with Signals? Show both RxJS and pure Signal approaches.",
    answer:
      "**Approach 1: RxJS with toSignal():**\n\n" +
      "```typescript\n" +
      "import { toSignal } from '@angular/core/rxjs-interop';\n" +
      "import { inject, Component } from '@angular/core';\n\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  private http = inject(HttpClient);\n\n" +
      "  // Convert Observable to Signal\n" +
      "  users = toSignal(\n" +
      "    this.http.get<User[]>('/api/users'),\n" +
      "    { initialValue: [] }\n" +
      "  );\n\n" +
      "  // With retry\n" +
      "  products = toSignal(\n" +
      "    this.http.get<Product[]>('/api/products').pipe(\n" +
      "      retry(3),\n" +
      "      catchError(() => of([]))\n" +
      "    ),\n" +
      "    { initialValue: [] }\n" +
      "  );\n\n" +
      "  // Template\n" +
      "  // @for (user of users(); track user.id) { ... }\n" +
      "}\n" +
      "```\n\n" +
      "**Approach 2: Pure Signals (Manual):**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  private http = inject(HttpClient);\n\n" +
      "  // State signals\n" +
      "  users = signal<User[]>([]);\n" +
      "  loading = signal(false);\n" +
      "  error = signal<string | null>(null);\n\n" +
      "  // Computed\n" +
      "  hasData = computed(() => this.users().length > 0);\n\n" +
      "  loadUsers() {\n" +
      "    this.loading.set(true);\n" +
      "    this.error.set(null);\n\n" +
      "    this.http.get<User[]>('/api/users')\n" +
      "      .pipe(\n" +
      "        catchError(err => {\n" +
      "          this.error.set(err.message);\n" +
      "          return of([]);\n" +
      "        }),\n" +
      "        finalize(() => this.loading.set(false))\n" +
      "      )\n" +
      "      .subscribe(users => this.users.set(users));\n" +
      "  }\n\n" +
      "  ngOnInit() {\n" +
      "    this.loadUsers();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Approach 3: Resource API (Angular 19+):**\n\n" +
      "```typescript\n" +
      "import { resource } from '@angular/core';\n\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  userId = signal(1);\n\n" +
      "  // Automatic refetch when userId changes\n" +
      "  userResource = resource({\n" +
      "    request: () => ({ id: this.userId() }),\n" +
      "    loader: ({ request }) => \n" +
      "      this.http.get<User>(`/api/users/${request.id}`)\n" +
      "  });\n\n" +
      "  // Access data, loading, error\n" +
      "  user = this.userResource.value;\n" +
      "  loading = this.userResource.isLoading;\n" +
      "  error = this.userResource.error;\n\n" +
      "  // Change userId triggers auto-reload\n" +
      "  loadUser(id: number) {\n" +
      "    this.userId.set(id);\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Signals HTTP",
    difficulty: "hard",
    tags: ["signals", "http", "rxjs", "tosignal", "resource"],
  },
  {
    id: 102,
    question: "How do you handle errors and loading states with Signals?",
    answer:
      "**Comprehensive Error & Loading Management:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class DataService {\n" +
      "  private http = inject(HttpClient);\n\n" +
      "  // Loading states\n" +
      "  private loadingState = signal(false);\n" +
      "  private savingState = signal(false);\n" +
      "  private deletingState = signal<number | null>(null);\n\n" +
      "  loading = this.loadingState.asReadonly();\n" +
      "  saving = this.savingState.asReadonly();\n" +
      "  deleting = this.deletingState.asReadonly();\n\n" +
      "  // Error states\n" +
      "  private errorState = signal<string | null>(null);\n" +
      "  private fieldErrors = signal<Record<string, string>>({});\n\n" +
      "  error = this.errorState.asReadonly();\n" +
      "  fieldError = this.fieldErrors.asReadonly();\n\n" +
      "  // Data\n" +
      "  private dataState = signal<User[]>([]);\n" +
      "  data = this.dataState.asReadonly();\n\n" +
      "  // Computed\n" +
      "  isLoading = computed(() => this.loading() || this.saving());\n" +
      "  hasError = computed(() => !!this.error());\n\n" +
      "  loadData() {\n" +
      "    this.loadingState.set(true);\n" +
      "    this.errorState.set(null);\n\n" +
      "    this.http.get<User[]>('/api/users')\n" +
      "      .pipe(\n" +
      "        catchError(error => {\n" +
      "          this.handleError(error);\n" +
      "          return of([]);\n" +
      "        }),\n" +
      "        finalize(() => this.loadingState.set(false))\n" +
      "      )\n" +
      "      .subscribe(users => this.dataState.set(users));\n" +
      "  }\n\n" +
      "  saveData(user: User) {\n" +
      "    this.savingState.set(true);\n" +
      "    this.errorState.set(null);\n" +
      "    this.fieldErrors.set({});\n\n" +
      "    this.http.post<User>('/api/users', user)\n" +
      "      .pipe(\n" +
      "        catchError(error => {\n" +
      "          if (error.status === 400 && error.error.errors) {\n" +
      "            // Field-specific errors\n" +
      "            this.fieldErrors.set(error.error.errors);\n" +
      "          } else {\n" +
      "            this.errorState.set(error.message);\n" +
      "          }\n" +
      "          return of(null);\n" +
      "        }),\n" +
      "        finalize(() => this.savingState.set(false))\n" +
      "      )\n" +
      "      .subscribe(saved => {\n" +
      "        if (saved) {\n" +
      "          this.dataState.update(users => [...users, saved]);\n" +
      "        }\n" +
      "      });\n" +
      "  }\n\n" +
      "  deleteData(id: number) {\n" +
      "    this.deletingState.set(id);\n\n" +
      "    this.http.delete(`/api/users/${id}`)\n" +
      "      .pipe(\n" +
      "        catchError(error => {\n" +
      "          this.errorState.set(`Failed to delete user ${id}`);\n" +
      "          return of(null);\n" +
      "        }),\n" +
      "        finalize(() => this.deletingState.set(null))\n" +
      "      )\n" +
      "      .subscribe(success => {\n" +
      "        if (success !== null) {\n" +
      "          this.dataState.update(users => users.filter(u => u.id !== id));\n" +
      "        }\n" +
      "      });\n" +
      "  }\n\n" +
      "  clearError() {\n" +
      "    this.errorState.set(null);\n" +
      "    this.fieldErrors.set({});\n" +
      "  }\n\n" +
      "  private handleError(error: any) {\n" +
      "    const message = error.error?.message || error.message || 'Unknown error';\n" +
      "    this.errorState.set(message);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Component with Loading/Error UI:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  template: `\n" +
      "    <!-- Global error toast -->\n" +
      "    @if (service.error(); as error) {\n" +
      '      <div class="toast error">\n' +
      "        {{ error }}\n" +
      '        <button (click)="service.clearError()">✕</button>\n' +
      "      </div>\n" +
      "    }\n\n" +
      "    <!-- Loading overlay -->\n" +
      "    @if (service.isLoading()) {\n" +
      '      <div class="loading-overlay">\n' +
      '        <div class="spinner"></div>\n' +
      "      </div>\n" +
      "    }\n\n" +
      "    <!-- Data list -->\n" +
      "    @for (user of service.data(); track user.id) {\n" +
      '      <div class="user-card" [class.deleting]="service.deleting() === user.id">\n' +
      "        <h3>{{ user.name }}</h3>\n" +
      "        <button \n" +
      '          (click)="service.deleteUser(user.id)"\n' +
      '          [disabled]="service.deleting() === user.id">\n' +
      "          @if (service.deleting() === user.id) {\n" +
      "            Deleting...\n" +
      "          } @else {\n" +
      "            Delete\n" +
      "          }\n" +
      "        </button>\n" +
      "      </div>\n" +
      "    }\n\n" +
      "    <!-- Field errors -->\n" +
      "    @if (service.fieldError().name) {\n" +
      '      <span class="field-error">{{ service.fieldError().name }}</span>\n' +
      "    }\n" +
      "  `\n" +
      "})\n" +
      "export class Component {\n" +
      "  service = inject(DataService);\n" +
      "}\n" +
      "```",
    category: "Signals Error Handling",
    difficulty: "hard",
    tags: ["signals", "error-handling", "loading", "state-management"],
  },
  {
    id: 103,
    question:
      "How do you create Stateful Signal-based Services? Show complete example with loading/error/data pattern.",
    answer:
      "**Generic Signal Service Pattern:**\n\n" +
      "```typescript\n" +
      "// Base class for reusable pattern\n" +
      "export abstract class SignalService<T> {\n" +
      "  protected http = inject(HttpClient);\n\n" +
      "  // State signals\n" +
      "  protected dataState = signal<T[]>([]);\n" +
      "  protected loadingState = signal(false);\n" +
      "  protected errorState = signal<string | null>(null);\n" +
      "  protected selectedState = signal<T | null>(null);\n\n" +
      "  // Public API\n" +
      "  readonly data = this.dataState.asReadonly();\n" +
      "  readonly loading = this.loadingState.asReadonly();\n" +
      "  readonly error = this.errorState.asReadonly();\n" +
      "  readonly selected = this.selectedState.asReadonly();\n\n" +
      "  // Computed\n" +
      "  readonly count = computed(() => this.data().length);\n" +
      "  readonly hasData = computed(() => this.data().length > 0);\n" +
      "  readonly hasError = computed(() => !!this.error());\n\n" +
      "  abstract getEndpoint(): string;\n\n" +
      "  load() {\n" +
      "    this.loadingState.set(true);\n" +
      "    this.errorState.set(null);\n\n" +
      "    this.http.get<T[]>(this.getEndpoint())\n" +
      "      .pipe(\n" +
      "        catchError(error => {\n" +
      "          this.errorState.set(error.message);\n" +
      "          return of([]);\n" +
      "        }),\n" +
      "        finalize(() => this.loadingState.set(false))\n" +
      "      )\n" +
      "      .subscribe(data => this.dataState.set(data));\n" +
      "  }\n\n" +
      "  select(item: T) {\n" +
      "    this.selectedState.set(item);\n" +
      "  }\n\n" +
      "  clearError() {\n" +
      "    this.errorState.set(null);\n" +
      "  }\n" +
      "}\n\n" +
      "// Concrete implementation\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class UsersService extends SignalService<User> {\n" +
      "  getEndpoint() {\n" +
      "    return '/api/users';\n" +
      "  }\n\n" +
      "  // Add custom methods\n" +
      "  activeUsers = computed(() => \n" +
      "    this.data().filter(u => u.active)\n" +
      "  );\n\n" +
      "  searchUsers = signal('');\n" +
      "  filteredUsers = computed(() => {\n" +
      "    const query = this.searchUsers().toLowerCase();\n" +
      "    return this.data().filter(u => \n" +
      "      u.name.toLowerCase().includes(query)\n" +
      "    );\n" +
      "  });\n" +
      "}\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class ProductsService extends SignalService<Product> {\n" +
      "  getEndpoint() {\n" +
      "    return '/api/products';\n" +
      "  }\n\n" +
      "  // Product-specific\n" +
      "  totalValue = computed(() => \n" +
      "    this.data().reduce((sum, p) => sum + p.price, 0)\n" +
      "  );\n" +
      "}\n" +
      "```\n\n" +
      "**Usage:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class UsersComponent {\n" +
      "  service = inject(UsersService);\n\n" +
      "  ngOnInit() {\n" +
      "    this.service.load();\n" +
      "  }\n" +
      "}\n\n" +
      "@Component({...})\n" +
      "export class ProductsComponent {\n" +
      "  service = inject(ProductsService);\n\n" +
      "  ngOnInit() {\n" +
      "    this.service.load();\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Signal Services",
    difficulty: "hard",
    tags: ["signals", "services", "state-management", "patterns"],
  },
  {
    id: 104,
    question: "How do you implement Authentication with Signals? Show complete auth flow.",
    answer:
      "**Complete Signal-based Authentication:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class SignalAuthService {\n" +
      "  private http = inject(HttpClient);\n" +
      "  private router = inject(Router);\n\n" +
      "  // State\n" +
      "  private userState = signal<User | null>(null);\n" +
      "  private tokenState = signal<string | null>(null);\n" +
      "  private loadingState = signal(false);\n" +
      "  private errorState = signal<string | null>(null);\n\n" +
      "  // Public signals\n" +
      "  user = this.userState.asReadonly();\n" +
      "  token = this.tokenState.asReadonly();\n" +
      "  loading = this.loadingState.asReadonly();\n" +
      "  error = this.errorState.asReadonly();\n\n" +
      "  // Computed\n" +
      "  isAuthenticated = computed(() => !!this.user());\n" +
      "  isAdmin = computed(() => this.user()?.role === 'admin');\n" +
      "  userName = computed(() => this.user()?.name ?? 'Guest');\n" +
      "  userEmail = computed(() => this.user()?.email ?? '');\n\n" +
      "  constructor() {\n" +
      "    this.loadStoredAuth();\n" +
      "    this.setupTokenExpiration();\n" +
      "  }\n\n" +
      "  login(email: string, password: string) {\n" +
      "    this.loadingState.set(true);\n" +
      "    this.errorState.set(null);\n\n" +
      "    this.http.post<{ user: User; token: string; expiresIn: number }>(\n" +
      "      '/api/login',\n" +
      "      { email, password }\n" +
      "    )\n" +
      "      .pipe(\n" +
      "        tap(response => {\n" +
      "          this.setAuthData(response);\n" +
      "          this.router.navigate(['/dashboard']);\n" +
      "        }),\n" +
      "        catchError(error => {\n" +
      "          this.errorState.set(error.error?.message || 'Login failed');\n" +
      "          return of(null);\n" +
      "        }),\n" +
      "        finalize(() => this.loadingState.set(false))\n" +
      "      )\n" +
      "      .subscribe();\n" +
      "  }\n\n" +
      "  logout() {\n" +
      "    this.userState.set(null);\n" +
      "    this.tokenState.set(null);\n" +
      "    localStorage.removeItem('token');\n" +
      "    localStorage.removeItem('user');\n" +
      "    this.router.navigate(['/login']);\n" +
      "  }\n\n" +
      "  refreshToken() {\n" +
      "    return this.http.post<{ token: string }>('/api/refresh', {}).pipe(\n" +
      "      tap(({ token }) => {\n" +
      "        this.tokenState.set(token);\n" +
      "        localStorage.setItem('token', token);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n\n" +
      "  private setAuthData(response: { user: User; token: string; expiresIn: number }) {\n" +
      "    this.userState.set(response.user);\n" +
      "    this.tokenState.set(response.token);\n" +
      "    localStorage.setItem('token', response.token);\n" +
      "    localStorage.setItem('user', JSON.stringify(response.user));\n" +
      "    localStorage.setItem('tokenExpires', String(Date.now() + response.expiresIn * 1000));\n" +
      "  }\n\n" +
      "  private loadStoredAuth() {\n" +
      "    const token = localStorage.getItem('token');\n" +
      "    const user = localStorage.getItem('user');\n" +
      "    const expires = localStorage.getItem('tokenExpires');\n\n" +
      "    if (token && user && expires && Date.now() < +expires) {\n" +
      "      this.tokenState.set(token);\n" +
      "      this.userState.set(JSON.parse(user));\n" +
      "    } else {\n" +
      "      this.logout();\n" +
      "    }\n" +
      "  }\n\n" +
      "  private setupTokenExpiration() {\n" +
      "    effect(() => {\n" +
      "      const expires = localStorage.getItem('tokenExpires');\n" +
      "      if (expires && this.isAuthenticated()) {\n" +
      "        const timeLeft = +expires - Date.now();\n" +
      "        if (timeLeft > 0) {\n" +
      "          setTimeout(() => this.refreshToken().subscribe(), timeLeft - 60000);\n" +
      "        }\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "}\n\n" +
      "// Guard\n" +
      "export const authGuard: CanActivateFn = () => {\n" +
      "  const auth = inject(SignalAuthService);\n" +
      "  const router = inject(Router);\n\n" +
      "  if (auth.isAuthenticated()) {\n" +
      "    return true;\n" +
      "  }\n\n" +
      "  return router.createUrlTree(['/login']);\n" +
      "};\n\n" +
      "// Interceptor\n" +
      "export const authInterceptor: HttpInterceptorFn = (req, next) => {\n" +
      "  const auth = inject(SignalAuthService);\n" +
      "  const token = auth.token();\n\n" +
      "  if (token) {\n" +
      "    req = req.clone({\n" +
      "      setHeaders: { Authorization: `Bearer ${token}` }\n" +
      "    });\n" +
      "  }\n\n" +
      "  return next(req).pipe(\n" +
      "    catchError(error => {\n" +
      "      if (error.status === 401) {\n" +
      "        auth.logout();\n" +
      "      }\n" +
      "      return throwError(() => error);\n" +
      "    })\n" +
      "  );\n" +
      "};\n" +
      "```",
    category: "Signals Authentication",
    difficulty: "hard",
    tags: ["signals", "authentication", "jwt", "security"],
  },
  {
    id: 105,
    question:
      "How do you handle user-facing error messages with Signals? Show toast/notification system.",
    answer:
      "**Toast Service with Signals:**\n\n" +
      "```typescript\n" +
      "export interface Toast {\n" +
      "  id: number;\n" +
      "  message: string;\n" +
      "  type: 'success' | 'error' | 'warning' | 'info';\n" +
      "  duration?: number;\n" +
      "}\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class ToastService {\n" +
      "  private toastsState = signal<Toast[]>([]);\n" +
      "  private nextId = 0;\n\n" +
      "  toasts = this.toastsState.asReadonly();\n" +
      "  hasToasts = computed(() => this.toasts().length > 0);\n\n" +
      "  show(message: string, type: Toast['type'] = 'info', duration = 3000) {\n" +
      "    const toast: Toast = {\n" +
      "      id: this.nextId++,\n" +
      "      message,\n" +
      "      type,\n" +
      "      duration\n" +
      "    };\n\n" +
      "    this.toastsState.update(toasts => [...toasts, toast]);\n\n" +
      "    if (duration > 0) {\n" +
      "      setTimeout(() => this.remove(toast.id), duration);\n" +
      "    }\n" +
      "  }\n\n" +
      "  success(message: string) {\n" +
      "    this.show(message, 'success');\n" +
      "  }\n\n" +
      "  error(message: string) {\n" +
      "    this.show(message, 'error', 5000);\n" +
      "  }\n\n" +
      "  warning(message: string) {\n" +
      "    this.show(message, 'warning');\n" +
      "  }\n\n" +
      "  remove(id: number) {\n" +
      "    this.toastsState.update(toasts => toasts.filter(t => t.id !== id));\n" +
      "  }\n\n" +
      "  clear() {\n" +
      "    this.toastsState.set([]);\n" +
      "  }\n" +
      "}\n\n" +
      "// Toast Container Component\n" +
      "@Component({\n" +
      "  selector: 'app-toast-container',\n" +
      "  standalone: true,\n" +
      "  template: `\n" +
      '    <div class="toast-container">\n' +
      "      @for (toast of toastService.toasts(); track toast.id) {\n" +
      '        <div class="toast" [class]="toast.type">\n' +
      "          <span>{{ toast.message }}</span>\n" +
      '          <button (click)="toastService.remove(toast.id)">✕</button>\n' +
      "        </div>\n" +
      "      }\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .toast-container {\n" +
      "      position: fixed;\n" +
      "      top: 20px;\n" +
      "      right: 20px;\n" +
      "      z-index: 9999;\n" +
      "    }\n" +
      "    .toast {\n" +
      "      padding: 12px 16px;\n" +
      "      margin-bottom: 8px;\n" +
      "      border-radius: 4px;\n" +
      "      box-shadow: 0 2px 8px rgba(0,0,0,0.15);\n" +
      "    }\n" +
      "    .success { background: #4caf50; color: white; }\n" +
      "    .error { background: #f44336; color: white; }\n" +
      "    .warning { background: #ff9800; color: white; }\n" +
      "    .info { background: #2196f3; color: white; }\n" +
      "  `]\n" +
      "})\n" +
      "export class ToastContainerComponent {\n" +
      "  toastService = inject(ToastService);\n" +
      "}\n\n" +
      "// Usage in other components\n" +
      "@Component({...})\n" +
      "export class DataComponent {\n" +
      "  toast = inject(ToastService);\n" +
      "  http = inject(HttpClient);\n\n" +
      "  saveData(data: any) {\n" +
      "    this.http.post('/api/data', data)\n" +
      "      .pipe(\n" +
      "        tap(() => this.toast.success('Data saved successfully!')),\n" +
      "        catchError(error => {\n" +
      "          this.toast.error(error.message);\n" +
      "          return of(null);\n" +
      "        })\n" +
      "      )\n" +
      "      .subscribe();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Form Validation Errors:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  template: `\n" +
      "    <form>\n" +
      '      <input [(ngModel)]="name" name="name" />\n' +
      "      @if (errors().name) {\n" +
      '        <span class="error">{{ errors().name }}</span>\n' +
      "      }\n\n" +
      '      <input [(ngModel)]="email" name="email" />\n' +
      "      @if (errors().email) {\n" +
      '        <span class="error">{{ errors().email }}</span>\n' +
      "      }\n\n" +
      '      <button (click)="submit()">Submit</button>\n' +
      "    </form>\n" +
      "  `\n" +
      "})\n" +
      "export class FormComponent {\n" +
      "  name = '';\n" +
      "  email = '';\n" +
      "  errors = signal<Record<string, string>>({});\n\n" +
      "  submit() {\n" +
      "    this.http.post('/api/users', { name: this.name, email: this.email })\n" +
      "      .pipe(\n" +
      "        catchError(error => {\n" +
      "          if (error.status === 400) {\n" +
      "            this.errors.set(error.error.errors);\n" +
      "          }\n" +
      "          return of(null);\n" +
      "        })\n" +
      "      )\n" +
      "      .subscribe();\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Signals User Messages",
    difficulty: "hard",
    tags: ["signals", "toast", "notifications", "ux"],
  },
  {
    id: 106,
    question: "How do you implement Reactive Search with Signals?",
    answer:
      "**Signal-based Search with Debounce:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-user-search',\n" +
      "  standalone: true,\n" +
      "  imports: [FormsModule],\n" +
      "  template: `\n" +
      "    <input \n" +
      '      [value]="searchQuery()" \n' +
      '      (input)="searchQuery.set($any($event.target).value)" \n' +
      '      placeholder="Search users..." />\n\n' +
      "    @if (loading()) {\n" +
      "      <p>Searching...</p>\n" +
      "    }\n\n" +
      "    @if (error(); as err) {\n" +
      '      <p class="error">{{ err }}</p>\n' +
      "    }\n\n" +
      "    <p>Found: {{ results().length }} users</p>\n\n" +
      "    @for (user of results(); track user.id) {\n" +
      '      <div class="user-card">{{ user.name }}</div>\n' +
      "    } @empty {\n" +
      "      <p>No results</p>\n" +
      "    }\n" +
      "  `\n" +
      "})\n" +
      "export class UserSearchComponent {\n" +
      "  private http = inject(HttpClient);\n\n" +
      "  searchQuery = signal('');\n" +
      "  results = signal<User[]>([]);\n" +
      "  loading = signal(false);\n" +
      "  error = signal<string | null>(null);\n\n" +
      "  constructor() {\n" +
      "    // Auto-search when query changes (with debounce using RxJS)\n" +
      "    toObservable(this.searchQuery)\n" +
      "      .pipe(\n" +
      "        debounceTime(300),\n" +
      "        distinctUntilChanged(),\n" +
      "        tap(() => {\n" +
      "          this.loading.set(true);\n" +
      "          this.error.set(null);\n" +
      "        }),\n" +
      "        switchMap(query => {\n" +
      "          if (!query) {\n" +
      "            this.results.set([]);\n" +
      "            this.loading.set(false);\n" +
      "            return of([]);\n" +
      "          }\n\n" +
      "          return this.http.get<User[]>(`/api/users/search?q=${query}`).pipe(\n" +
      "            catchError(error => {\n" +
      "              this.error.set(error.message);\n" +
      "              return of([]);\n" +
      "            }),\n" +
      "            finalize(() => this.loading.set(false))\n" +
      "          );\n" +
      "        })\n" +
      "      )\n" +
      "      .subscribe(users => this.results.set(users));\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Alternative: Pure Signal Approach (No RxJS):**\n\n" +
      "```typescript\n" +
      "// Client-side filtering\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  allUsers = signal<User[]>([]);\n" +
      "  searchQuery = signal('');\n\n" +
      "  // Computed filtered results\n" +
      "  filteredUsers = computed(() => {\n" +
      "    const query = this.searchQuery().toLowerCase();\n" +
      "    if (!query) return this.allUsers();\n\n" +
      "    return this.allUsers().filter(user =>\n" +
      "      user.name.toLowerCase().includes(query) ||\n" +
      "      user.email.toLowerCase().includes(query)\n" +
      "    );\n" +
      "  });\n\n" +
      "  resultCount = computed(() => this.filteredUsers().length);\n" +
      "}\n" +
      "```",
    category: "Signals Reactive Search",
    difficulty: "hard",
    tags: ["signals", "search", "debounce", "reactive"],
  },
  {
    id: 107,
    question: "How do you implement Pagination with Signals?",
    answer:
      "**Complete Pagination System:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class PaginatedDataService {\n" +
      "  private http = inject(HttpClient);\n\n" +
      "  // State\n" +
      "  private dataState = signal<User[]>([]);\n" +
      "  private totalState = signal(0);\n" +
      "  private pageState = signal(1);\n" +
      "  private pageSizeState = signal(10);\n" +
      "  private loadingState = signal(false);\n\n" +
      "  // Public\n" +
      "  data = this.dataState.asReadonly();\n" +
      "  total = this.totalState.asReadonly();\n" +
      "  page = this.pageState.asReadonly();\n" +
      "  pageSize = this.pageSizeState.asReadonly();\n" +
      "  loading = this.loadingState.asReadonly();\n\n" +
      "  // Computed\n" +
      "  totalPages = computed(() => Math.ceil(this.total() / this.pageSize()));\n" +
      "  hasNext = computed(() => this.page() < this.totalPages());\n" +
      "  hasPrev = computed(() => this.page() > 1);\n" +
      "  startIndex = computed(() => (this.page() - 1) * this.pageSize() + 1);\n" +
      "  endIndex = computed(() => Math.min(this.page() * this.pageSize(), this.total()));\n\n" +
      "  constructor() {\n" +
      "    // Auto-load when page/pageSize changes\n" +
      "    effect(() => {\n" +
      "      const page = this.page();\n" +
      "      const pageSize = this.pageSize();\n" +
      "      this.load(page, pageSize);\n" +
      "    });\n" +
      "  }\n\n" +
      "  private load(page: number, pageSize: number) {\n" +
      "    this.loadingState.set(true);\n\n" +
      "    this.http.get<{ data: User[]; total: number }>(\n" +
      "      `/api/users?page=${page}&pageSize=${pageSize}`\n" +
      "    )\n" +
      "      .pipe(finalize(() => this.loadingState.set(false)))\n" +
      "      .subscribe(response => {\n" +
      "        this.dataState.set(response.data);\n" +
      "        this.totalState.set(response.total);\n" +
      "      });\n" +
      "  }\n\n" +
      "  nextPage() {\n" +
      "    if (this.hasNext()) {\n" +
      "      this.pageState.update(p => p + 1);\n" +
      "    }\n" +
      "  }\n\n" +
      "  prevPage() {\n" +
      "    if (this.hasPrev()) {\n" +
      "      this.pageState.update(p => p - 1);\n" +
      "    }\n" +
      "  }\n\n" +
      "  goToPage(page: number) {\n" +
      "    if (page >= 1 && page <= this.totalPages()) {\n" +
      "      this.pageState.set(page);\n" +
      "    }\n" +
      "  }\n\n" +
      "  setPageSize(size: number) {\n" +
      "    this.pageSizeState.set(size);\n" +
      "    this.pageState.set(1); // Reset to first page\n" +
      "  }\n" +
      "}\n\n" +
      "// Component\n" +
      "@Component({\n" +
      "  template: `\n" +
      "    @for (user of service.data(); track user.id) {\n" +
      "      <div>{{ user.name }}</div>\n" +
      "    }\n\n" +
      '    <div class="pagination">\n' +
      '      <button (click)="service.prevPage()" [disabled]="!service.hasPrev()">\n' +
      "        Previous\n" +
      "      </button>\n\n" +
      "      <span>Page {{ service.page() }} of {{ service.totalPages() }}</span>\n" +
      "      <span>({{ service.startIndex() }}-{{ service.endIndex() }} of {{ service.total() }})</span>\n\n" +
      '      <button (click)="service.nextPage()" [disabled]="!service.hasNext()">\n' +
      "        Next\n" +
      "      </button>\n\n" +
      '      <select [value]="service.pageSize()" (change)="service.setPageSize(+$any($event.target).value)">\n' +
      '        <option value="10">10</option>\n' +
      '        <option value="25">25</option>\n' +
      '        <option value="50">50</option>\n' +
      "      </select>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class UsersComponent {\n" +
      "  service = inject(PaginatedDataService);\n" +
      "}\n" +
      "```",
    category: "Signals Pagination",
    difficulty: "hard",
    tags: ["signals", "pagination", "data-tables", "ux"],
  },
  {
    id: 116,
    question: "How do you convert between Signals and RxJS? Explain toSignal() and toObservable().",
    answer:
      "**toSignal() - Observable to Signal:**\n\n" +
      "```typescript\n" +
      "import { toSignal } from '@angular/core/rxjs-interop';\n" +
      "import { interval, fromEvent } from 'rxjs';\n\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  // Convert HTTP observable\n" +
      "  users = toSignal(\n" +
      "    this.http.get<User[]>('/api/users'),\n" +
      "    { initialValue: [] }\n" +
      "  );\n\n" +
      "  // Convert interval\n" +
      "  timer = toSignal(interval(1000), { initialValue: 0 });\n\n" +
      "  // Without initial value (can be undefined)\n" +
      "  data = toSignal(this.dataService.data$);\n" +
      "  // Type: Signal<Data | undefined>\n\n" +
      "  // Require initial value\n" +
      "  safeData = toSignal(\n" +
      "    this.dataService.data$,\n" +
      "    { requireSync: true } // Throws if no value emitted synchronously\n" +
      "  );\n\n" +
      "  // Manual unsubscribe\n" +
      "  constructor() {\n" +
      "    const signal = toSignal(this.observable$);\n" +
      "    // Auto-unsubscribes when component destroys\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**toObservable() - Signal to Observable:**\n\n" +
      "```typescript\n" +
      "import { toObservable } from '@angular/core/rxjs-interop';\n\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  searchQuery = signal('');\n\n" +
      "  constructor() {\n" +
      "    // Convert signal to observable for RxJS operators\n" +
      "    toObservable(this.searchQuery)\n" +
      "      .pipe(\n" +
      "        debounceTime(300),\n" +
      "        distinctUntilChanged(),\n" +
      "        switchMap(query => this.http.get(`/api/search?q=${query}`))\n" +
      "      )\n" +
      "      .subscribe(results => this.results.set(results));\n" +
      "  }\n\n" +
      "  results = signal<any[]>([]);\n" +
      "}\n" +
      "```\n\n" +
      "**Combining Both:**\n\n" +
      "```typescript\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  userId = signal(1);\n\n" +
      "  // Signal → Observable → Transform → Signal\n" +
      "  user = toSignal(\n" +
      "    toObservable(this.userId).pipe(\n" +
      "      debounceTime(300),\n" +
      "      switchMap(id => this.http.get<User>(`/api/users/${id}`))\n" +
      "    )\n" +
      "  );\n\n" +
      "  // When userId changes, automatically fetches new user\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices:**\n" +
      "- Use toSignal() for observables you want in templates\n" +
      "- Use toObservable() when you need RxJS operators\n" +
      "- Always provide initialValue when possible\n" +
      "- toSignal() auto-unsubscribes on destroy",
    category: "Signal-RxJS Interop",
    difficulty: "hard",
    tags: ["signals", "rxjs", "tosignal", "toobservable", "interop"],
  },
  {
    id: 108,
    question: "How do you implement Optimistic Updates with Signals?",
    answer:
      "**Optimistic Update Pattern:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class OptimisticUserService {\n" +
      "  private http = inject(HttpClient);\n\n" +
      "  private usersState = signal<User[]>([]);\n" +
      "  private errorState = signal<string | null>(null);\n\n" +
      "  users = this.usersState.asReadonly();\n" +
      "  error = this.errorState.asReadonly();\n\n" +
      "  // Optimistic create\n" +
      "  createUser(user: Partial<User>) {\n" +
      "    const tempId = Date.now(); // Temporary ID\n" +
      "    const tempUser: User = { ...user, id: tempId, pending: true } as User;\n\n" +
      "    // 1. Immediately add to UI (optimistic)\n" +
      "    this.usersState.update(users => [...users, tempUser]);\n\n" +
      "    // 2. Save to server\n" +
      "    this.http.post<User>('/api/users', user)\n" +
      "      .pipe(\n" +
      "        catchError(error => {\n" +
      "          // Rollback on error\n" +
      "          this.usersState.update(users => users.filter(u => u.id !== tempId));\n" +
      "          this.errorState.set(error.message);\n" +
      "          return of(null);\n" +
      "        })\n" +
      "      )\n" +
      "      .subscribe(savedUser => {\n" +
      "        if (savedUser) {\n" +
      "          // Replace temp with real user\n" +
      "          this.usersState.update(users =>\n" +
      "            users.map(u => u.id === tempId ? savedUser : u)\n" +
      "          );\n" +
      "        }\n" +
      "      });\n" +
      "  }\n\n" +
      "  // Optimistic update\n" +
      "  updateUser(id: number, changes: Partial<User>) {\n" +
      "    // Store original for rollback\n" +
      "    const original = this.users().find(u => u.id === id);\n" +
      "    if (!original) return;\n\n" +
      "    // 1. Immediately update UI\n" +
      "    this.usersState.update(users =>\n" +
      "      users.map(u => u.id === id ? { ...u, ...changes } : u)\n" +
      "    );\n\n" +
      "    // 2. Save to server\n" +
      "    this.http.put<User>(`/api/users/${id}`, changes)\n" +
      "      .pipe(\n" +
      "        catchError(error => {\n" +
      "          // Rollback to original\n" +
      "          this.usersState.update(users =>\n" +
      "            users.map(u => u.id === id ? original : u)\n" +
      "          );\n" +
      "          this.errorState.set('Update failed');\n" +
      "          return of(null);\n" +
      "        })\n" +
      "      )\n" +
      "      .subscribe(updated => {\n" +
      "        if (updated) {\n" +
      "          // Confirm with server data\n" +
      "          this.usersState.update(users =>\n" +
      "            users.map(u => u.id === id ? updated : u)\n" +
      "          );\n" +
      "        }\n" +
      "      });\n" +
      "  }\n\n" +
      "  // Optimistic delete\n" +
      "  deleteUser(id: number) {\n" +
      "    const original = this.users().find(u => u.id === id);\n" +
      "    if (!original) return;\n\n" +
      "    // 1. Immediately remove from UI\n" +
      "    this.usersState.update(users => users.filter(u => u.id !== id));\n\n" +
      "    // 2. Delete on server\n" +
      "    this.http.delete(`/api/users/${id}`)\n" +
      "      .pipe(\n" +
      "        catchError(error => {\n" +
      "          // Rollback - add back\n" +
      "          this.usersState.update(users => [...users, original]);\n" +
      "          this.errorState.set('Delete failed');\n" +
      "          return of(null);\n" +
      "        })\n" +
      "      )\n" +
      "      .subscribe();\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Signals Optimistic Updates",
    difficulty: "hard",
    tags: ["signals", "optimistic-updates", "ux", "offline"],
  },
  {
    id: 110,
    question: "How do you implement Caching and State Persistence with Signals?",
    answer:
      "**LocalStorage Sync with Signals:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class CachedDataService {\n" +
      "  private dataState = signal<User[]>([]);\n" +
      "  private cacheKey = 'users-cache';\n\n" +
      "  data = this.dataState.asReadonly();\n\n" +
      "  constructor() {\n" +
      "    // Load from cache\n" +
      "    this.loadFromCache();\n\n" +
      "    // Auto-save on changes\n" +
      "    effect(() => {\n" +
      "      const users = this.data();\n" +
      "      localStorage.setItem(this.cacheKey, JSON.stringify(users));\n" +
      "    });\n" +
      "  }\n\n" +
      "  private loadFromCache() {\n" +
      "    const cached = localStorage.getItem(this.cacheKey);\n" +
      "    if (cached) {\n" +
      "      this.dataState.set(JSON.parse(cached));\n" +
      "    }\n" +
      "  }\n\n" +
      "  updateData(users: User[]) {\n" +
      "    this.dataState.set(users);\n" +
      "    // Auto-saves via effect\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Signals Caching",
    difficulty: "intermediate",
    tags: ["signals", "caching", "localstorage", "persistence"],
  },
  {
    id: 111,
    question: "How do you implement Real-time Updates with Signals and WebSockets?",
    answer:
      "**WebSocket with Signals:**\n\n" +
      "```typescript\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class SignalWebSocketService {\n" +
      "  private socket$ = webSocket('ws://localhost:8080');\n\n" +
      "  // State\n" +
      "  private messagesState = signal<Message[]>([]);\n" +
      "  private connectedState = signal(false);\n" +
      "  private onlineUsersState = signal<User[]>([]);\n\n" +
      "  messages = this.messagesState.asReadonly();\n" +
      "  connected = this.connectedState.asReadonly();\n" +
      "  onlineUsers = this.onlineUsersState.asReadonly();\n\n" +
      "  // Computed\n" +
      "  messageCount = computed(() => this.messages().length);\n" +
      "  onlineCount = computed(() => this.onlineUsers().length);\n\n" +
      "  connect() {\n" +
      "    this.socket$.pipe(\n" +
      "      tap(() => this.connectedState.set(true)),\n" +
      "      catchError(() => {\n" +
      "        this.connectedState.set(false);\n" +
      "        return of(null);\n" +
      "      })\n" +
      "    ).subscribe(message => {\n" +
      "      if (!message) return;\n\n" +
      "      switch (message.type) {\n" +
      "        case 'NEW_MESSAGE':\n" +
      "          this.messagesState.update(msgs => [...msgs, message.data]);\n" +
      "          break;\n" +
      "        case 'USER_JOINED':\n" +
      "          this.onlineUsersState.update(users => [...users, message.data]);\n" +
      "          break;\n" +
      "        case 'USER_LEFT':\n" +
      "          this.onlineUsersState.update(users => \n" +
      "            users.filter(u => u.id !== message.data.id)\n" +
      "          );\n" +
      "          break;\n" +
      "      }\n" +
      "    });\n" +
      "  }\n\n" +
      "  sendMessage(text: string) {\n" +
      "    this.socket$.next({ type: 'SEND_MESSAGE', text });\n" +
      "  }\n\n" +
      "  disconnect() {\n" +
      "    this.socket$.complete();\n" +
      "    this.connectedState.set(false);\n" +
      "  }\n" +
      "}\n\n" +
      "// Component\n" +
      "@Component({\n" +
      "  template: `\n" +
      "    @if (ws.connected()) {\n" +
      '      <span class="status online">Connected</span>\n' +
      "    } @else {\n" +
      '      <span class="status offline">Disconnected</span>\n' +
      "    }\n\n" +
      '    <div class="online-users">\n' +
      "      <p>Online: {{ ws.onlineCount() }}</p>\n" +
      "      @for (user of ws.onlineUsers(); track user.id) {\n" +
      "        <span>{{ user.name }}</span>\n" +
      "      }\n" +
      "    </div>\n\n" +
      '    <div class="messages">\n' +
      "      @for (msg of ws.messages(); track msg.id) {\n" +
      '        <div class="message">{{ msg.text }}</div>\n' +
      "      }\n" +
      "    </div>\n\n" +
      "    <input #input (keyup.enter)=\"sendMessage(input.value); input.value = ''\" />\n" +
      "  `\n" +
      "})\n" +
      "export class ChatComponent {\n" +
      "  ws = inject(SignalWebSocketService);\n\n" +
      "  ngOnInit() {\n" +
      "    this.ws.connect();\n" +
      "  }\n\n" +
      "  ngOnDestroy() {\n" +
      "    this.ws.disconnect();\n" +
      "  }\n\n" +
      "  sendMessage(text: string) {\n" +
      "    if (text.trim()) {\n" +
      "      this.ws.sendMessage(text);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Signals WebSocket",
    difficulty: "hard",
    tags: ["signals", "websocket", "real-time", "chat"],
  },
  {
    id: 112,
    question: "How do you implement Undo/Redo with Signals?",
    answer:
      "**Undo/Redo Pattern with Signals:**\n\n" +
      "```typescript\n" +
      "interface HistoryState<T> {\n" +
      "  past: T[];\n" +
      "  present: T;\n" +
      "  future: T[];\n" +
      "}\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class UndoableService<T> {\n" +
      "  private historyState = signal<HistoryState<T>>({\n" +
      "    past: [],\n" +
      "    present: null as T,\n" +
      "    future: []\n" +
      "  });\n\n" +
      "  // Current state\n" +
      "  current = computed(() => this.historyState().present);\n\n" +
      "  // Can undo/redo?\n" +
      "  canUndo = computed(() => this.historyState().past.length > 0);\n" +
      "  canRedo = computed(() => this.historyState().future.length > 0);\n\n" +
      "  // Initialize\n" +
      "  init(initialValue: T) {\n" +
      "    this.historyState.set({\n" +
      "      past: [],\n" +
      "      present: initialValue,\n" +
      "      future: []\n" +
      "    });\n" +
      "  }\n\n" +
      "  // Update (adds to history)\n" +
      "  update(newValue: T) {\n" +
      "    this.historyState.update(state => ({\n" +
      "      past: [...state.past, state.present],\n" +
      "      present: newValue,\n" +
      "      future: [] // Clear redo history\n" +
      "    }));\n" +
      "  }\n\n" +
      "  // Undo\n" +
      "  undo() {\n" +
      "    if (!this.canUndo()) return;\n\n" +
      "    this.historyState.update(state => ({\n" +
      "      past: state.past.slice(0, -1),\n" +
      "      present: state.past[state.past.length - 1],\n" +
      "      future: [state.present, ...state.future]\n" +
      "    }));\n" +
      "  }\n\n" +
      "  // Redo\n" +
      "  redo() {\n" +
      "    if (!this.canRedo()) return;\n\n" +
      "    this.historyState.update(state => ({\n" +
      "      past: [...state.past, state.present],\n" +
      "      present: state.future[0],\n" +
      "      future: state.future.slice(1)\n" +
      "    }));\n" +
      "  }\n\n" +
      "  // Clear history\n" +
      "  clearHistory() {\n" +
      "    this.historyState.update(state => ({\n" +
      "      past: [],\n" +
      "      present: state.present,\n" +
      "      future: []\n" +
      "    }));\n" +
      "  }\n" +
      "}\n\n" +
      "// Usage: Text Editor\n" +
      "@Component({\n" +
      "  template: `\n" +
      '    <div class="toolbar">\n' +
      '      <button (click)="history.undo()" [disabled]="!history.canUndo()">\n' +
      "        Undo\n" +
      "      </button>\n" +
      '      <button (click)="history.redo()" [disabled]="!history.canRedo()">\n' +
      "        Redo\n" +
      "      </button>\n" +
      "    </div>\n\n" +
      "    <textarea \n" +
      '      [value]="history.current()" \n' +
      '      (input)="onTextChange($any($event.target).value)">\n' +
      "    </textarea>\n" +
      "  `\n" +
      "})\n" +
      "export class EditorComponent {\n" +
      "  history = new UndoableService<string>();\n\n" +
      "  ngOnInit() {\n" +
      "    this.history.init('');\n" +
      "  }\n\n" +
      "  onTextChange(text: string) {\n" +
      "    this.history.update(text);\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Signals Undo/Redo",
    difficulty: "hard",
    tags: ["signals", "undo-redo", "history", "state-management"],
  },
  {
    id: 113,
    question: "How do you implement Filtering, Sorting, and Multi-selection with Signals?",
    answer:
      "**Advanced Data Manipulation with Signals:**\n\n" +
      "```typescript\n" +
      "@Component({\n" +
      "  selector: 'app-users-table',\n" +
      "  template: `\n" +
      "    <!-- Filters -->\n" +
      "    <input \n" +
      '      [value]="searchQuery()" \n' +
      '      (input)="searchQuery.set($any($event.target).value)" \n' +
      '      placeholder="Search..." />\n\n' +
      '    <select [value]="statusFilter()" (change)="statusFilter.set($any($event.target).value)">\n' +
      '      <option value="">All</option>\n' +
      '      <option value="active">Active</option>\n' +
      '      <option value="inactive">Inactive</option>\n' +
      "    </select>\n\n" +
      "    <!-- Sorting -->\n" +
      "    <button (click)=\"toggleSort('name')\">Sort by Name</button>\n" +
      "    <button (click)=\"toggleSort('email')\">Sort by Email</button>\n\n" +
      "    <!-- Select All -->\n" +
      "    <input \n" +
      '      type="checkbox" \n' +
      '      [checked]="allSelected()" \n' +
      '      (change)="toggleSelectAll()" />\n\n' +
      "    <p>{{ selectedCount() }} selected</p>\n\n" +
      "    <!-- Data Table -->\n" +
      "    @for (user of displayedUsers(); track user.id) {\n" +
      '      <div class="row" [class.selected]="isSelected(user.id)">\n' +
      "        <input \n" +
      '          type="checkbox"\n' +
      '          [checked]="isSelected(user.id)"\n' +
      '          (change)="toggleSelect(user.id)" />\n' +
      "        <span>{{ user.name }}</span>\n" +
      "        <span>{{ user.email }}</span>\n" +
      "      </div>\n" +
      "    } @empty {\n" +
      "      <p>No users found</p>\n" +
      "    }\n\n" +
      "    @if (selectedCount() > 0) {\n" +
      '      <button (click)="deleteSelected()">Delete Selected</button>\n' +
      "    }\n" +
      "  `\n" +
      "})\n" +
      "export class UsersTableComponent {\n" +
      "  // Raw data\n" +
      "  allUsers = signal<User[]>([]);\n\n" +
      "  // Filters\n" +
      "  searchQuery = signal('');\n" +
      "  statusFilter = signal('');\n\n" +
      "  // Sorting\n" +
      "  sortField = signal<keyof User | null>(null);\n" +
      "  sortDirection = signal<'asc' | 'desc'>('asc');\n\n" +
      "  // Selection\n" +
      "  selectedIds = signal<Set<number>>(new Set());\n\n" +
      "  // Computed: Filtered\n" +
      "  filteredUsers = computed(() => {\n" +
      "    let users = this.allUsers();\n" +
      "    const query = this.searchQuery().toLowerCase();\n" +
      "    const status = this.statusFilter();\n\n" +
      "    if (query) {\n" +
      "      users = users.filter(u => \n" +
      "        u.name.toLowerCase().includes(query) ||\n" +
      "        u.email.toLowerCase().includes(query)\n" +
      "      );\n" +
      "    }\n\n" +
      "    if (status) {\n" +
      "      users = users.filter(u => u.status === status);\n" +
      "    }\n\n" +
      "    return users;\n" +
      "  });\n\n" +
      "  // Computed: Sorted\n" +
      "  displayedUsers = computed(() => {\n" +
      "    const users = [...this.filteredUsers()];\n" +
      "    const field = this.sortField();\n" +
      "    const dir = this.sortDirection();\n\n" +
      "    if (!field) return users;\n\n" +
      "    return users.sort((a, b) => {\n" +
      "      const aVal = a[field];\n" +
      "      const bVal = b[field];\n" +
      "      const result = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;\n" +
      "      return dir === 'asc' ? result : -result;\n" +
      "    });\n" +
      "  });\n\n" +
      "  // Computed: Selection\n" +
      "  selectedCount = computed(() => this.selectedIds().size);\n" +
      "  allSelected = computed(() => {\n" +
      "    const users = this.displayedUsers();\n" +
      "    return users.length > 0 && users.every(u => this.selectedIds().has(u.id));\n" +
      "  });\n\n" +
      "  toggleSort(field: keyof User) {\n" +
      "    if (this.sortField() === field) {\n" +
      "      this.sortDirection.update(dir => dir === 'asc' ? 'desc' : 'asc');\n" +
      "    } else {\n" +
      "      this.sortField.set(field);\n" +
      "      this.sortDirection.set('asc');\n" +
      "    }\n" +
      "  }\n\n" +
      "  toggleSelect(id: number) {\n" +
      "    this.selectedIds.update(ids => {\n" +
      "      const newIds = new Set(ids);\n" +
      "      if (newIds.has(id)) {\n" +
      "        newIds.delete(id);\n" +
      "      } else {\n" +
      "        newIds.add(id);\n" +
      "      }\n" +
      "      return newIds;\n" +
      "    });\n" +
      "  }\n\n" +
      "  toggleSelectAll() {\n" +
      "    if (this.allSelected()) {\n" +
      "      this.selectedIds.set(new Set());\n" +
      "    } else {\n" +
      "      const allIds = this.displayedUsers().map(u => u.id);\n" +
      "      this.selectedIds.set(new Set(allIds));\n" +
      "    }\n" +
      "  }\n\n" +
      "  isSelected(id: number) {\n" +
      "    return this.selectedIds().has(id);\n" +
      "  }\n\n" +
      "  deleteSelected() {\n" +
      "    const ids = Array.from(this.selectedIds());\n" +
      "    this.allUsers.update(users => users.filter(u => !ids.includes(u.id)));\n" +
      "    this.selectedIds.set(new Set());\n" +
      "  }\n" +
      "}\n" +
      "```",
    category: "Signals Data Tables",
    difficulty: "hard",
    tags: ["signals", "filtering", "sorting", "selection", "tables"],
  },
  {
    id: 114,
    question: "How do you implement Dark Mode and Theme Switching with Signals?",
    answer:
      "**Theme Service with Signals:**\n\n" +
      "```typescript\n" +
      "type Theme = 'light' | 'dark' | 'auto';\n\n" +
      "@Injectable({ providedIn: 'root' })\n" +
      "export class ThemeService {\n" +
      "  private themeState = signal<Theme>('auto');\n" +
      "  private systemPrefersDark = signal(false);\n\n" +
      "  theme = this.themeState.asReadonly();\n\n" +
      "  // Computed: Actual applied theme\n" +
      "  appliedTheme = computed(() => {\n" +
      "    const theme = this.theme();\n" +
      "    if (theme === 'auto') {\n" +
      "      return this.systemPrefersDark() ? 'dark' : 'light';\n" +
      "    }\n" +
      "    return theme;\n" +
      "  });\n\n" +
      "  isDark = computed(() => this.appliedTheme() === 'dark');\n\n" +
      "  constructor() {\n" +
      "    // Load from localStorage\n" +
      "    const saved = localStorage.getItem('theme') as Theme;\n" +
      "    if (saved) {\n" +
      "      this.themeState.set(saved);\n" +
      "    }\n\n" +
      "    // Watch system preference\n" +
      "    const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');\n" +
      "    this.systemPrefersDark.set(darkModeQuery.matches);\n\n" +
      "    darkModeQuery.addEventListener('change', e => {\n" +
      "      this.systemPrefersDark.set(e.matches);\n" +
      "    });\n\n" +
      "    // Apply theme to DOM\n" +
      "    effect(() => {\n" +
      "      const isDark = this.isDark();\n" +
      "      document.documentElement.classList.toggle('dark', isDark);\n" +
      "      document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');\n" +
      "    });\n" +
      "  }\n\n" +
      "  setTheme(theme: Theme) {\n" +
      "    this.themeState.set(theme);\n" +
      "    localStorage.setItem('theme', theme);\n" +
      "  }\n\n" +
      "  toggle() {\n" +
      "    const current = this.appliedTheme();\n" +
      "    this.setTheme(current === 'dark' ? 'light' : 'dark');\n" +
      "  }\n" +
      "}\n\n" +
      "// Theme Switcher Component\n" +
      "@Component({\n" +
      "  selector: 'app-theme-switcher',\n" +
      "  standalone: true,\n" +
      "  template: `\n" +
      '    <div class="theme-switcher">\n' +
      "      <button (click)=\"theme.setTheme('light')\" [class.active]=\"theme.theme() === 'light'\">\n" +
      "        ☀️ Light\n" +
      "      </button>\n" +
      "      <button (click)=\"theme.setTheme('dark')\" [class.active]=\"theme.theme() === 'dark'\">\n" +
      "        🌙 Dark\n" +
      "      </button>\n" +
      "      <button (click)=\"theme.setTheme('auto')\" [class.active]=\"theme.theme() === 'auto'\">\n" +
      "        🔄 Auto\n" +
      "      </button>\n" +
      "    </div>\n" +
      "    <p>Current: {{ theme.appliedTheme() }}</p>\n" +
      "  `\n" +
      "})\n" +
      "export class ThemeSwitcherComponent {\n" +
      "  theme = inject(ThemeService);\n" +
      "}\n\n" +
      "// CSS (Tailwind dark mode)\n" +
      "// tailwind.config.js\n" +
      "module.exports = {\n" +
      "  darkMode: 'class', // Use class-based dark mode\n" +
      "  // ...\n" +
      "}\n\n" +
      "// CSS Variables approach\n" +
      ":root {\n" +
      "  --bg-color: white;\n" +
      "  --text-color: black;\n" +
      "}\n\n" +
      ".dark {\n" +
      "  --bg-color: #1a1a1a;\n" +
      "  --text-color: white;\n" +
      "}\n" +
      "```",
    category: "Signals Theming",
    difficulty: "intermediate",
    tags: ["signals", "dark-mode", "theme", "ux"],
  },
  {
    id: 115,
    question:
      "What are Angular Signals Best Practices? Summarize patterns, pitfalls, and migration strategy.",
    answer:
      "**Best Practices:**\n\n" +
      "```typescript\n" +
      "1. **Use signals() for state, computed() for derived values**\n" +
      "   count = signal(0);\n" +
      "   doubleCount = computed(() => this.count() * 2);\n\n" +
      "2. **Make writable signals private, expose readonly**\n" +
      "   private countState = signal(0);\n" +
      "   count = this.countState.asReadonly();\n\n" +
      "3. **Use effect() only for side effects, not state changes**\n" +
      "   // ✅ Good\n" +
      "   effect(() => console.log(this.count()));\n" +
      "   \n" +
      "   // ❌ Bad\n" +
      "   effect(() => this.otherSignal.set(this.count()));\n\n" +
      "4. **Use input() instead of @Input() for new components**\n" +
      "   userId = input.required<number>();\n\n" +
      "5. **Use model() for two-way binding**\n" +
      "   value = model(0);\n\n" +
      "6. **Use viewChild() instead of @ViewChild()**\n" +
      "   inputElement = viewChild<ElementRef>('input');\n\n" +
      "7. **Keep computed() pure (no side effects)**\n" +
      "   // ✅ Good\n" +
      "   fullName = computed(() => `${this.first()} ${this.last()}`);\n" +
      "   \n" +
      "   // ❌ Bad\n" +
      "   badComputed = computed(() => {\n" +
      "     this.http.get('/api').subscribe(); // NO!\n" +
      "     return this.value();\n" +
      "   });\n\n" +
      "8. **Signals are synchronous**\n" +
      "   this.count.set(5);\n" +
      "   console.log(this.count()); // 5 immediately\n\n" +
      "9. **Use toSignal() for observables in templates**\n" +
      "   users = toSignal(this.http.get<User[]>('/api/users'), { initialValue: [] });\n\n" +
      "10. **Combine with RxJS when needed**\n" +
      "    toObservable(this.searchQuery)\n" +
      "      .pipe(debounceTime(300))\n" +
      "      .subscribe(...);\n" +
      "```\n\n" +
      "**Common Pitfalls:**\n\n" +
      "```typescript\n" +
      "// ❌ 1. Forgetting to call signal\n" +
      "if (this.count > 5) { } // Wrong!\n" +
      "if (this.count() > 5) { } // Correct\n\n" +
      "// ❌ 2. Mutating signal value\n" +
      "this.users().push(newUser); // Wrong!\n" +
      "this.users.update(u => [...u, newUser]); // Correct\n\n" +
      "// ❌ 3. Using effect() for derived state\n" +
      "effect(() => this.total.set(this.items().length)); // Wrong!\n" +
      "total = computed(() => this.items().length); // Correct\n\n" +
      "// ❌ 4. Async operations in computed()\n" +
      "computed(() => {\n" +
      "  this.http.get('/api').subscribe(); // Wrong!\n" +
      "  return this.value();\n" +
      "});\n" +
      "```\n\n" +
      "**Migration Strategy:**\n\n" +
      "```typescript\n" +
      "// Before (Observables)\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  @Input() userId: number;\n" +
      "  @Output() userChanged = new EventEmitter<User>();\n" +
      "  @ViewChild('input') input: ElementRef;\n\n" +
      "  user$ = new BehaviorSubject<User | null>(null);\n" +
      "  loading$ = new BehaviorSubject(false);\n\n" +
      "  ngOnInit() {\n" +
      "    this.loadUser();\n" +
      "  }\n" +
      "}\n\n" +
      "// After (Signals)\n" +
      "@Component({...})\n" +
      "export class Component {\n" +
      "  userId = input.required<number>();\n" +
      "  userChanged = output<User>();\n" +
      "  inputElement = viewChild<ElementRef>('input');\n\n" +
      "  user = signal<User | null>(null);\n" +
      "  loading = signal(false);\n\n" +
      "  constructor() {\n" +
      "    // Auto-load when userId changes\n" +
      "    effect(() => this.loadUser(this.userId()));\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**When to Use Signals:**\n" +
      "✅ New components\n" +
      "✅ Local state management\n" +
      "✅ Derived/computed values\n" +
      "✅ View queries\n" +
      "✅ Component inputs/outputs\n\n" +
      "**When to Keep RxJS:**\n" +
      "✅ Complex async flows\n" +
      "✅ Existing large codebases\n" +
      "✅ Time-based operators (debounce, throttle)\n" +
      "✅ HTTP interceptors\n\n" +
      "**The Future:**\n" +
      "- Signals are the future of Angular reactivity\n" +
      "- Gradually migrate existing code\n" +
      "- Use signals for new features\n" +
      "- RxJS and Signals work together!",
    category: "Signals Best Practices",
    difficulty: "hard",
    tags: ["signals", "best-practices", "migration", "patterns"],
  },

  {
    id: 117,
    question: "What are Angular elements?",
    answer:
      "Angular elements are Angular components packaged as custom elements (a web standard for defining new HTML elements in a framework-agnostic way). Angular Elements host an Angular component, providing a bridge between the data and the logic defined in the component and the standard DOM APIs, thus, providing a way to use Angular components in non-Angular environments.",
    category: "Angular Elements",
    difficulty: "easy",
    tags: ["angular", "elements"],
  },
  {
    id: 118,
    question: "What is the browser support of Angular Elements?",
    answer:
      "Since Angular elements are packaged as custom elements the browser support of angular elements is same as custom elements support.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 119,
    question: "What are custom elements?",
    answer:
      "Custom elements (or Web Components) are a Web Platform feature which extends HTML by allowing you to define a tag whose content is created and controlled by JavaScript code. The browser maintains a CustomElementRegistry of defined custom elements, which maps an instantiable JavaScript class to an HTML tag. Currently this feature is supported by Chrome, Firefox, Opera, and Safari, and available in other browsers through polyfills.",
    category: "Angular Elements",
    difficulty: "hard",
    tags: ["elements"],
  },
  {
    id: 120,
    question: "Do I need to bootstrap custom elements?",
    answer:
      "No, custom elements bootstrap (or start) automatically when they are added to the DOM, and are automatically destroyed when removed from the DOM. Once a custom element is added to the DOM for any page, it looks and behaves like any other HTML element, and does not require any special knowledge of Angular.",
    category: "Angular Elements",
    difficulty: "hard",
    tags: ["elements"],
  },
  {
    id: 121,
    question: "Explain how custom elements works internally?",
    answer: "Below are the steps in an order about custom elements functionality,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 122,
    question: "How to transfer components to custom elements?",
    answer: "Transforming components to custom elements involves two major steps,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 123,
    question: "What are the mapping rules between Angular component and custom element?",
    answer:
      "The Component properties and logic maps directly into HTML attributes and the browser's event system. Let us describe them in two steps,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 124,
    question: "How do you define typings for custom elements?",
    answer: "You can use the NgElement and WithProperties types exported from @angular/elements.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 125,
    question: "What are dynamic components?",
    answer:
      "Dynamic components are the components in which the component's location in the application is not defined at build time i.e. they are not used in any angular template. Instead, the component is instantiated and placed in the application at runtime.",
    category: "Components",
    difficulty: "easy",
    tags: ["component"],
  },
  {
    id: 126,
    question: "What are the various kinds of directives?",
    answer: "There are mainly three kinds of directives:",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 127,
    question: "How do you create directives using CLI?",
    answer:
      "You can use CLI command ng generate directive to create the directive class file. It creates the source file(src/app/components/directivename.directive.ts), the respective test file .spec.ts and declare the directive class file in root module.",
    category: "Directives",
    difficulty: "easy",
    tags: ["cli", "directive", "di"],
  },
  {
    id: 128,
    question: "Give an example for attribute directives?",
    answer:
      "Let's take simple highlighter behavior as a example directive for DOM element. You can create and apply the attribute directive using below step:",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 129,
    question: "What is Angular Router?",
    answer:
      "Angular Router is a mechanism in which navigation happens from one view to the next as users perform application tasks. It borrows the concepts or model of browser's application navigation. It enables developers to build Single Page Applications with multiple views and allow navigation between these views.",
    category: "Routing",
    difficulty: "intermediate",
    tags: ["angular", "router"],
  },
  {
    id: 130,
    question: "What is the purpose of base href tag?",
    answer:
      "The routing application should add element to the index.html as the first child in the tag in order to indicate how to compose navigation URLs. If app folder is the application root then you can set the href value as below",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 131,
    question: "What are the router imports?",
    answer:
      "The Angular Router which represents a particular component view for a given URL is not part of Angular Core. It is available in library named @angular/router to import required router components. For example, we import them in app module as below,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 132,
    question: "What is router outlet?",
    answer:
      "The RouterOutlet is a directive from the router library and it acts as a placeholder that marks the spot in the template where the router should display the components for that outlet. Router outlet is used like a component,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 133,
    question: "What are router links?",
    answer:
      "The RouterLink is a directive on the anchor tags give the router control over those elements. Since the navigation paths are fixed, you can assign string values to router-link directive as below,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 134,
    question: "What are active router links?",
    answer:
      "RouterLinkActive is a directive that toggles css classes for active RouterLink bindings based on the current RouterState. i.e, The Router will add CSS classes when this link is active and remove when the link is inactive. For example, you can add them to RouterLinks as below.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 135,
    question: "What is router state?",
    answer:
      "RouterState is a tree of activated routes. Every node in this tree knows about the consumed URL segments, the extracted parameters, and the resolved data. You can access the current RouterState from anywhere in the application using the Router service and the routerState property.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 136,
    question: "What are router events?",
    answer:
      "During each navigation, the Router emits navigation events through the Router.events property allowing you to track the lifecycle of the route.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 137,
    question: "What is activated route?",
    answer:
      "ActivatedRoute contains the information about a route associated with a component loaded in an outlet. It can also be used to traverse the router state tree. The ActivatedRoute will be injected as a router service to access the information. In the below example, you can access route path and parameters,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 138,
    question: "How do you define routes?",
    answer:
      "A router must be configured with a list of route definitions. You configures the router with routes via the RouterModule.forRoot() method, and adds the result to the AppModule's imports array.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 139,
    question: "What is the purpose of Wildcard route?",
    answer:
      "If the URL doesn't match any predefined routes then it causes the router to throw an error and crash the app. In this case, you can use wildcard route. A wildcard route has a path consisting of two asterisks to match every URL.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 140,
    question: "Do I need a Routing Module always?",
    answer:
      "No, the Routing Module is a design choice. You can skip routing Module (for example, AppRoutingModule) when the configuration is simple and merge the routing configuration directly into the companion module (for example, AppModule). But it is recommended when the configuration is complex and includes specialized guard and resolver services.",
    category: "Modules",
    difficulty: "easy",
    tags: ["module"],
  },
  {
    id: 141,
    question: "What is Angular Universal?",
    answer:
      "Angular Universal is a server-side rendering module for Angular applications in various scenarios. This is a community driven project and available under @angular/platform-server package. Recently Angular Universal is integrated with Angular CLI.",
    category: "Angular Basics",
    difficulty: "easy",
    tags: ["angular"],
  },
  {
    id: 142,
    question: "What are different types of compilation in Angular?",
    answer: "Angular offers two ways to compile your application,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 143,
    question: "What is JIT?",
    answer:
      "Just-in-Time (JIT) is a type of compilation that compiles your app in the browser at runtime. JIT compilation was the default until Angular 8, now default is AOT. When you run the ng build (build only) or ng serve (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the aot property in your build configuration specified in angular.json. By default, aot is set to true.",
    category: "Compilation/AOT",
    difficulty: "hard",
    tags: ["jit"],
  },
  {
    id: 144,
    question: "What is AOT?",
    answer:
      "Ahead-of-Time (AOT) is a type of compilation that compiles your app at build time. This is the default starting in Angular 9. When you run the ng build (build only) or ng serve (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the aot property in your build configuration specified in angular.json. By default, aot is set to true.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 145,
    question: "Why do we need compilation process?",
    answer:
      "The Angular components and templates cannot be understood by the browser directly. Due to that Angular applications require a compilation process before they can run in a browser. For example, In AOT compilation, both Angular HTML and TypeScript code converted into efficient JavaScript code during the build phase before browser runs it.",
    category: "Compilation/AOT",
    difficulty: "easy",
    tags: ["angular"],
  },
  {
    id: 146,
    question: "What are the advantages with AOT?",
    answer: "Below are the list of AOT benefits,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 147,
    question: "What are the ways to control AOT compilation?",
    answer: "You can control your app compilation in two ways,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 148,
    question: "What are the restrictions of metadata?",
    answer: "In Angular, You must write metadata with the following general constraints,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 149,
    question: "What are the three phases of AOT?",
    answer: "The AOT compiler works in three phases,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 150,
    question: "Can I use arrow functions in AOT?",
    answer:
      "No, Arrow functions or lambda functions can’t be used to assign values to the decorator properties. For example, the following snippet is invalid:",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 151,
    question: "What is the purpose of metadata json files?",
    answer:
      "The metadata.json file can be treated as a diagram of the overall structure of a decorator's metadata, represented as an abstract syntax tree(AST). During the analysis phase, the AOT collector scan the metadata recorded in the Angular decorators and outputs metadata information in .metadata.json files, one per .d.ts file.",
    category: "Compilation/AOT",
    difficulty: "hard",
    tags: ["angular"],
  },
  {
    id: 152,
    question: "Can I use any javascript feature for expression syntax in AOT?",
    answer:
      "No, the AOT collector understands a subset of (or limited) JavaScript features. If an expression uses unsupported syntax, the collector writes an error node to the .metadata.json file. Later point of time, the compiler reports an error if it needs that piece of metadata to generate the application code.",
    category: "Compilation/AOT",
    difficulty: "hard",
    tags: ["aot"],
  },
  {
    id: 153,
    question: "What is folding?",
    answer:
      "The compiler can only resolve references to exported symbols in the metadata. Where as some of the non-exported members are folded while generating the code. i.e Folding is a process in which the collector evaluate an expression during collection and record the result in the .metadata.json instead of the original expression. For example, the compiler couldn't refer selector reference because it is not exported",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 154,
    question: "What are macros?",
    answer:
      "The AOT compiler supports macros in the form of functions or static methods that return an expression in a single return expression. For example, let us take a below macro function,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 155,
    question: "Give an example of few metadata errors?",
    answer: "Below are some of the errors encountered in metadata,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 156,
    question: "What is metadata rewriting?",
    answer:
      "Metadata rewriting is the process in which the compiler converts the expression initializing the fields such as useClass, useValue, useFactory, and data into an exported variable, which replaces the expression. Remember that the compiler does this rewriting during the emit of the .js file but not in definition files( .d.ts file).",
    category: "Compilation/AOT",
    difficulty: "hard",
    tags: ["angular"],
  },
  {
    id: 157,
    question: "How do you provide configuration inheritance?",
    answer:
      "Angular Compiler supports configuration inheritance through extends in the tsconfig.json on angularCompilerOptions. i.e, The configuration from the base file(for example, tsconfig.base.json) are loaded first, then overridden by those in the inheriting config file.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 158,
    question: "How do you specify angular template compiler options?",
    answer:
      "The angular template compiler options are specified as members of the angularCompilerOptions object in the tsconfig.json file. These options will be specified adjacent to typescript compiler options.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 159,
    question: "How do you enable binding expression validation?",
    answer:
      "You can enable binding expression validation explicitly by adding the compiler option fullTemplateTypeCheck in the angularCompilerOptions of the project's tsconfig.json. It produces error messages when a type error is detected in a template binding expression.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 160,
    question: "What is the purpose of any type cast function?",
    answer:
      "You can disable binding expression type checking using $any() type cast function(by surrounding the expression). In the following example, the error Property contacts does not exist is suppressed by casting user to the any type.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 161,
    question: "What is Non null type assertion operator?",
    answer:
      "You can use the non-null type assertion operator to suppress the Object is possibly 'undefined' error. In the following example, the user and contact properties are always set together, implying that contact is always non-null if user is non-null. The error is suppressed in the example by using contact!.email.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 162,
    question: "How is type narrowing applied in templates?",
    answer:
      "The expression used in an ngIf directive is used to narrow type unions in the Angular template compiler similar to if expression in typescript. So *ngIf allows the typeScript compiler to infer that the data used in the binding expression will never be undefined.",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 163,
    question: "How do you describe various dependencies in angular application?",
    answer:
      "The dependencies section of package.json with in an angular application can be divided as follow,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 164,
    question: "What is zone?",
    answer:
      "A Zone is an execution context that persists across async tasks. Angular relies on zone.js to run Angular's change detection processes when native JavaScript operations raise events",
    category: "Dependency Injection",
    difficulty: "intermediate",
    tags: ["zone"],
  },
  {
    id: 165,
    question: "What is the purpose of common module?",
    answer:
      "The commonly-needed services, pipes, and directives provided by @angular/common module. Apart from these HttpClientModule is available under @angular/common/http.",
    category: "Modules",
    difficulty: "easy",
    tags: ["module"],
  },
  {
    id: 166,
    question: "What is codelyzer?",
    answer:
      "Codelyzer provides set of tslint rules for static code analysis of Angular TypeScript projects. You can run the static code analyzer over web apps, NativeScript, Ionic etc. Angular CLI has support for this and it can be use as below,",
    category: "General",
    difficulty: "intermediate",
    tags: ["general"],
  },
  {
    id: 167,
    question: "What are the key differences between template-driven and reactive forms in Angular?",
    answer:
      "Template-driven and reactive forms are two different approaches to handling forms in Angular, each with distinct characteristics:\n\n" +
      "**Template-Driven Forms:**\n" +
      "```typescript\n" +
      "// Template-driven form example\n" +
      "// app.component.html\n" +
      '<form #userForm="ngForm" (ngSubmit)="onSubmit(userForm)">\n' +
      '  <div class="form-group">\n' +
      '    <label for="name">Name:</label>\n' +
      "    <input \n" +
      '      type="text" \n' +
      '      id="name" \n' +
      '      name="name" \n' +
      "      ngModel \n" +
      "      required \n" +
      '      #name="ngModel"\n' +
      '      [class.is-invalid]="name.invalid && name.touched"\n' +
      "    />\n" +
      '    <div *ngIf="name.invalid && name.touched" class="invalid-feedback">\n' +
      "      Name is required\n" +
      "    </div>\n" +
      "  </div>\n" +
      "  \n" +
      '  <div class="form-group">\n' +
      '    <label for="email">Email:</label>\n' +
      "    <input \n" +
      '      type="email" \n' +
      '      id="email" \n' +
      '      name="email" \n' +
      "      ngModel \n" +
      "      required \n" +
      "      email \n" +
      '      #email="ngModel"\n' +
      "    />\n" +
      "  </div>\n" +
      "  \n" +
      '  <button type="submit" [disabled]="userForm.invalid">Submit</button>\n' +
      "</form>\n" +
      "```\n\n" +
      "```typescript\n" +
      "// app.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "import { NgForm } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-root',\n" +
      "  templateUrl: './app.component.html'\n" +
      "})\n" +
      "export class AppComponent {\n" +
      "  onSubmit(form: NgForm) {\n" +
      "    if (form.valid) {\n" +
      "      console.log('Form submitted:', form.value);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Reactive Forms:**\n" +
      "```typescript\n" +
      "// Reactive form example\n" +
      "// app.component.ts\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { FormBuilder, FormGroup, Validators } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-root',\n" +
      "  templateUrl: './app.component.html'\n" +
      "})\n" +
      "export class AppComponent implements OnInit {\n" +
      "  userForm: FormGroup;\n" +
      "\n" +
      "  constructor(private fb: FormBuilder) {}\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    this.userForm = this.fb.group({\n" +
      "      name: ['', [Validators.required]],\n" +
      "      email: ['', [Validators.required, Validators.email]]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  onSubmit() {\n" +
      "    if (this.userForm.valid) {\n" +
      "      console.log('Form submitted:', this.userForm.value);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "```html\n" +
      "<!-- app.component.html -->\n" +
      '<form [formGroup]="userForm" (ngSubmit)="onSubmit()">\n' +
      '  <div class="form-group">\n' +
      '    <label for="name">Name:</label>\n' +
      "    <input \n" +
      '      type="text" \n' +
      '      id="name" \n' +
      '      formControlName="name"\n' +
      "      [class.is-invalid]=\"userForm.get('name')?.invalid && userForm.get('name')?.touched\"\n" +
      "    />\n" +
      "    <div *ngIf=\"userForm.get('name')?.invalid && userForm.get('name')?.touched\" class=\"invalid-feedback\">\n" +
      "      Name is required\n" +
      "    </div>\n" +
      "  </div>\n" +
      "  \n" +
      '  <div class="form-group">\n' +
      '    <label for="email">Email:</label>\n' +
      "    <input \n" +
      '      type="email" \n' +
      '      id="email" \n' +
      '      formControlName="email"\n' +
      "    />\n" +
      "  </div>\n" +
      "  \n" +
      '  <button type="submit" [disabled]="userForm.invalid">Submit</button>\n' +
      "</form>\n" +
      "```\n\n" +
      "**Key Differences:**\n" +
      "1. **Data Model**: Template-driven uses data binding, reactive uses FormControl/FormGroup\n" +
      "2. **Validation**: Template-driven uses template directives, reactive uses validator functions\n" +
      "3. **Immutability**: Template-driven mutates data model, reactive uses immutable approach\n" +
      "4. **Testing**: Reactive forms are easier to unit test\n" +
      "5. **Complexity**: Template-driven is simpler for basic forms, reactive is better for complex forms\n" +
      "6. **Performance**: Reactive forms have better performance for large forms\n" +
      "7. **Type Safety**: Reactive forms provide better TypeScript support",
    category: "Forms",
    difficulty: "intermediate",
    tags: ["forms", "template-driven", "reactive", "validation"],
  },
  {
    id: 168,
    question:
      "How do you create and manage FormControl, FormGroup, and FormArray in reactive forms?",
    answer:
      "Reactive forms provide three fundamental building blocks for form management:\n\n" +
      "**FormControl:**\n" +
      "```typescript\n" +
      "import { FormControl } from '@angular/forms';\n" +
      "\n" +
      "// Creating a FormControl\n" +
      "const nameControl = new FormControl('John');\n" +
      "const emailControl = new FormControl('', [Validators.required, Validators.email]);\n" +
      "\n" +
      "// With initial value and validators\n" +
      "const passwordControl = new FormControl('', {\n" +
      "  validators: [Validators.required, Validators.minLength(8)],\n" +
      "  updateOn: 'blur' // Update on blur instead of input\n" +
      "});\n" +
      "\n" +
      "// Accessing control properties\n" +
      "console.log(nameControl.value); // 'John'\n" +
      "console.log(nameControl.valid); // true\n" +
      "console.log(nameControl.errors); // null\n" +
      "console.log(nameControl.status); // 'VALID'\n" +
      "\n" +
      "// Setting values programmatically\n" +
      "nameControl.setValue('Jane');\n" +
      "nameControl.patchValue('Bob'); // Partial update\n" +
      "nameControl.reset(); // Reset to initial value\n" +
      "\n" +
      "// Subscribing to value changes\n" +
      "nameControl.valueChanges.subscribe(value => {\n" +
      "  console.log('Name changed:', value);\n" +
      "});\n" +
      "\n" +
      "nameControl.statusChanges.subscribe(status => {\n" +
      "  console.log('Status changed:', status);\n" +
      "});\n" +
      "```\n\n" +
      "**FormGroup:**\n" +
      "```typescript\n" +
      "import { FormGroup, FormControl, Validators } from '@angular/forms';\n" +
      "\n" +
      "// Creating FormGroup with FormBuilder\n" +
      "import { FormBuilder } from '@angular/forms';\n" +
      "\n" +
      "export class UserFormComponent {\n" +
      "  userForm: FormGroup;\n" +
      "\n" +
      "  constructor(private fb: FormBuilder) {\n" +
      "    this.userForm = this.fb.group({\n" +
      "      name: ['', [Validators.required]],\n" +
      "      email: ['', [Validators.required, Validators.email]],\n" +
      "      age: [null, [Validators.min(18), Validators.max(100)]]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Alternative: Manual FormGroup creation\n" +
      "  createFormManually() {\n" +
      "    this.userForm = new FormGroup({\n" +
      "      name: new FormControl('', [Validators.required]),\n" +
      "      email: new FormControl('', [Validators.required, Validators.email]),\n" +
      "      age: new FormControl(null, [Validators.min(18), Validators.max(100)])\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Accessing form controls\n" +
      "  get nameControl() {\n" +
      "    return this.userForm.get('name');\n" +
      "  }\n" +
      "\n" +
      "  get emailControl() {\n" +
      "    return this.userForm.get('email');\n" +
      "  }\n" +
      "\n" +
      "  // Form operations\n" +
      "  onSubmit() {\n" +
      "    if (this.userForm.valid) {\n" +
      "      console.log('Form value:', this.userForm.value);\n" +
      "      console.log('Form raw value:', this.userForm.getRawValue());\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Programmatic form updates\n" +
      "  updateForm() {\n" +
      "    // Set all values\n" +
      "    this.userForm.setValue({\n" +
      "      name: 'John Doe',\n" +
      "      email: 'john@example.com',\n" +
      "      age: 30\n" +
      "    });\n" +
      "\n" +
      "    // Partial update\n" +
      "    this.userForm.patchValue({\n" +
      "      name: 'Jane Doe'\n" +
      "    });\n" +
      "\n" +
      "    // Reset form\n" +
      "    this.userForm.reset();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**FormArray:**\n" +
      "```typescript\n" +
      "import { FormArray, FormControl, FormGroup } from '@angular/forms';\n" +
      "\n" +
      "export class DynamicFormComponent {\n" +
      "  userForm: FormGroup;\n" +
      "\n" +
      "  constructor(private fb: FormBuilder) {\n" +
      "    this.userForm = this.fb.group({\n" +
      "      name: ['', Validators.required],\n" +
      "      hobbies: this.fb.array([]), // Empty FormArray\n" +
      "      addresses: this.fb.array([\n" +
      "        this.createAddressGroup() // Initial address\n" +
      "      ])\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Create address FormGroup\n" +
      "  createAddressGroup(): FormGroup {\n" +
      "    return this.fb.group({\n" +
      "      street: ['', Validators.required],\n" +
      "      city: ['', Validators.required],\n" +
      "      zipCode: ['', Validators.required]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Get FormArray\n" +
      "  get hobbiesArray(): FormArray {\n" +
      "    return this.userForm.get('hobbies') as FormArray;\n" +
      "  }\n" +
      "\n" +
      "  get addressesArray(): FormArray {\n" +
      "    return this.userForm.get('addresses') as FormArray;\n" +
      "  }\n" +
      "\n" +
      "  // Add/Remove FormArray items\n" +
      "  addHobby() {\n" +
      "    this.hobbiesArray.push(new FormControl('', Validators.required));\n" +
      "  }\n" +
      "\n" +
      "  removeHobby(index: number) {\n" +
      "    this.hobbiesArray.removeAt(index);\n" +
      "  }\n" +
      "\n" +
      "  addAddress() {\n" +
      "    this.addressesArray.push(this.createAddressGroup());\n" +
      "  }\n" +
      "\n" +
      "  removeAddress(index: number) {\n" +
      "    this.addressesArray.removeAt(index);\n" +
      "  }\n" +
      "\n" +
      "  // Access FormArray controls\n" +
      "  getHobbyControl(index: number): FormControl {\n" +
      "    return this.hobbiesArray.at(index) as FormControl;\n" +
      "  }\n" +
      "\n" +
      "  getAddressGroup(index: number): FormGroup {\n" +
      "    return this.addressesArray.at(index) as FormGroup;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template Usage:**\n" +
      "```html\n" +
      "<!-- FormGroup template -->\n" +
      '<form [formGroup]="userForm" (ngSubmit)="onSubmit()">\n' +
      '  <input formControlName="name" placeholder="Name" />\n' +
      '  <input formControlName="email" placeholder="Email" />\n' +
      '  <input formControlName="age" placeholder="Age" />\n' +
      "  \n" +
      "  <!-- FormArray for hobbies -->\n" +
      '  <div formArrayName="hobbies">\n' +
      '    <div *ngFor="let hobby of hobbiesArray.controls; let i = index">\n' +
      '      <input [formControlName]="i" placeholder="Hobby {{i + 1}}" />\n' +
      '      <button type="button" (click)="removeHobby(i)">Remove</button>\n' +
      "    </div>\n" +
      '    <button type="button" (click)="addHobby()">Add Hobby</button>\n' +
      "  </div>\n" +
      "  \n" +
      "  <!-- FormArray for addresses -->\n" +
      '  <div formArrayName="addresses">\n' +
      '    <div *ngFor="let address of addressesArray.controls; let i = index" [formGroupName]="i">\n' +
      '      <input formControlName="street" placeholder="Street" />\n' +
      '      <input formControlName="city" placeholder="City" />\n' +
      '      <input formControlName="zipCode" placeholder="ZIP Code" />\n' +
      '      <button type="button" (click)="removeAddress(i)">Remove Address</button>\n' +
      "    </div>\n" +
      '    <button type="button" (click)="addAddress()">Add Address</button>\n' +
      "  </div>\n" +
      "  \n" +
      '  <button type="submit" [disabled]="userForm.invalid">Submit</button>\n' +
      "</form>\n" +
      "```\n\n" +
      "**Best Practices:**\n" +
      "- Use FormBuilder for cleaner code\n" +
      "- Implement proper validation\n" +
      "- Use FormArray for dynamic lists\n" +
      "- Subscribe to valueChanges for reactive updates\n" +
      "- Use getter methods for cleaner template access\n" +
      "- Implement proper error handling",
    category: "Forms",
    difficulty: "intermediate",
    tags: ["forms", "reactive", "FormControl", "FormGroup", "FormArray"],
  },
  {
    id: 169,
    question: "How do you implement custom validators in Angular reactive forms?",
    answer:
      "Custom validators in Angular reactive forms allow you to create reusable validation logic beyond the built-in validators:\n\n" +
      "**Basic Custom Validator:**\n" +
      "```typescript\n" +
      "import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\n" +
      "\n" +
      "// Simple custom validator function\n" +
      "export function noSpacesValidator(control: AbstractControl): ValidationErrors | null {\n" +
      "  if (control.value && control.value.includes(' ')) {\n" +
      "    return { noSpaces: { value: control.value } };\n" +
      "  }\n" +
      "  return null;\n" +
      "}\n" +
      "\n" +
      "// Validator factory function\n" +
      "export function minLengthValidator(minLength: number): ValidatorFn {\n" +
      "  return (control: AbstractControl): ValidationErrors | null => {\n" +
      "    if (control.value && control.value.length < minLength) {\n" +
      "      return { \n" +
      "        minLength: { \n" +
      "          requiredLength: minLength, \n" +
      "          actualLength: control.value.length \n" +
      "        } \n" +
      "      };\n" +
      "    }\n" +
      "    return null;\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "// Using custom validators\n" +
      "export class UserFormComponent {\n" +
      "  userForm: FormGroup;\n" +
      "\n" +
      "  constructor(private fb: FormBuilder) {\n" +
      "    this.userForm = this.fb.group({\n" +
      "      username: ['', [Validators.required, noSpacesValidator]],\n" +
      "      password: ['', [Validators.required, minLengthValidator(8)]]\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Async Custom Validator:**\n" +
      "```typescript\n" +
      "import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';\n" +
      "import { Observable, of } from 'rxjs';\n" +
      "import { map, catchError, delay } from 'rxjs/operators';\n" +
      "\n" +
      "// Async validator for checking username availability\n" +
      "export function usernameAvailabilityValidator(\n" +
      "  userService: UserService\n" +
      "): AsyncValidatorFn {\n" +
      "  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n" +
      "    if (!control.value) {\n" +
      "      return of(null);\n" +
      "    }\n" +
      "\n" +
      "    return userService.checkUsernameAvailability(control.value).pipe(\n" +
      "      map(isAvailable => isAvailable ? null : { usernameTaken: true }),\n" +
      "      catchError(() => of({ usernameCheckFailed: true }))\n" +
      "    );\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "// Using async validator\n" +
      "export class RegistrationFormComponent {\n" +
      "  registrationForm: FormGroup;\n" +
      "\n" +
      "  constructor(\n" +
      "    private fb: FormBuilder,\n" +
      "    private userService: UserService\n" +
      "  ) {\n" +
      "    this.registrationForm = this.fb.group({\n" +
      "      username: ['', \n" +
      "        [Validators.required, noSpacesValidator],\n" +
      "        [usernameAvailabilityValidator(this.userService)]\n" +
      "      ]\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Cross-Field Validator:**\n" +
      "```typescript\n" +
      "// Cross-field validator for password confirmation\n" +
      "export function passwordMatchValidator(control: AbstractControl): ValidationErrors | null {\n" +
      "  const password = control.get('password');\n" +
      "  const confirmPassword = control.get('confirmPassword');\n" +
      "\n" +
      "  if (!password || !confirmPassword) {\n" +
      "    return null;\n" +
      "  }\n" +
      "\n" +
      "  return password.value === confirmPassword.value ? null : { passwordMismatch: true };\n" +
      "}\n" +
      "\n" +
      "// Using cross-field validator\n" +
      "export class PasswordFormComponent {\n" +
      "  passwordForm: FormGroup;\n" +
      "\n" +
      "  constructor(private fb: FormBuilder) {\n" +
      "    this.passwordForm = this.fb.group({\n" +
      "      password: ['', [Validators.required, Validators.minLength(8)]],\n" +
      "      confirmPassword: ['', Validators.required]\n" +
      "    }, { validators: passwordMatchValidator });\n" +
      "  }\n" +
      "\n" +
      "  get passwordError() {\n" +
      "    return this.passwordForm.get('password')?.errors;\n" +
      "  }\n" +
      "\n" +
      "  get confirmPasswordError() {\n" +
      "    return this.passwordForm.get('confirmPassword')?.errors;\n" +
      "  }\n" +
      "\n" +
      "  get formError() {\n" +
      "    return this.passwordForm.errors;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template Error Handling:**\n" +
      "```html\n" +
      "<!-- Custom validator error display -->\n" +
      '<form [formGroup]="userForm">\n' +
      '  <div class="form-group">\n' +
      "    <label>Username:</label>\n" +
      '    <input formControlName="username" />\n' +
      "    \n" +
      "    <!-- Custom validator errors -->\n" +
      "    <div *ngIf=\"userForm.get('username')?.hasError('noSpaces')\" class=\"error\">\n" +
      "      Username cannot contain spaces\n" +
      "    </div>\n" +
      "    \n" +
      "    <div *ngIf=\"userForm.get('username')?.hasError('usernameTaken')\" class=\"error\">\n" +
      "      Username is already taken\n" +
      "    </div>\n" +
      "    \n" +
      "    <div *ngIf=\"userForm.get('username')?.hasError('usernameCheckFailed')\" class=\"error\">\n" +
      "      Unable to verify username availability\n" +
      "    </div>\n" +
      "  </div>\n" +
      "  \n" +
      "  <!-- Cross-field validator error -->\n" +
      '  <div *ngIf="passwordForm.hasError(\'passwordMismatch\')" class="error">\n' +
      "    Passwords do not match\n" +
      "  </div>\n" +
      "</form>\n" +
      "```\n\n" +
      "**Advanced Custom Validator with Parameters:**\n" +
      "```typescript\n" +
      "// Validator with multiple parameters\n" +
      "export function rangeValidator(min: number, max: number): ValidatorFn {\n" +
      "  return (control: AbstractControl): ValidationErrors | null => {\n" +
      "    const value = control.value;\n" +
      "    if (value === null || value === undefined) {\n" +
      "      return null;\n" +
      "    }\n" +
      "\n" +
      "    if (value < min || value > max) {\n" +
      "      return {\n" +
      "        range: {\n" +
      "          min: min,\n" +
      "          max: max,\n" +
      "          actual: value\n" +
      "        }\n" +
      "      };\n" +
      "    }\n" +
      "    return null;\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "// Email domain validator\n" +
      "export function emailDomainValidator(allowedDomains: string[]): ValidatorFn {\n" +
      "  return (control: AbstractControl): ValidationErrors | null => {\n" +
      "    if (!control.value) {\n" +
      "      return null;\n" +
      "    }\n" +
      "\n" +
      "    const email = control.value;\n" +
      "    const domain = email.split('@')[1];\n" +
      "\n" +
      "    if (!allowedDomains.includes(domain)) {\n" +
      "      return {\n" +
      "        invalidDomain: {\n" +
      "          allowedDomains: allowedDomains,\n" +
      "          actualDomain: domain\n" +
      "        }\n" +
      "      };\n" +
      "    }\n" +
      "    return null;\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "// Using parameterized validators\n" +
      "export class AdvancedFormComponent {\n" +
      "  advancedForm: FormGroup;\n" +
      "\n" +
      "  constructor(private fb: FormBuilder) {\n" +
      "    this.advancedForm = this.fb.group({\n" +
      "      age: [null, [rangeValidator(18, 65)]],\n" +
      "      email: ['', [\n" +
      "        Validators.required,\n" +
      "        Validators.email,\n" +
      "        emailDomainValidator(['company.com', 'partner.com'])\n" +
      "      ]]\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices:**\n" +
      "- Keep validators pure and stateless\n" +
      "- Return null for valid values\n" +
      "- Use descriptive error keys\n" +
      "- Include context in error objects\n" +
      "- Handle async validators properly\n" +
      "- Test validators thoroughly\n" +
      "- Use TypeScript for better type safety",
    category: "Forms",
    difficulty: "advanced",
    tags: ["forms", "reactive", "validators", "custom", "async"],
  },
  {
    id: 170,
    question:
      "How do you handle form validation errors and display them in Angular reactive forms?",
    answer:
      "Proper error handling and display in Angular reactive forms provides a better user experience:\n\n" +
      "**Basic Error Handling:**\n" +
      "```typescript\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { FormBuilder, FormGroup, Validators, AbstractControl } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-user-form',\n" +
      "  templateUrl: './user-form.component.html'\n" +
      "})\n" +
      "export class UserFormComponent implements OnInit {\n" +
      "  userForm: FormGroup;\n" +
      "  submitted = false;\n" +
      "\n" +
      "  constructor(private fb: FormBuilder) {}\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    this.userForm = this.fb.group({\n" +
      "      name: ['', [Validators.required, Validators.minLength(2)]],\n" +
      "      email: ['', [Validators.required, Validators.email]],\n" +
      "      age: [null, [Validators.required, Validators.min(18), Validators.max(100)]]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Helper method to get form control\n" +
      "  getFormControl(controlName: string): AbstractControl | null {\n" +
      "    return this.userForm.get(controlName);\n" +
      "  }\n" +
      "\n" +
      "  // Check if control has error\n" +
      "  hasError(controlName: string, errorType: string): boolean {\n" +
      "    const control = this.getFormControl(controlName);\n" +
      "    return control ? control.hasError(errorType) : false;\n" +
      "  }\n" +
      "\n" +
      "  // Check if control should show error\n" +
      "  shouldShowError(controlName: string): boolean {\n" +
      "    const control = this.getFormControl(controlName);\n" +
      "    return control ? (control.invalid && (control.dirty || control.touched || this.submitted)) : false;\n" +
      "  }\n" +
      "\n" +
      "  // Get error message\n" +
      "  getErrorMessage(controlName: string): string {\n" +
      "    const control = this.getFormControl(controlName);\n" +
      "    if (!control || !control.errors) return '';\n" +
      "\n" +
      "    const errors = control.errors;\n" +
      "    \n" +
      "    if (errors['required']) return `${controlName} is required`;\n" +
      "    if (errors['email']) return 'Please enter a valid email';\n" +
      "    if (errors['minlength']) return `${controlName} must be at least ${errors['minlength'].requiredLength} characters`;\n" +
      "    if (errors['min']) return `${controlName} must be at least ${errors['min'].min}`;\n" +
      "    if (errors['max']) return `${controlName} must be at most ${errors['max'].max}`;\n" +
      "    \n" +
      "    return 'Invalid input';\n" +
      "  }\n" +
      "\n" +
      "  onSubmit() {\n" +
      "    this.submitted = true;\n" +
      "    \n" +
      "    if (this.userForm.valid) {\n" +
      "      console.log('Form submitted:', this.userForm.value);\n" +
      "    } else {\n" +
      "      // Mark all fields as touched to show errors\n" +
      "      this.markFormGroupTouched(this.userForm);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Mark all form controls as touched\n" +
      "  private markFormGroupTouched(formGroup: FormGroup) {\n" +
      "    Object.keys(formGroup.controls).forEach(key => {\n" +
      "      const control = formGroup.get(key);\n" +
      "      control?.markAsTouched();\n" +
      "      \n" +
      "      if (control instanceof FormGroup) {\n" +
      "        this.markFormGroupTouched(control);\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template Error Display:**\n" +
      "```html\n" +
      "<!-- user-form.component.html -->\n" +
      '<form [formGroup]="userForm" (ngSubmit)="onSubmit()">\n' +
      "  <!-- Name field with error handling -->\n" +
      '  <div class="form-group">\n' +
      '    <label for="name">Name:</label>\n' +
      "    <input \n" +
      '      type="text" \n' +
      '      id="name" \n' +
      '      formControlName="name"\n' +
      "      [class.is-invalid]=\"shouldShowError('name')\"\n" +
      "      [class.is-valid]=\"getFormControl('name')?.valid && getFormControl('name')?.touched\"\n" +
      "    />\n" +
      "    \n" +
      "    <!-- Error messages -->\n" +
      '    <div *ngIf="shouldShowError(\'name\')" class="invalid-feedback">\n' +
      "      {{ getErrorMessage('name') }}\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Email field with error handling -->\n" +
      '  <div class="form-group">\n' +
      '    <label for="email">Email:</label>\n' +
      "    <input \n" +
      '      type="email" \n' +
      '      id="email" \n' +
      '      formControlName="email"\n' +
      "      [class.is-invalid]=\"shouldShowError('email')\"\n" +
      "    />\n" +
      "    \n" +
      '    <div *ngIf="shouldShowError(\'email\')" class="invalid-feedback">\n' +
      "      {{ getErrorMessage('email') }}\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Age field with error handling -->\n" +
      '  <div class="form-group">\n' +
      '    <label for="age">Age:</label>\n' +
      "    <input \n" +
      '      type="number" \n' +
      '      id="age" \n' +
      '      formControlName="age"\n' +
      "      [class.is-invalid]=\"shouldShowError('age')\"\n" +
      "    />\n" +
      "    \n" +
      '    <div *ngIf="shouldShowError(\'age\')" class="invalid-feedback">\n' +
      "      {{ getErrorMessage('age') }}\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Submit button -->\n" +
      '  <button type="submit" [disabled]="userForm.invalid && submitted">\n' +
      "    Submit\n" +
      "  </button>\n" +
      "  \n" +
      "  <!-- Form-level error summary -->\n" +
      '  <div *ngIf="submitted && userForm.invalid" class="alert alert-danger">\n' +
      "    <h6>Please fix the following errors:</h6>\n" +
      '    <ul class="mb-0">\n' +
      "      <li *ngIf=\"hasError('name', 'required')\">Name is required</li>\n" +
      "      <li *ngIf=\"hasError('email', 'required')\">Email is required</li>\n" +
      "      <li *ngIf=\"hasError('email', 'email')\">Please enter a valid email</li>\n" +
      "      <li *ngIf=\"hasError('age', 'required')\">Age is required</li>\n" +
      "    </ul>\n" +
      "  </div>\n" +
      "</form>\n" +
      "```\n\n" +
      "**Advanced Error Handling Service:**\n" +
      "```typescript\n" +
      "// error-handler.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { AbstractControl, ValidationErrors } from '@angular/forms';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class ErrorHandlerService {\n" +
      "  private errorMessages: { [key: string]: string } = {\n" +
      "    required: 'This field is required',\n" +
      "    email: 'Please enter a valid email address',\n" +
      "    minlength: 'Minimum length is {requiredLength} characters',\n" +
      "    maxlength: 'Maximum length is {requiredLength} characters',\n" +
      "    min: 'Minimum value is {min}',\n" +
      "    max: 'Maximum value is {max}',\n" +
      "    pattern: 'Please enter a valid format',\n" +
      "    noSpaces: 'This field cannot contain spaces',\n" +
      "    usernameTaken: 'This username is already taken',\n" +
      "    passwordMismatch: 'Passwords do not match'\n" +
      "  };\n" +
      "\n" +
      "  getErrorMessage(control: AbstractControl, fieldName: string = 'This field'): string {\n" +
      "    if (!control || !control.errors) return '';\n" +
      "\n" +
      "    const errors = control.errors;\n" +
      "    const firstError = Object.keys(errors)[0];\n" +
      "    \n" +
      "    let message = this.errorMessages[firstError] || 'Invalid input';\n" +
      "    \n" +
      "    // Replace placeholders with actual values\n" +
      "    const errorData = errors[firstError];\n" +
      "    if (errorData && typeof errorData === 'object') {\n" +
      "      Object.keys(errorData).forEach(key => {\n" +
      "        message = message.replace(`{${key}}`, errorData[key]);\n" +
      "      });\n" +
      "    }\n" +
      "    \n" +
      "    return message.replace('This field', fieldName);\n" +
      "  }\n" +
      "\n" +
      "  shouldShowError(control: AbstractControl, submitted: boolean = false): boolean {\n" +
      "    if (!control) return false;\n" +
      "    return control.invalid && (control.dirty || control.touched || submitted);\n" +
      "  }\n" +
      "\n" +
      "  getFieldErrors(control: AbstractControl): string[] {\n" +
      "    if (!control || !control.errors) return [];\n" +
      "    \n" +
      "    return Object.keys(control.errors).map(errorKey => {\n" +
      "      return this.getErrorMessage(control, 'Field');\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Using Error Handler Service:**\n" +
      "```typescript\n" +
      "// user-form.component.ts\n" +
      "import { ErrorHandlerService } from './error-handler.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-user-form',\n" +
      "  templateUrl: './user-form.component.html'\n" +
      "})\n" +
      "export class UserFormComponent {\n" +
      "  userForm: FormGroup;\n" +
      "  submitted = false;\n" +
      "\n" +
      "  constructor(\n" +
      "    private fb: FormBuilder,\n" +
      "    private errorHandler: ErrorHandlerService\n" +
      "  ) {\n" +
      "    this.userForm = this.fb.group({\n" +
      "      name: ['', [Validators.required, Validators.minLength(2)]],\n" +
      "      email: ['', [Validators.required, Validators.email]]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  getErrorMessage(controlName: string): string {\n" +
      "    const control = this.userForm.get(controlName);\n" +
      "    return this.errorHandler.getErrorMessage(control!, controlName);\n" +
      "  }\n" +
      "\n" +
      "  shouldShowError(controlName: string): boolean {\n" +
      "    const control = this.userForm.get(controlName);\n" +
      "    return this.errorHandler.shouldShowError(control!, this.submitted);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**CSS for Error States:**\n" +
      "```css\n" +
      "/* user-form.component.css */\n" +
      ".form-group {\n" +
      "  margin-bottom: 1rem;\n" +
      "}\n" +
      "\n" +
      ".form-control.is-invalid {\n" +
      "  border-color: #dc3545;\n" +
      "  box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);\n" +
      "}\n" +
      "\n" +
      ".form-control.is-valid {\n" +
      "  border-color: #28a745;\n" +
      "  box-shadow: 0 0 0 0.2rem rgba(40, 167, 69, 0.25);\n" +
      "}\n" +
      "\n" +
      ".invalid-feedback {\n" +
      "  display: block;\n" +
      "  width: 100%;\n" +
      "  margin-top: 0.25rem;\n" +
      "  font-size: 0.875rem;\n" +
      "  color: #dc3545;\n" +
      "}\n" +
      "\n" +
      ".valid-feedback {\n" +
      "  display: block;\n" +
      "  width: 100%;\n" +
      "  margin-top: 0.25rem;\n" +
      "  font-size: 0.875rem;\n" +
      "  color: #28a745;\n" +
      "}\n" +
      "\n" +
      ".alert {\n" +
      "  padding: 0.75rem 1.25rem;\n" +
      "  margin-bottom: 1rem;\n" +
      "  border: 1px solid transparent;\n" +
      "  border-radius: 0.25rem;\n" +
      "}\n" +
      "\n" +
      ".alert-danger {\n" +
      "  color: #721c24;\n" +
      "  background-color: #f8d7da;\n" +
      "  border-color: #f5c6cb;\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices:**\n" +
      "- Show errors only after user interaction\n" +
      "- Use consistent error messaging\n" +
      "- Provide clear, actionable error messages\n" +
      "- Handle both field-level and form-level errors\n" +
      "- Use CSS classes for visual feedback\n" +
      "- Implement error summary for complex forms\n" +
      "- Test error scenarios thoroughly",
    category: "Forms",
    difficulty: "intermediate",
    tags: ["forms", "reactive", "validation", "error-handling", "UX"],
  },
  {
    id: 171,
    question: "How do you implement dynamic forms with FormArray in Angular reactive forms?",
    answer:
      "Dynamic forms with FormArray allow users to add/remove form fields dynamically, perfect for scenarios like multiple addresses, phone numbers, or skills:\n\n" +
      "**Basic Dynamic Form Implementation:**\n" +
      "```typescript\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { FormBuilder, FormGroup, FormArray, FormControl, Validators } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-dynamic-form',\n" +
      "  templateUrl: './dynamic-form.component.html'\n" +
      "})\n" +
      "export class DynamicFormComponent implements OnInit {\n" +
      "  dynamicForm: FormGroup;\n" +
      "\n" +
      "  constructor(private fb: FormBuilder) {}\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    this.dynamicForm = this.fb.group({\n" +
      "      name: ['', Validators.required],\n" +
      "      email: ['', [Validators.required, Validators.email]],\n" +
      "      skills: this.fb.array([]), // Empty FormArray for skills\n" +
      "      addresses: this.fb.array([\n" +
      "        this.createAddressGroup() // Start with one address\n" +
      "      ])\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Create a new skill FormControl\n" +
      "  createSkillControl(): FormControl {\n" +
      "    return this.fb.control('', [Validators.required, Validators.minLength(2)]);\n" +
      "  }\n" +
      "\n" +
      "  // Create a new address FormGroup\n" +
      "  createAddressGroup(): FormGroup {\n" +
      "    return this.fb.group({\n" +
      "      street: ['', Validators.required],\n" +
      "      city: ['', Validators.required],\n" +
      "      zipCode: ['', [Validators.required, Validators.pattern(/^[0-9]{5}$/)]],\n" +
      "      country: ['', Validators.required]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Get FormArray getters\n" +
      "  get skillsArray(): FormArray {\n" +
      "    return this.dynamicForm.get('skills') as FormArray;\n" +
      "  }\n" +
      "\n" +
      "  get addressesArray(): FormArray {\n" +
      "    return this.dynamicForm.get('addresses') as FormArray;\n" +
      "  }\n" +
      "\n" +
      "  // Add/Remove methods for skills\n" +
      "  addSkill() {\n" +
      "    this.skillsArray.push(this.createSkillControl());\n" +
      "  }\n" +
      "\n" +
      "  removeSkill(index: number) {\n" +
      "    if (this.skillsArray.length > 1) {\n" +
      "      this.skillsArray.removeAt(index);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Add/Remove methods for addresses\n" +
      "  addAddress() {\n" +
      "    this.addressesArray.push(this.createAddressGroup());\n" +
      "  }\n" +
      "\n" +
      "  removeAddress(index: number) {\n" +
      "    if (this.addressesArray.length > 1) {\n" +
      "      this.addressesArray.removeAt(index);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Get skill control by index\n" +
      "  getSkillControl(index: number): FormControl {\n" +
      "    return this.skillsArray.at(index) as FormControl;\n" +
      "  }\n" +
      "\n" +
      "  // Get address group by index\n" +
      "  getAddressGroup(index: number): FormGroup {\n" +
      "    return this.addressesArray.at(index) as FormGroup;\n" +
      "  }\n" +
      "\n" +
      "  // Form submission\n" +
      "  onSubmit() {\n" +
      "    if (this.dynamicForm.valid) {\n" +
      "      console.log('Form submitted:', this.dynamicForm.value);\n" +
      "      console.log('Raw form value:', this.dynamicForm.getRawValue());\n" +
      "    } else {\n" +
      "      this.markFormGroupTouched(this.dynamicForm);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Mark all controls as touched\n" +
      "  private markFormGroupTouched(formGroup: FormGroup) {\n" +
      "    Object.keys(formGroup.controls).forEach(key => {\n" +
      "      const control = formGroup.get(key);\n" +
      "      \n" +
      "      if (control instanceof FormGroup) {\n" +
      "        this.markFormGroupTouched(control);\n" +
      "      } else if (control instanceof FormArray) {\n" +
      "        control.controls.forEach(arrayControl => {\n" +
      "          if (arrayControl instanceof FormGroup) {\n" +
      "            this.markFormGroupTouched(arrayControl);\n" +
      "          } else {\n" +
      "            arrayControl.markAsTouched();\n" +
      "          }\n" +
      "        });\n" +
      "      } else {\n" +
      "        control?.markAsTouched();\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template Implementation:**\n" +
      "```html\n" +
      "<!-- dynamic-form.component.html -->\n" +
      '<form [formGroup]="dynamicForm" (ngSubmit)="onSubmit()">\n' +
      "  <!-- Basic fields -->\n" +
      '  <div class="form-group">\n' +
      "    <label>Name:</label>\n" +
      '    <input formControlName="name" placeholder="Enter your name" />\n' +
      "  </div>\n" +
      "\n" +
      '  <div class="form-group">\n' +
      "    <label>Email:</label>\n" +
      '    <input formControlName="email" placeholder="Enter your email" />\n' +
      "  </div>\n" +
      "\n" +
      "  <!-- Dynamic Skills Section -->\n" +
      '  <div class="form-section">\n' +
      "    <h3>Skills</h3>\n" +
      '    <div formArrayName="skills">\n' +
      "      <div \n" +
      '        *ngFor="let skill of skillsArray.controls; let i = index" \n' +
      '        class="skill-item"\n' +
      "      >\n" +
      '        <div class="form-group">\n' +
      "          <input \n" +
      '            [formControlName]="i" \n' +
      '            placeholder="Enter skill {{i + 1}}"\n' +
      '            [class.is-invalid]="getSkillControl(i).invalid && getSkillControl(i).touched"\n' +
      "          />\n" +
      "          <button \n" +
      '            type="button" \n' +
      '            class="btn btn-danger btn-sm" \n' +
      '            (click)="removeSkill(i)"\n' +
      '            [disabled]="skillsArray.length <= 1"\n' +
      "          >\n" +
      "            Remove\n" +
      "          </button>\n" +
      "        </div>\n" +
      "        \n" +
      "        <!-- Error display for skills -->\n" +
      "        <div \n" +
      '          *ngIf="getSkillControl(i).invalid && getSkillControl(i).touched" \n' +
      '          class="error-message"\n' +
      "        >\n" +
      "          <span *ngIf=\"getSkillControl(i).hasError('required')\">Skill is required</span>\n" +
      "          <span *ngIf=\"getSkillControl(i).hasError('minlength')\">Skill must be at least 2 characters</span>\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      "    <button \n" +
      '      type="button" \n' +
      '      class="btn btn-primary" \n' +
      '      (click)="addSkill()"\n' +
      "    >\n" +
      "      Add Skill\n" +
      "    </button>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Dynamic Addresses Section -->\n" +
      '  <div class="form-section">\n' +
      "    <h3>Addresses</h3>\n" +
      '    <div formArrayName="addresses">\n' +
      "      <div \n" +
      '        *ngFor="let address of addressesArray.controls; let i = index" \n' +
      '        [formGroupName]="i"\n' +
      '        class="address-item"\n' +
      "      >\n" +
      '        <div class="address-header">\n' +
      "          <h4>Address {{i + 1}}</h4>\n" +
      "          <button \n" +
      '            type="button" \n' +
      '            class="btn btn-danger btn-sm" \n' +
      '            (click)="removeAddress(i)"\n' +
      '            [disabled]="addressesArray.length <= 1"\n' +
      "          >\n" +
      "            Remove Address\n" +
      "          </button>\n" +
      "        </div>\n" +
      "        \n" +
      '        <div class="form-row">\n' +
      '          <div class="form-group">\n' +
      "            <label>Street:</label>\n" +
      "            <input \n" +
      '              formControlName="street" \n' +
      '              placeholder="Enter street address"\n' +
      "              [class.is-invalid]=\"getAddressGroup(i).get('street')?.invalid && getAddressGroup(i).get('street')?.touched\"\n" +
      "            />\n" +
      "            <div \n" +
      "              *ngIf=\"getAddressGroup(i).get('street')?.invalid && getAddressGroup(i).get('street')?.touched\" \n" +
      '              class="error-message"\n' +
      "            >\n" +
      "              Street is required\n" +
      "            </div>\n" +
      "          </div>\n" +
      "          \n" +
      '          <div class="form-group">\n' +
      "            <label>City:</label>\n" +
      "            <input \n" +
      '              formControlName="city" \n' +
      '              placeholder="Enter city"\n' +
      "              [class.is-invalid]=\"getAddressGroup(i).get('city')?.invalid && getAddressGroup(i).get('city')?.touched\"\n" +
      "            />\n" +
      "            <div \n" +
      "              *ngIf=\"getAddressGroup(i).get('city')?.invalid && getAddressGroup(i).get('city')?.touched\" \n" +
      '              class="error-message"\n' +
      "            >\n" +
      "              City is required\n" +
      "            </div>\n" +
      "          </div>\n" +
      "        </div>\n" +
      "        \n" +
      '        <div class="form-row">\n' +
      '          <div class="form-group">\n' +
      "            <label>ZIP Code:</label>\n" +
      "            <input \n" +
      '              formControlName="zipCode" \n' +
      '              placeholder="Enter ZIP code"\n' +
      "              [class.is-invalid]=\"getAddressGroup(i).get('zipCode')?.invalid && getAddressGroup(i).get('zipCode')?.touched\"\n" +
      "            />\n" +
      "            <div \n" +
      "              *ngIf=\"getAddressGroup(i).get('zipCode')?.invalid && getAddressGroup(i).get('zipCode')?.touched\" \n" +
      '              class="error-message"\n' +
      "            >\n" +
      "              <span *ngIf=\"getAddressGroup(i).get('zipCode')?.hasError('required')\">ZIP code is required</span>\n" +
      "              <span *ngIf=\"getAddressGroup(i).get('zipCode')?.hasError('pattern')\">ZIP code must be 5 digits</span>\n" +
      "            </div>\n" +
      "          </div>\n" +
      "          \n" +
      '          <div class="form-group">\n' +
      "            <label>Country:</label>\n" +
      "            <select \n" +
      '              formControlName="country"\n' +
      "              [class.is-invalid]=\"getAddressGroup(i).get('country')?.invalid && getAddressGroup(i).get('country')?.touched\"\n" +
      "            >\n" +
      '              <option value="">Select Country</option>\n' +
      '              <option value="US">United States</option>\n' +
      '              <option value="CA">Canada</option>\n' +
      '              <option value="UK">United Kingdom</option>\n' +
      '              <option value="DE">Germany</option>\n' +
      "            </select>\n" +
      "            <div \n" +
      "              *ngIf=\"getAddressGroup(i).get('country')?.invalid && getAddressGroup(i).get('country')?.touched\" \n" +
      '              class="error-message"\n' +
      "            >\n" +
      "              Country is required\n" +
      "            </div>\n" +
      "          </div>\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      "    <button \n" +
      '      type="button" \n' +
      '      class="btn btn-primary" \n' +
      '      (click)="addAddress()"\n' +
      "    >\n" +
      "      Add Address\n" +
      "    </button>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Submit button -->\n" +
      '  <div class="form-actions">\n' +
      "    <button \n" +
      '      type="submit" \n' +
      '      class="btn btn-success"\n' +
      '      [disabled]="dynamicForm.invalid"\n' +
      "    >\n" +
      "      Submit Form\n" +
      "    </button>\n" +
      "    \n" +
      "    <button \n" +
      '      type="button" \n' +
      '      class="btn btn-secondary" \n' +
      '      (click)="dynamicForm.reset()"\n' +
      "    >\n" +
      "      Reset Form\n" +
      "    </button>\n" +
      "  </div>\n" +
      "</form>\n" +
      "```\n\n" +
      "**Advanced Dynamic Form with Conditional Fields:**\n" +
      "```typescript\n" +
      "// Advanced dynamic form with conditional logic\n" +
      "export class AdvancedDynamicFormComponent {\n" +
      "  dynamicForm: FormGroup;\n" +
      "  \n" +
      "  constructor(private fb: FormBuilder) {\n" +
      "    this.dynamicForm = this.fb.group({\n" +
      "      userType: ['individual', Validators.required],\n" +
      "      personalInfo: this.fb.group({\n" +
      "        firstName: ['', Validators.required],\n" +
      "        lastName: ['', Validators.required],\n" +
      "        dateOfBirth: ['', Validators.required]\n" +
      "      }),\n" +
      "      companyInfo: this.fb.group({\n" +
      "        companyName: [''],\n" +
      "        taxId: [''],\n      " +
      "        employees: this.fb.array([])\n" +
      "      }),\n" +
      "      contacts: this.fb.array([\n" +
      "        this.createContactGroup()\n" +
      "      ])\n" +
      "    });\n" +
      "\n" +
      "    // Watch for userType changes\n" +
      "    this.dynamicForm.get('userType')?.valueChanges.subscribe(userType => {\n" +
      "      this.handleUserTypeChange(userType);\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  createContactGroup(): FormGroup {\n" +
      "    return this.fb.group({\n" +
      "      type: ['email', Validators.required],\n" +
      "      value: ['', Validators.required],\n" +
      "      isPrimary: [false]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  createEmployeeGroup(): FormGroup {\n" +
      "    return this.fb.group({\n" +
      "      name: ['', Validators.required],\n" +
      "      position: ['', Validators.required],\n" +
      "      salary: [null, [Validators.required, Validators.min(0)]]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  handleUserTypeChange(userType: string) {\n" +
      "    const companyInfo = this.dynamicForm.get('companyInfo');\n" +
      "    \n" +
      "    if (userType === 'company') {\n" +
      "      // Enable company fields\n" +
      "      companyInfo?.get('companyName')?.setValidators([Validators.required]);\n" +
      "      companyInfo?.get('taxId')?.setValidators([Validators.required]);\n" +
      "    } else {\n" +
      "      // Disable company fields\n" +
      "      companyInfo?.get('companyName')?.clearValidators();\n" +
      "      companyInfo?.get('taxId')?.clearValidators();\n" +
      "      \n" +
      "      // Clear company values\n" +
      "      companyInfo?.patchValue({\n" +
      "        companyName: '',\n" +
      "        taxId: ''\n" +
      "      });\n" +
      "    }\n" +
      "    \n" +
      "    // Update validation\n" +
      "    companyInfo?.get('companyName')?.updateValueAndValidity();\n" +
      "    companyInfo?.get('taxId')?.updateValueAndValidity();\n" +
      "  }\n" +
      "\n" +
      "  get contactsArray(): FormArray {\n" +
      "    return this.dynamicForm.get('contacts') as FormArray;\n" +
      "  }\n" +
      "\n" +
      "  get employeesArray(): FormArray {\n" +
      "    return this.dynamicForm.get('companyInfo.employees') as FormArray;\n" +
      "  }\n" +
      "\n" +
      "  addContact() {\n" +
      "    this.contactsArray.push(this.createContactGroup());\n" +
      "  }\n" +
      "\n" +
      "  removeContact(index: number) {\n" +
      "    this.contactsArray.removeAt(index);\n" +
      "  }\n" +
      "\n" +
      "  addEmployee() {\n" +
      "    this.employeesArray.push(this.createEmployeeGroup());\n" +
      "  }\n" +
      "\n" +
      "  removeEmployee(index: number) {\n" +
      "    this.employeesArray.removeAt(index);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**CSS for Dynamic Forms:**\n" +
      "```css\n" +
      "/* dynamic-form.component.css */\n" +
      ".form-section {\n" +
      "  margin-bottom: 2rem;\n" +
      "  padding: 1rem;\n" +
      "  border: 1px solid #dee2e6;\n" +
      "  border-radius: 0.25rem;\n" +
      "}\n" +
      "\n" +
      ".skill-item, .address-item {\n" +
      "  margin-bottom: 1rem;\n" +
      "  padding: 1rem;\n" +
      "  background-color: #f8f9fa;\n" +
      "  border-radius: 0.25rem;\n" +
      "}\n" +
      "\n" +
      ".address-header {\n" +
      "  display: flex;\n" +
      "  justify-content: space-between;\n" +
      "  align-items: center;\n" +
      "  margin-bottom: 1rem;\n" +
      "}\n" +
      "\n" +
      ".form-row {\n" +
      "  display: flex;\n" +
      "  gap: 1rem;\n" +
      "}\n" +
      "\n" +
      ".form-group {\n" +
      "  flex: 1;\n" +
      "  margin-bottom: 1rem;\n" +
      "}\n" +
      "\n" +
      ".form-actions {\n" +
      "  margin-top: 2rem;\n" +
      "  display: flex;\n" +
      "  gap: 1rem;\n" +
      "}\n" +
      "\n" +
      ".error-message {\n" +
      "  color: #dc3545;\n" +
      "  font-size: 0.875rem;\n" +
      "  margin-top: 0.25rem;\n" +
      "}\n" +
      "\n" +
      ".btn {\n" +
      "  padding: 0.375rem 0.75rem;\n" +
      "  border: 1px solid transparent;\n" +
      "  border-radius: 0.25rem;\n" +
      "  cursor: pointer;\n" +
      "}\n" +
      "\n" +
      ".btn-primary {\n" +
      "  background-color: #007bff;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-danger {\n" +
      "  background-color: #dc3545;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-success {\n" +
      "  background-color: #28a745;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-secondary {\n" +
      "  background-color: #6c757d;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-sm {\n" +
      "  padding: 0.25rem 0.5rem;\n" +
      "  font-size: 0.875rem;\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices:**\n" +
      "- Always provide minimum one item in FormArray\n" +
      "- Use proper validation for dynamic fields\n" +
      "- Implement proper error handling\n" +
      "- Use getter methods for cleaner templates\n" +
      "- Handle form state properly\n" +
      "- Provide clear visual feedback\n" +
      "- Test dynamic form scenarios thoroughly",
    category: "Forms",
    difficulty: "advanced",
    tags: ["forms", "reactive", "FormArray", "dynamic", "validation"],
  },
  {
    id: 172,
    question:
      "How do you implement form state management and persistence in Angular reactive forms?",
    answer:
      "Form state management and persistence in Angular reactive forms involves saving, restoring, and managing form data across sessions:\n\n" +
      "**Basic Form State Management:**\n" +
      "```typescript\n" +
      "import { Component, OnInit, OnDestroy } from '@angular/core';\n" +
      "import { FormBuilder, FormGroup, Validators } from '@angular/forms';\n" +
      "import { Subscription } from 'rxjs';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-form-state',\n" +
      "  templateUrl: './form-state.component.html'\n" +
      "})\n" +
      "export class FormStateComponent implements OnInit, OnDestroy {\n" +
      "  userForm: FormGroup;\n" +
      "  private formSubscription: Subscription;\n" +
      "  private readonly FORM_STORAGE_KEY = 'userFormData';\n" +
      "  private readonly FORM_STATE_KEY = 'userFormState';\n" +
      "\n" +
      "  constructor(private fb: FormBuilder) {\n" +
      "    this.userForm = this.fb.group({\n" +
      "      name: ['', Validators.required],\n" +
      "      email: ['', [Validators.required, Validators.email]],\n" +
      "      phone: ['', Validators.required],\n" +
      "      address: this.fb.group({\n" +
      "        street: ['', Validators.required],\n" +
      "        city: ['', Validators.required],\n" +
      "        zipCode: ['', Validators.required]\n" +
      "      })\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    // Restore form data from localStorage\n" +
      "    this.restoreFormData();\n" +
      "    \n" +
      "    // Subscribe to form changes for auto-save\n" +
      "    this.formSubscription = this.userForm.valueChanges.subscribe(formData => {\n" +
      "      this.saveFormData(formData);\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  ngOnDestroy() {\n" +
      "    if (this.formSubscription) {\n" +
      "      this.formSubscription.unsubscribe();\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Save form data to localStorage\n" +
      "  private saveFormData(formData: any) {\n" +
      "    try {\n" +
      "      localStorage.setItem(this.FORM_STORAGE_KEY, JSON.stringify(formData));\n" +
      "      \n" +
      "      // Save form state (touched, dirty, etc.)\n" +
      "      const formState = {\n" +
      "        touched: this.userForm.touched,\n" +
      "        dirty: this.userForm.dirty,\n" +
      "        valid: this.userForm.valid,\n" +
      "        timestamp: new Date().toISOString()\n" +
      "      };\n" +
      "      localStorage.setItem(this.FORM_STATE_KEY, JSON.stringify(formState));\n" +
      "    } catch (error) {\n" +
      "      console.error('Error saving form data:', error);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Restore form data from localStorage\n" +
      "  private restoreFormData() {\n" +
      "    try {\n" +
      "      const savedData = localStorage.getItem(this.FORM_STORAGE_KEY);\n" +
      "      const savedState = localStorage.getItem(this.FORM_STATE_KEY);\n" +
      "      \n" +
      "      if (savedData) {\n" +
      "        const formData = JSON.parse(savedData);\n" +
      "        this.userForm.patchValue(formData);\n" +
      "        \n" +
      "        // Restore form state if available\n" +
      "        if (savedState) {\n" +
      "          const formState = JSON.parse(savedState);\n" +
      "          this.restoreFormState(formState);\n" +
      "        }\n" +
      "      }\n" +
      "    } catch (error) {\n" +
      "      console.error('Error restoring form data:', error);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Restore form state\n" +
      "  private restoreFormState(formState: any) {\n" +
      "    if (formState.touched) {\n" +
      "      this.userForm.markAsTouched();\n" +
      "    }\n" +
      "    if (formState.dirty) {\n" +
      "      this.userForm.markAsDirty();\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Clear saved form data\n" +
      "  clearFormData() {\n" +
      "    localStorage.removeItem(this.FORM_STORAGE_KEY);\n" +
      "    localStorage.removeItem(this.FORM_STATE_KEY);\n" +
      "    this.userForm.reset();\n" +
      "  }\n" +
      "\n" +
      "  // Check if form has saved data\n" +
      "  hasSavedData(): boolean {\n" +
      "    return localStorage.getItem(this.FORM_STORAGE_KEY) !== null;\n" +
      "  }\n" +
      "\n" +
      "  // Get saved data timestamp\n" +
      "  getSavedDataTimestamp(): string | null {\n" +
      "    const savedState = localStorage.getItem(this.FORM_STATE_KEY);\n" +
      "    if (savedState) {\n" +
      "      const formState = JSON.parse(savedState);\n" +
      "      return formState.timestamp;\n" +
      "    }\n" +
      "    return null;\n" +
      "  }\n" +
      "\n" +
      "  onSubmit() {\n" +
      "    if (this.userForm.valid) {\n" +
      "      console.log('Form submitted:', this.userForm.value);\n" +
      "      // Clear saved data after successful submission\n" +
      "      this.clearFormData();\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Advanced Form State Service:**\n" +
      "```typescript\n" +
      "// form-state.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { FormGroup, AbstractControl } from '@angular/forms';\n" +
      "import { BehaviorSubject, Observable } from 'rxjs';\n" +
      "\n" +
      "export interface FormState {\n" +
      "  data: any;\n" +
      "  state: {\n" +
      "    touched: boolean;\n" +
      "    dirty: boolean;\n" +
      "    valid: boolean;\n" +
      "    timestamp: string;\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class FormStateService {\n" +
      "  private formStates = new Map<string, FormState>();\n" +
      "  private stateSubject = new BehaviorSubject<Map<string, FormState>>(new Map());\n" +
      "\n" +
      "  constructor() {\n" +
      "    // Load all saved form states on service initialization\n" +
      "    this.loadAllFormStates();\n" +
      "  }\n" +
      "\n" +
      "  // Save form state\n" +
      "  saveFormState(formId: string, form: FormGroup): void {\n" +
      "    const formState: FormState = {\n" +
      "      data: form.value,\n" +
      "      state: {\n" +
      "        touched: form.touched,\n" +
      "        dirty: form.dirty,\n" +
      "        valid: form.valid,\n" +
      "        timestamp: new Date().toISOString()\n" +
      "      }\n" +
      "    };\n" +
      "\n" +
      "    this.formStates.set(formId, formState);\n" +
      "    this.persistFormState(formId, formState);\n" +
      "    this.stateSubject.next(this.formStates);\n" +
      "  }\n" +
      "\n" +
      "  // Restore form state\n" +
      "  restoreFormState(formId: string, form: FormGroup): boolean {\n" +
      "    const savedState = this.formStates.get(formId);\n" +
      "    \n" +
      "    if (savedState) {\n" +
      "      form.patchValue(savedState.data);\n" +
      "      \n" +
      "      // Restore form state\n" +
      "      if (savedState.state.touched) {\n" +
      "        form.markAsTouched();\n" +
      "      }\n" +
      "      if (savedState.state.dirty) {\n" +
      "        form.markAsDirty();\n" +
      "      }\n" +
      "      \n" +
      "      return true;\n" +
      "    }\n" +
      "    \n" +
      "    return false;\n" +
      "  }\n" +
      "\n" +
      "  // Clear form state\n" +
      "  clearFormState(formId: string): void {\n" +
      "    this.formStates.delete(formId);\n" +
      "    localStorage.removeItem(`form_${formId}`);\n" +
      "    this.stateSubject.next(this.formStates);\n" +
      "  }\n" +
      "\n" +
      "  // Get all form states\n" +
      "  getAllFormStates(): Observable<Map<string, FormState>> {\n" +
      "    return this.stateSubject.asObservable();\n" +
      "  }\n" +
      "\n" +
      "  // Check if form has saved state\n" +
      "  hasFormState(formId: string): boolean {\n" +
      "    return this.formStates.has(formId);\n" +
      "  }\n" +
      "\n" +
      "  // Get form state timestamp\n" +
      "  getFormStateTimestamp(formId: string): string | null {\n" +
      "    const formState = this.formStates.get(formId);\n" +
      "    return formState ? formState.state.timestamp : null;\n" +
      "  }\n" +
      "\n" +
      "  // Persist form state to localStorage\n" +
      "  private persistFormState(formId: string, formState: FormState): void {\n" +
      "    try {\n" +
      "      localStorage.setItem(`form_${formId}`, JSON.stringify(formState));\n" +
      "    } catch (error) {\n" +
      "      console.error(`Error persisting form state for ${formId}:`, error);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Load all form states from localStorage\n" +
      "  private loadAllFormStates(): void {\n" +
      "    for (let i = 0; i < localStorage.length; i++) {\n" +
      "      const key = localStorage.key(i);\n" +
      "      if (key?.startsWith('form_')) {\n" +
      "        try {\n" +
      "          const formId = key.replace('form_', '');\n" +
      "          const formState = JSON.parse(localStorage.getItem(key) || '{}');\n" +
      "          this.formStates.set(formId, formState);\n" +
      "        } catch (error) {\n" +
      "          console.error(`Error loading form state for ${key}:`, error);\n" +
      "        }\n" +
      "      }\n" +
      "    }\n" +
      "    this.stateSubject.next(this.formStates);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Using Form State Service:**\n" +
      "```typescript\n" +
      "// user-form.component.ts\n" +
      "import { FormStateService } from './form-state.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-user-form',\n" +
      "  templateUrl: './user-form.component.html'\n" +
      "})\n" +
      "export class UserFormComponent implements OnInit, OnDestroy {\n" +
      "  userForm: FormGroup;\n" +
      "  private readonly FORM_ID = 'userForm';\n" +
      "  private formSubscription: Subscription;\n" +
      "\n" +
      "  constructor(\n" +
      "    private fb: FormBuilder,\n" +
      "    private formStateService: FormStateService\n" +
      "  ) {\n" +
      "    this.userForm = this.fb.group({\n" +
      "      name: ['', Validators.required],\n" +
      "      email: ['', [Validators.required, Validators.email]],\n" +
      "      phone: ['', Validators.required]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    // Restore form state if available\n" +
      "    const restored = this.formStateService.restoreFormState(this.FORM_ID, this.userForm);\n" +
      "    \n" +
      "    if (restored) {\n" +
      "      console.log('Form state restored from:', this.formStateService.getFormStateTimestamp(this.FORM_ID));\n" +
      "    }\n" +
      "    \n" +
      "    // Auto-save form changes\n" +
      "    this.formSubscription = this.userForm.valueChanges.pipe(\n" +
      "      debounceTime(500) // Debounce to avoid excessive saves\n" +
      "    ).subscribe(() => {\n" +
      "      this.formStateService.saveFormState(this.FORM_ID, this.userForm);\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  ngOnDestroy() {\n" +
      "    if (this.formSubscription) {\n" +
      "      this.formSubscription.unsubscribe();\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  onSubmit() {\n" +
      "    if (this.userForm.valid) {\n" +
      "      console.log('Form submitted:', this.userForm.value);\n" +
      "      // Clear saved state after successful submission\n" +
      "      this.formStateService.clearFormState(this.FORM_ID);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Manual save\n" +
      "  saveForm() {\n" +
      "    this.formStateService.saveFormState(this.FORM_ID, this.userForm);\n" +
      "  }\n" +
      "\n" +
      "  // Check if form has saved data\n" +
      "  hasSavedData(): boolean {\n" +
      "    return this.formStateService.hasFormState(this.FORM_ID);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template with State Management:**\n" +
      "```html\n" +
      "<!-- user-form.component.html -->\n" +
      '<form [formGroup]="userForm" (ngSubmit)="onSubmit()">\n' +
      "  <!-- Form state indicator -->\n" +
      '  <div *ngIf="hasSavedData()" class="form-state-indicator">\n' +
      '    <i class="fas fa-save"></i>\n' +
      "    <span>Form data saved</span>\n" +
      '    <button type="button" class="btn btn-sm btn-outline-secondary" (click)="saveForm()">\n' +
      "      Save Now\n" +
      "    </button>\n" +
      "  </div>\n" +
      "\n" +
      '  <div class="form-group">\n' +
      "    <label>Name:</label>\n" +
      '    <input formControlName="name" placeholder="Enter your name" />\n' +
      "  </div>\n" +
      "\n" +
      '  <div class="form-group">\n' +
      "    <label>Email:</label>\n" +
      '    <input formControlName="email" placeholder="Enter your email" />\n' +
      "  </div>\n" +
      "\n" +
      '  <div class="form-group">\n' +
      "    <label>Phone:</label>\n" +
      '    <input formControlName="phone" placeholder="Enter your phone" />\n' +
      "  </div>\n" +
      "\n" +
      '  <div class="form-actions">\n' +
      '    <button type="submit" [disabled]="userForm.invalid">Submit</button>\n' +
      '    <button type="button" (click)="saveForm()">Save Draft</button>\n' +
      '    <button type="button" (click)="userForm.reset()">Reset</button>\n' +
      "  </div>\n" +
      "</form>\n" +
      "```\n\n" +
      "**Form State Management with IndexedDB:**\n" +
      "```typescript\n" +
      "// indexeddb-form-state.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { FormGroup } from '@angular/forms';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class IndexedDBFormStateService {\n" +
      "  private dbName = 'FormStateDB';\n" +
      "  private dbVersion = 1;\n" +
      "  private storeName = 'formStates';\n" +
      "\n" +
      "  async saveFormState(formId: string, form: FormGroup): Promise<void> {\n" +
      "    const db = await this.openDatabase();\n" +
      "    const transaction = db.transaction([this.storeName], 'readwrite');\n" +
      "    const store = transaction.objectStore(this.storeName);\n" +
      "    \n" +
      "    const formState = {\n" +
      "      id: formId,\n" +
      "      data: form.value,\n      " +
      "      state: {\n" +
      "        touched: form.touched,\n" +
      "        dirty: form.dirty,\n" +
      "        valid: form.valid,\n" +
      "        timestamp: new Date().toISOString()\n" +
      "      }\n" +
      "    };\n" +
      "    \n" +
      "    await store.put(formState);\n" +
      "  }\n" +
      "\n" +
      "  async restoreFormState(formId: string, form: FormGroup): Promise<boolean> {\n" +
      "    const db = await this.openDatabase();\n" +
      "    const transaction = db.transaction([this.storeName], 'readonly');\n" +
      "    const store = transaction.objectStore(this.storeName);\n" +
      "    \n" +
      "    const request = store.get(formId);\n" +
      "    \n" +
      "    return new Promise((resolve) => {\n" +
      "      request.onsuccess = () => {\n" +
      "        const result = request.result;\n" +
      "        if (result) {\n" +
      "          form.patchValue(result.data);\n" +
      "          if (result.state.touched) form.markAsTouched();\n" +
      "          if (result.state.dirty) form.markAsDirty();\n" +
      "          resolve(true);\n" +
      "        } else {\n" +
      "          resolve(false);\n" +
      "        }\n" +
      "      };\n" +
      "      \n" +
      "      request.onerror = () => resolve(false);\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  private openDatabase(): Promise<IDBDatabase> {\n" +
      "    return new Promise((resolve, reject) => {\n" +
      "      const request = indexedDB.open(this.dbName, this.dbVersion);\n" +
      "      \n" +
      "      request.onupgradeneeded = (event) => {\n" +
      "        const db = (event.target as IDBOpenDBRequest).result;\n" +
      "        if (!db.objectStoreNames.contains(this.storeName)) {\n" +
      "          db.createObjectStore(this.storeName, { keyPath: 'id' });\n" +
      "        }\n" +
      "      };\n" +
      "      \n" +
      "      request.onsuccess = () => resolve(request.result);\n" +
      "      request.onerror = () => reject(request.error);\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices:**\n" +
      "- Use debouncing for auto-save to avoid excessive storage operations\n" +
      "- Implement proper error handling for storage operations\n" +
      "- Consider using IndexedDB for large form data\n" +
      "- Provide clear user feedback about saved state\n" +
      "- Implement data expiration policies\n" +
      "- Use proper TypeScript interfaces for type safety\n" +
      "- Test form state persistence thoroughly",
    category: "Forms",
    difficulty: "advanced",
    tags: ["forms", "reactive", "state-management", "persistence", "localStorage"],
  },
  {
    id: 173,
    question:
      "How do you implement template-driven forms in Angular and what are their limitations?",
    answer:
      "Template-driven forms in Angular use directives in the template to create and manage form controls, providing a simpler approach for basic forms:\n\n" +
      "**Basic Template-Driven Form Implementation:**\n" +
      "```typescript\n" +
      "// app.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "import { NgForm } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-root',\n" +
      "  templateUrl: './app.component.html',\n" +
      "  styleUrls: ['./app.component.css']\n" +
      "})\n" +
      "export class AppComponent {\n" +
      "  user = {\n" +
      "    name: '',\n" +
      "    email: '',\n" +
      "    age: null,\n" +
      "    country: '',\n" +
      "    newsletter: false\n" +
      "  };\n" +
      "\n" +
      "  countries = [\n" +
      "    { code: 'US', name: 'United States' },\n" +
      "    { code: 'CA', name: 'Canada' },\n" +
      "    { code: 'UK', name: 'United Kingdom' },\n" +
      "    { code: 'DE', name: 'Germany' }\n" +
      "  ];\n" +
      "\n" +
      "  onSubmit(form: NgForm) {\n" +
      "    if (form.valid) {\n" +
      "      console.log('Form submitted:', form.value);\n" +
      "      console.log('Form status:', form.status);\n" +
      "      console.log('Form touched:', form.touched);\n" +
      "      console.log('Form dirty:', form.dirty);\n" +
      "    } else {\n" +
      "      console.log('Form is invalid');\n" +
      "      this.markFormGroupTouched(form);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  onReset(form: NgForm) {\n" +
      "    form.resetForm();\n" +
      "    this.user = {\n" +
      "      name: '',\n" +
      "      email: '',\n      " +
      "      age: null,\n" +
      "      country: '',\n" +
      "      newsletter: false\n" +
      "    };\n" +
      "  }\n" +
      "\n" +
      "  // Helper method to mark all fields as touched\n" +
      "  private markFormGroupTouched(form: NgForm) {\n" +
      "    Object.keys(form.controls).forEach(key => {\n" +
      "      const control = form.controls[key];\n" +
      "      control.markAsTouched();\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template Implementation:**\n" +
      "```html\n" +
      "<!-- app.component.html -->\n" +
      '<form #userForm="ngForm" (ngSubmit)="onSubmit(userForm)" novalidate>\n' +
      "  <!-- Form status display -->\n" +
      '  <div class="form-status">\n' +
      "    <p>Form Status: {{ userForm.status }}</p>\n" +
      "    <p>Form Valid: {{ userForm.valid }}</p>\n" +
      "    <p>Form Touched: {{ userForm.touched }}</p>\n" +
      "    <p>Form Dirty: {{ userForm.dirty }}</p>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Name field -->\n" +
      '  <div class="form-group">\n' +
      '    <label for="name">Name:</label>\n' +
      "    <input \n" +
      '      type="text" \n' +
      '      id="name" \n' +
      '      name="name" \n' +
      '      [(ngModel)]="user.name" \n' +
      "      required \n" +
      '      minlength="2" \n' +
      '      maxlength="50"\n' +
      '      #name="ngModel"\n' +
      '      [class.is-invalid]="name.invalid && name.touched"\n' +
      '      [class.is-valid]="name.valid && name.touched"\n' +
      "    />\n" +
      "    \n" +
      "    <!-- Validation messages -->\n" +
      '    <div *ngIf="name.invalid && name.touched" class="invalid-feedback">\n' +
      "      <div *ngIf=\"name.errors?.['required']\">Name is required</div>\n" +
      "      <div *ngIf=\"name.errors?.['minlength']\">\n" +
      "        Name must be at least {{ name.errors?.['minlength'].requiredLength }} characters\n" +
      "      </div>\n" +
      "      <div *ngIf=\"name.errors?.['maxlength']\">\n" +
      "        Name cannot exceed {{ name.errors?.['maxlength'].requiredLength }} characters\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Email field -->\n" +
      '  <div class="form-group">\n' +
      '    <label for="email">Email:</label>\n' +
      "    <input \n" +
      '      type="email" \n' +
      '      id="email" \n' +
      '      name="email" \n' +
      '      [(ngModel)]="user.email" \n' +
      "      required \n" +
      "      email\n" +
      '      #email="ngModel"\n' +
      '      [class.is-invalid]="email.invalid && email.touched"\n' +
      "    />\n" +
      "    \n" +
      '    <div *ngIf="email.invalid && email.touched" class="invalid-feedback">\n' +
      "      <div *ngIf=\"email.errors?.['required']\">Email is required</div>\n" +
      "      <div *ngIf=\"email.errors?.['email']\">Please enter a valid email address</div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Age field -->\n" +
      '  <div class="form-group">\n' +
      '    <label for="age">Age:</label>\n' +
      "    <input \n" +
      '      type="number" \n' +
      '      id="age" \n' +
      '      name="age" \n' +
      '      [(ngModel)]="user.age" \n' +
      "      required \n" +
      '      min="18" \n' +
      '      max="100"\n' +
      '      #age="ngModel"\n' +
      '      [class.is-invalid]="age.invalid && age.touched"\n' +
      "    />\n" +
      "    \n" +
      '    <div *ngIf="age.invalid && age.touched" class="invalid-feedback">\n' +
      "      <div *ngIf=\"age.errors?.['required']\">Age is required</div>\n" +
      "      <div *ngIf=\"age.errors?.['min']\">Age must be at least {{ age.errors?.['min'].min }}</div>\n" +
      "      <div *ngIf=\"age.errors?.['max']\">Age cannot exceed {{ age.errors?.['max'].max }}</div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Country dropdown -->\n" +
      '  <div class="form-group">\n' +
      '    <label for="country">Country:</label>\n' +
      "    <select \n" +
      '      id="country" \n' +
      '      name="country" \n' +
      '      [(ngModel)]="user.country" \n' +
      "      required\n" +
      '      #country="ngModel"\n' +
      '      [class.is-invalid]="country.invalid && country.touched"\n' +
      "    >\n" +
      '      <option value="">Select a country</option>\n' +
      '      <option *ngFor="let country of countries" [value]="country.code">\n' +
      "        {{ country.name }}\n" +
      "      </option>\n" +
      "    </select>\n" +
      "    \n" +
      '    <div *ngIf="country.invalid && country.touched" class="invalid-feedback">\n' +
      "      <div *ngIf=\"country.errors?.['required']\">Please select a country</div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Newsletter checkbox -->\n" +
      '  <div class="form-group">\n' +
      '    <div class="form-check">\n' +
      "      <input \n" +
      '        type="checkbox" \n' +
      '        id="newsletter" \n' +
      '        name="newsletter" \n' +
      '        [(ngModel)]="user.newsletter"\n' +
      '        #newsletter="ngModel"\n' +
      "      />\n" +
      '      <label class="form-check-label" for="newsletter">\n' +
      "        Subscribe to newsletter\n" +
      "      </label>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Form actions -->\n" +
      '  <div class="form-actions">\n' +
      "    <button \n" +
      '      type="submit" \n' +
      '      [disabled]="userForm.invalid"\n' +
      '      class="btn btn-primary"\n' +
      "    >\n" +
      "      Submit\n" +
      "    </button>\n" +
      "    \n" +
      "    <button \n" +
      '      type="button" \n' +
      '      (click)="onReset(userForm)"\n' +
      '      class="btn btn-secondary"\n' +
      "    >\n" +
      "      Reset\n" +
      "    </button>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Form debug info -->\n" +
      '  <div class="form-debug" *ngIf="userForm.touched">\n' +
      "    <h4>Form Debug Information:</h4>\n" +
      "    <pre>{{ userForm.value | json }}</pre>\n" +
      "    <pre>{{ userForm.errors | json }}</pre>\n" +
      "  </div>\n" +
      "</form>\n" +
      "```\n\n" +
      "**Module Configuration:**\n" +
      "```typescript\n" +
      "// app.module.ts\n" +
      "import { NgModule } from '@angular/core';\n" +
      "import { BrowserModule } from '@angular/platform-browser';\n" +
      "import { FormsModule } from '@angular/forms'; // Required for template-driven forms\n" +
      "\n" +
      "import { AppComponent } from './app.component';\n" +
      "\n" +
      "@NgModule({\n" +
      "  declarations: [\n" +
      "    AppComponent\n" +
      "  ],\n" +
      "  imports: [\n" +
      "    BrowserModule,\n" +
      "    FormsModule // Import FormsModule for template-driven forms\n" +
      "  ],\n" +
      "  providers: [],\n" +
      "  bootstrap: [AppComponent]\n" +
      "})\n" +
      "export class AppModule { }\n" +
      "```\n\n" +
      "**Advanced Template-Driven Form with Custom Validation:**\n" +
      "```typescript\n" +
      "// Custom validator directive\n" +
      "import { Directive, Input } from '@angular/core';\n" +
      "import { NG_VALIDATORS, Validator, AbstractControl, ValidationErrors } from '@angular/forms';\n" +
      "\n" +
      "@Directive({\n" +
      "  selector: '[appCustomValidator]',\n" +
      "  providers: [{\n" +
      "    provide: NG_VALIDATORS,\n" +
      "    useExisting: CustomValidatorDirective,\n" +
      "    multi: true\n" +
      "  }]\n" +
      "})\n" +
      "export class CustomValidatorDirective implements Validator {\n" +
      "  @Input() appCustomValidator: string = '';\n" +
      "\n" +
      "  validate(control: AbstractControl): ValidationErrors | null {\n" +
      "    if (!control.value) {\n" +
      "      return null;\n" +
      "    }\n" +
      "\n" +
      "    // Example: Check if value contains forbidden words\n" +
      "    const forbiddenWords = this.appCustomValidator.split(',');\n" +
      "    const hasForbiddenWord = forbiddenWords.some(word => \n" +
      "      control.value.toLowerCase().includes(word.toLowerCase())\n" +
      "    );\n" +
      "\n" +
      "    return hasForbiddenWord ? { forbiddenWord: { value: control.value } } : null;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Using Custom Validator in Template:**\n" +
      "```html\n" +
      "<!-- Using custom validator directive -->\n" +
      '<div class="form-group">\n' +
      '  <label for="username">Username:</label>\n' +
      "  <input \n" +
      '    type="text" \n' +
      '    id="username" \n' +
      '    name="username" \n' +
      '    [(ngModel)]="user.username" \n' +
      "    required \n" +
      '    minlength="3"\n' +
      '    appCustomValidator="admin,root,user"\n' +
      '    #username="ngModel"\n' +
      '    [class.is-invalid]="username.invalid && username.touched"\n' +
      "  />\n" +
      "  \n" +
      '  <div *ngIf="username.invalid && username.touched" class="invalid-feedback">\n' +
      "    <div *ngIf=\"username.errors?.['required']\">Username is required</div>\n" +
      "    <div *ngIf=\"username.errors?.['minlength']\">Username must be at least 3 characters</div>\n" +
      "    <div *ngIf=\"username.errors?.['forbiddenWord']\">Username contains forbidden words</div>\n" +
      "  </div>\n" +
      "</div>\n" +
      "```\n\n" +
      "**Template-Driven Form Limitations:**\n" +
      "```typescript\n" +
      "// Limitations and when to avoid template-driven forms\n" +
      "export class TemplateDrivenLimitations {\n" +
      "  /*\n" +
      "   * LIMITATIONS:\n" +
      "   * \n" +
      "   * 1. Limited Programmatic Control:\n" +
      "   *    - Cannot easily add/remove validators at runtime\n" +
      "   *    - Difficult to implement complex validation logic\n" +
      "   *    - Hard to manage form state programmatically\n" +
      "   * \n" +
      "   * 2. Performance Issues:\n" +
      "   *    - Forms are created after view initialization\n" +
      "   *    - Can cause performance issues with large forms\n" +
      "   *    - Less efficient change detection\n" +
      "   * \n" +
      "   * 3. Testing Difficulties:\n" +
      "   *    - Harder to unit test form logic\n" +
      "   *    - Validation logic is mixed with template\n" +
      "   *    - Difficult to test form state changes\n" +
      "   * \n" +
      "   * 4. Type Safety:\n" +
      "   *    - Less TypeScript support\n" +
      "   *    - No compile-time validation of form structure\n" +
      "   *    - Runtime errors for form control access\n" +
      "   * \n" +
      "   * 5. Complex Forms:\n" +
      "   *    - Difficult to handle dynamic form fields\n" +
      "   *    - Hard to implement conditional validation\n" +
      "   *    - Limited support for nested form groups\n" +
      "   * \n" +
      "   * 6. Form State Management:\n" +
      "   *    - No built-in support for form state persistence\n" +
      "   *    - Difficult to implement auto-save functionality\n" +
      "   *    - Limited control over form lifecycle\n" +
      "   */\n" +
      "\n" +
      "  // Example of what's difficult with template-driven forms\n" +
      "  difficultOperations() {\n" +
      "    // ❌ Cannot easily add validators dynamically\n" +
      "    // ❌ Cannot easily create forms programmatically\n" +
      "    // ❌ Cannot easily implement complex validation rules\n" +
      "    // ❌ Cannot easily manage form state\n" +
      "    // ❌ Cannot easily implement form arrays\n" +
      "    // ❌ Cannot easily implement conditional fields\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**When to Use Template-Driven Forms:**\n" +
      "```typescript\n" +
      "/*\n" +
      " * USE TEMPLATE-DRIVEN FORMS WHEN:\n" +
      " * \n" +
      " * ✅ Simple forms with basic validation\n" +
      " * ✅ Quick prototyping\n" +
      " * ✅ Forms with minimal business logic\n" +
      " * ✅ When you prefer declarative approach\n" +
      " * ✅ When form structure is static\n" +
      " * ✅ When you don't need complex validation\n" +
      " * ✅ When you don't need programmatic control\n" +
      " * \n" +
      " * AVOID TEMPLATE-DRIVEN FORMS WHEN:\n" +
      " * \n" +
      " * ❌ Complex forms with dynamic fields\n" +
      " * ❌ Forms requiring programmatic control\n" +
      " * ❌ Forms with complex validation logic\n" +
      " * ❌ Forms requiring extensive testing\n" +
      " * ❌ Forms with performance requirements\n" +
      " * ❌ Forms requiring type safety\n" +
      " * ❌ Forms with state management needs\n" +
      " */\n" +
      "```\n\n" +
      "**CSS for Template-Driven Forms:**\n" +
      "```css\n" +
      "/* app.component.css */\n" +
      ".form-group {\n" +
      "  margin-bottom: 1rem;\n" +
      "}\n" +
      "\n" +
      ".form-group label {\n" +
      "  display: block;\n" +
      "  margin-bottom: 0.5rem;\n" +
      "  font-weight: bold;\n" +
      "}\n" +
      "\n" +
      ".form-group input,\n" +
      ".form-group select {\n" +
      "  width: 100%;\n" +
      "  padding: 0.5rem;\n" +
      "  border: 1px solid #ccc;\n" +
      "  border-radius: 0.25rem;\n" +
      "}\n" +
      "\n" +
      ".is-invalid {\n" +
      "  border-color: #dc3545;\n" +
      "  box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);\n" +
      "}\n" +
      "\n" +
      ".is-valid {\n" +
      "  border-color: #28a745;\n" +
      "  box-shadow: 0 0 0 0.2rem rgba(40, 167, 69, 0.25);\n" +
      "}\n" +
      "\n" +
      ".invalid-feedback {\n" +
      "  display: block;\n" +
      "  width: 100%;\n" +
      "  margin-top: 0.25rem;\n" +
      "  font-size: 0.875rem;\n" +
      "  color: #dc3545;\n" +
      "}\n" +
      "\n" +
      ".form-check {\n" +
      "  display: flex;\n" +
      "  align-items: center;\n" +
      "  margin-bottom: 1rem;\n" +
      "}\n" +
      "\n" +
      ".form-check input {\n" +
      "  width: auto;\n" +
      "  margin-right: 0.5rem;\n" +
      "}\n" +
      "\n" +
      ".form-actions {\n" +
      "  margin-top: 2rem;\n" +
      "  display: flex;\n" +
      "  gap: 1rem;\n" +
      "}\n" +
      "\n" +
      ".btn {\n" +
      "  padding: 0.5rem 1rem;\n" +
      "  border: none;\n" +
      "  border-radius: 0.25rem;\n" +
      "  cursor: pointer;\n" +
      "}\n" +
      "\n" +
      ".btn-primary {\n" +
      "  background-color: #007bff;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-secondary {\n" +
      "  background-color: #6c757d;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn:disabled {\n" +
      "  opacity: 0.6;\n" +
      "  cursor: not-allowed;\n" +
      "}\n" +
      "\n" +
      ".form-status {\n" +
      "  background-color: #f8f9fa;\n" +
      "  padding: 1rem;\n" +
      "  border-radius: 0.25rem;\n" +
      "  margin-bottom: 1rem;\n" +
      "}\n" +
      "\n" +
      ".form-debug {\n" +
      "  background-color: #f8f9fa;\n" +
      "  padding: 1rem;\n" +
      "  border-radius: 0.25rem;\n" +
      "  margin-top: 2rem;\n" +
      "}\n" +
      "\n" +
      ".form-debug pre {\n" +
      "  background-color: #e9ecef;\n" +
      "  padding: 0.5rem;\n" +
      "  border-radius: 0.25rem;\n" +
      "  overflow-x: auto;\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices for Template-Driven Forms:**\n" +
      "- Use `novalidate` attribute to disable browser validation\n" +
      "- Always provide proper error messages\n" +
      "- Use template reference variables for form controls\n" +
      "- Implement proper CSS classes for validation states\n" +
      "- Use `resetForm()` instead of `reset()` for proper cleanup\n" +
      "- Consider using reactive forms for complex scenarios\n" +
      "- Test form validation thoroughly\n" +
      "- Use proper TypeScript interfaces for form data",
    category: "Forms",
    difficulty: "intermediate",
    tags: ["forms", "template-driven", "ngModel", "validation", "limitations"],
  },
  {
    id: 174,
    question:
      "How do you implement form validation with async validators in Angular reactive forms?",
    answer:
      "Async validators in Angular reactive forms allow you to perform asynchronous validation operations like checking server-side data:\n\n" +
      "**Basic Async Validator Implementation:**\n" +
      "```typescript\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';\n" +
      "import { Observable, of, timer } from 'rxjs';\n" +
      "import { map, switchMap, catchError, debounceTime, distinctUntilChanged } from 'rxjs/operators';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class UserService {\n" +
      "  // Simulate API call to check username availability\n" +
      "  checkUsernameAvailability(username: string): Observable<boolean> {\n" +
      "    // Simulate network delay\n" +
      "    return timer(1000).pipe(\n" +
      "      map(() => {\n" +
      "        // Simulate some usernames that are taken\n" +
      "        const takenUsernames = ['admin', 'user', 'test', 'john', 'jane'];\n" +
      "        return !takenUsernames.includes(username.toLowerCase());\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  // Simulate API call to check email availability\n" +
      "  checkEmailAvailability(email: string): Observable<boolean> {\n" +
      "    return timer(800).pipe(\n" +
      "      map(() => {\n" +
      "        // Simulate some emails that are taken\n" +
      "        const takenEmails = ['admin@example.com', 'user@example.com', 'test@example.com'];\n" +
      "        return !takenEmails.includes(email.toLowerCase());\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "// Username availability validator\n" +
      "export function usernameAvailabilityValidator(userService: UserService): AsyncValidatorFn {\n" +
      "  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n" +
      "    if (!control.value || control.value.length < 3) {\n" +
      "      return of(null);\n" +
      "    }\n" +
      "\n" +
      "    return control.valueChanges.pipe(\n" +
      "      debounceTime(500), // Wait 500ms after user stops typing\n" +
      "      distinctUntilChanged(), // Only check if value actually changed\n" +
      "      switchMap(value => {\n" +
      "        if (!value || value.length < 3) {\n" +
      "          return of(null);\n" +
      "        }\n" +
      "        \n" +
      "        return userService.checkUsernameAvailability(value).pipe(\n" +
      "          map(isAvailable => isAvailable ? null : { usernameTaken: true }),\n" +
      "          catchError(() => of({ usernameCheckFailed: true }))\n" +
      "        );\n" +
      "      })\n" +
      "    );\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "// Email availability validator\n" +
      "export function emailAvailabilityValidator(userService: UserService): AsyncValidatorFn {\n" +
      "  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n" +
      "    if (!control.value) {\n" +
      "      return of(null);\n" +
      "    }\n" +
      "\n" +
      "    return control.valueChanges.pipe(\n" +
      "      debounceTime(500),\n" +
      "      distinctUntilChanged(),\n" +
      "      switchMap(value => {\n" +
      "        if (!value) {\n" +
      "          return of(null);\n" +
      "        }\n" +
      "        \n" +
      "        return userService.checkEmailAvailability(value).pipe(\n" +
      "          map(isAvailable => isAvailable ? null : { emailTaken: true }),\n" +
      "          catchError(() => of({ emailCheckFailed: true }))\n" +
      "        );\n" +
      "      })\n" +
      "    );\n" +
      "  };\n" +
      "}\n" +
      "```\n\n" +
      "**Using Async Validators in Component:**\n" +
      "```typescript\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { FormBuilder, FormGroup, Validators } from '@angular/forms';\n" +
      "import { UserService, usernameAvailabilityValidator, emailAvailabilityValidator } from './user.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-user-form',\n" +
      "  templateUrl: './user-form.component.html'\n" +
      "})\n" +
      "export class UserFormComponent implements OnInit {\n" +
      "  userForm: FormGroup;\n" +
      "  isSubmitting = false;\n" +
      "\n" +
      "  constructor(\n" +
      "    private fb: FormBuilder,\n" +
      "    private userService: UserService\n" +
      "  ) {\n" +
      "    this.userForm = this.fb.group({\n" +
      "      username: ['', \n" +
      "        [Validators.required, Validators.minLength(3), Validators.pattern(/^[a-zA-Z0-9_]+$/)]\n" +
      "      ],\n" +
      "      email: ['', \n" +
      "        [Validators.required, Validators.email]\n" +
      "      ],\n" +
      "      password: ['', \n" +
      "        [Validators.required, Validators.minLength(8)]\n" +
      "      ],\n      " +
      "      confirmPassword: ['', Validators.required]\n" +
      "    }, {\n" +
      "      validators: this.passwordMatchValidator,\n" +
      "      asyncValidators: [\n" +
      "        usernameAvailabilityValidator(this.userService),\n" +
      "        emailAvailabilityValidator(this.userService)\n" +
      "      ]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    // Add async validators to individual controls\n" +
      "    this.userForm.get('username')?.setAsyncValidators(\n" +
      "      usernameAvailabilityValidator(this.userService)\n" +
      "    );\n" +
      "    \n" +
      "    this.userForm.get('email')?.setAsyncValidators(\n" +
      "      emailAvailabilityValidator(this.userService)\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  // Password match validator\n" +
      "  passwordMatchValidator(control: AbstractControl): ValidationErrors | null {\n" +
      "    const password = control.get('password');\n" +
      "    const confirmPassword = control.get('confirmPassword');\n" +
      "\n" +
      "    if (!password || !confirmPassword) {\n" +
      "      return null;\n" +
      "    }\n" +
      "\n" +
      "    return password.value === confirmPassword.value ? null : { passwordMismatch: true };\n" +
      "  }\n" +
      "\n" +
      "  // Get form control for easier access\n" +
      "  getFormControl(controlName: string) {\n" +
      "    return this.userForm.get(controlName);\n" +
      "  }\n" +
      "\n" +
      "  // Check if control is pending (async validation in progress)\n" +
      "  isControlPending(controlName: string): boolean {\n" +
      "    const control = this.getFormControl(controlName);\n" +
      "    return control ? control.pending : false;\n" +
      "  }\n" +
      "\n" +
      "  // Get error message for control\n" +
      "  getErrorMessage(controlName: string): string {\n" +
      "    const control = this.getFormControl(controlName);\n" +
      "    if (!control || !control.errors) return '';\n" +
      "\n" +
      "    const errors = control.errors;\n" +
      "    \n" +
      "    if (errors['required']) return `${controlName} is required`;\n" +
      "    if (errors['email']) return 'Please enter a valid email';\n" +
      "    if (errors['minlength']) return `${controlName} must be at least ${errors['minlength'].requiredLength} characters`;\n" +
      "    if (errors['pattern']) return `${controlName} contains invalid characters`;\n" +
      "    if (errors['usernameTaken']) return 'Username is already taken';\n" +
      "    if (errors['emailTaken']) return 'Email is already registered';\n" +
      "    if (errors['usernameCheckFailed']) return 'Unable to verify username availability';\n" +
      "    if (errors['emailCheckFailed']) return 'Unable to verify email availability';\n" +
      "    if (errors['passwordMismatch']) return 'Passwords do not match';\n" +
      "    \n" +
      "    return 'Invalid input';\n" +
      "  }\n" +
      "\n" +
      "  // Check if control should show error\n" +
      "  shouldShowError(controlName: string): boolean {\n" +
      "    const control = this.getFormControl(controlName);\n" +
      "    return control ? (control.invalid && (control.dirty || control.touched)) : false;\n" +
      "  }\n" +
      "\n" +
      "  onSubmit() {\n" +
      "    if (this.userForm.valid) {\n" +
      "      this.isSubmitting = true;\n" +
      "      \n" +
      "      // Simulate form submission\n" +
      "      setTimeout(() => {\n" +
      "        console.log('Form submitted:', this.userForm.value);\n" +
      "        this.isSubmitting = false;\n" +
      "        this.userForm.reset();\n" +
      "      }, 2000);\n" +
      "    } else {\n" +
      "      // Mark all fields as touched to show errors\n" +
      "      Object.keys(this.userForm.controls).forEach(key => {\n" +
      "        this.userForm.get(key)?.markAsTouched();\n" +
      "      });\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template with Async Validation:**\n" +
      "```html\n" +
      "<!-- user-form.component.html -->\n" +
      '<form [formGroup]="userForm" (ngSubmit)="onSubmit()">\n' +
      "  <!-- Username field with async validation -->\n" +
      '  <div class="form-group">\n' +
      '    <label for="username">Username:</label>\n' +
      '    <div class="input-group">\n' +
      "      <input \n" +
      '        type="text" \n' +
      '        id="username" \n' +
      '        formControlName="username"\n' +
      '        placeholder="Enter username"\n' +
      "        [class.is-invalid]=\"shouldShowError('username')\"\n" +
      "        [class.is-valid]=\"getFormControl('username')?.valid && getFormControl('username')?.touched\"\n" +
      "      />\n" +
      "      \n" +
      "      <!-- Loading spinner for async validation -->\n" +
      '      <div *ngIf="isControlPending(\'username\')" class="input-group-append">\n' +
      '        <span class="input-group-text">\n' +
      '          <i class="fas fa-spinner fa-spin"></i>\n' +
      "        </span>\n" +
      "      </div>\n" +
      "      \n" +
      "      <!-- Success indicator -->\n" +
      "      <div *ngIf=\"getFormControl('username')?.valid && !isControlPending('username')\" class=\"input-group-append\">\n" +
      '        <span class="input-group-text text-success">\n' +
      '          <i class="fas fa-check"></i>\n' +
      "        </span>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      "    <!-- Error messages -->\n" +
      '    <div *ngIf="shouldShowError(\'username\')" class="invalid-feedback">\n' +
      "      {{ getErrorMessage('username') }}\n" +
      "    </div>\n" +
      "    \n" +
      "    <!-- Help text -->\n" +
      '    <small class="form-text text-muted">\n' +
      "      Username must be at least 3 characters and contain only letters, numbers, and underscores.\n" +
      "    </small>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Email field with async validation -->\n" +
      '  <div class="form-group">\n' +
      '    <label for="email">Email:</label>\n' +
      '    <div class="input-group">\n' +
      "      <input \n" +
      '        type="email" \n' +
      '        id="email" \n' +
      '        formControlName="email"\n' +
      '        placeholder="Enter email address"\n' +
      "        [class.is-invalid]=\"shouldShowError('email')\"\n" +
      "        [class.is-valid]=\"getFormControl('email')?.valid && getFormControl('email')?.touched\"\n" +
      "      />\n" +
      "      \n" +
      "      <!-- Loading spinner -->\n" +
      '      <div *ngIf="isControlPending(\'email\')" class="input-group-append">\n' +
      '        <span class="input-group-text">\n' +
      '          <i class="fas fa-spinner fa-spin"></i>\n' +
      "        </span>\n" +
      "      </div>\n" +
      "      \n" +
      "      <!-- Success indicator -->\n" +
      "      <div *ngIf=\"getFormControl('email')?.valid && !isControlPending('email')\" class=\"input-group-append\">\n" +
      '        <span class="input-group-text text-success">\n' +
      '          <i class="fas fa-check"></i>\n' +
      "        </span>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      '    <div *ngIf="shouldShowError(\'email\')" class="invalid-feedback">\n' +
      "      {{ getErrorMessage('email') }}\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Password field -->\n" +
      '  <div class="form-group">\n' +
      '    <label for="password">Password:</label>\n' +
      "    <input \n" +
      '      type="password" \n' +
      '      id="password" \n' +
      '      formControlName="password"\n' +
      '      placeholder="Enter password"\n' +
      "      [class.is-invalid]=\"shouldShowError('password')\"\n" +
      "    />\n" +
      "    \n" +
      '    <div *ngIf="shouldShowError(\'password\')" class="invalid-feedback">\n' +
      "      {{ getErrorMessage('password') }}\n" +
      "    </div>\n" +
      "    \n" +
      '    <small class="form-text text-muted">\n' +
      "      Password must be at least 8 characters long.\n" +
      "    </small>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Confirm Password field -->\n" +
      '  <div class="form-group">\n' +
      '    <label for="confirmPassword">Confirm Password:</label>\n' +
      "    <input \n" +
      '      type="password" \n' +
      '      id="confirmPassword" \n' +
      '      formControlName="confirmPassword"\n' +
      '      placeholder="Confirm password"\n' +
      "      [class.is-invalid]=\"shouldShowError('confirmPassword')\"\n" +
      "    />\n" +
      "    \n" +
      '    <div *ngIf="shouldShowError(\'confirmPassword\')" class="invalid-feedback">\n' +
      "      {{ getErrorMessage('confirmPassword') }}\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Form-level error for password mismatch -->\n" +
      '  <div *ngIf="userForm.hasError(\'passwordMismatch\')" class="alert alert-danger">\n' +
      "    Passwords do not match\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Submit button -->\n" +
      '  <div class="form-actions">\n' +
      "    <button \n" +
      '      type="submit" \n' +
      '      [disabled]="userForm.invalid || isSubmitting"\n' +
      '      class="btn btn-primary"\n' +
      "    >\n" +
      '      <span *ngIf="isSubmitting" class="spinner-border spinner-border-sm mr-2"></span>\n' +
      "      {{ isSubmitting ? 'Creating Account...' : 'Create Account' }}\n" +
      "    </button>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Form status display -->\n" +
      '  <div class="form-status mt-3">\n' +
      "    <p><strong>Form Status:</strong> {{ userForm.status }}</p>\n" +
      "    <p><strong>Form Valid:</strong> {{ userForm.valid }}</p>\n" +
      "    <p><strong>Form Pending:</strong> {{ userForm.pending }}</p>\n" +
      "  </div>\n" +
      "</form>\n" +
      "```\n\n" +
      "**Advanced Async Validator with Caching:**\n" +
      "```typescript\n" +
      "// Advanced async validator with caching and error handling\n" +
      "export class AdvancedAsyncValidator {\n" +
      "  private static cache = new Map<string, { result: boolean; timestamp: number }>();\n" +
      "  private static CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n" +
      "\n" +
      "  static usernameAvailabilityValidator(userService: UserService): AsyncValidatorFn {\n" +
      "    return (control: AbstractControl): Observable<ValidationErrors | null> => {\n" +
      "      if (!control.value || control.value.length < 3) {\n" +
      "        return of(null);\n" +
      "      }\n" +
      "\n" +
      "      const username = control.value.toLowerCase();\n" +
      "      const cacheKey = `username_${username}`;\n" +
      "      const cached = this.cache.get(cacheKey);\n" +
      "      \n" +
      "      // Check cache first\n" +
      "      if (cached && (Date.now() - cached.timestamp) < this.CACHE_DURATION) {\n" +
      "        return of(cached.result ? null : { usernameTaken: true });\n" +
      "      }\n" +
      "\n" +
      "      return control.valueChanges.pipe(\n" +
      "        debounceTime(500),\n" +
      "        distinctUntilChanged(),\n" +
      "        switchMap(value => {\n" +
      "          if (!value || value.length < 3) {\n" +
      "            return of(null);\n" +
      "          }\n" +
      "          \n" +
      "          return userService.checkUsernameAvailability(value).pipe(\n" +
      "            map(isAvailable => {\n" +
      "              // Cache the result\n" +
      "              this.cache.set(cacheKey, {\n" +
      "                result: isAvailable,\n" +
      "                timestamp: Date.now()\n" +
      "              });\n" +
      "              \n" +
      "              return isAvailable ? null : { usernameTaken: true };\n" +
      "            }),\n" +
      "            catchError(error => {\n" +
      "              console.error('Username validation error:', error);\n" +
      "              return of({ usernameCheckFailed: true });\n" +
      "            })\n" +
      "          );\n" +
      "        })\n" +
      "      );\n" +
      "    };\n" +
      "  }\n" +
      "\n" +
      "  // Clear cache method\n" +
      "  static clearCache(): void {\n" +
      "    this.cache.clear();\n" +
      "  }\n" +
      "\n" +
      "  // Clear specific cache entry\n" +
      "  static clearCacheEntry(key: string): void {\n" +
      "    this.cache.delete(key);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**CSS for Async Validation:**\n" +
      "```css\n" +
      "/* user-form.component.css */\n" +
      ".form-group {\n" +
      "  margin-bottom: 1.5rem;\n" +
      "}\n" +
      "\n" +
      ".input-group {\n" +
      "  position: relative;\n" +
      "}\n" +
      "\n" +
      ".input-group-text {\n" +
      "  background-color: #f8f9fa;\n" +
      "  border: 1px solid #ced4da;\n" +
      "  border-left: none;\n" +
      "}\n" +
      "\n" +
      ".text-success {\n" +
      "  color: #28a745 !important;\n" +
      "}\n" +
      "\n" +
      ".fa-spinner {\n" +
      "  animation: spin 1s linear infinite;\n" +
      "}\n" +
      "\n" +
      "@keyframes spin {\n" +
      "  0% { transform: rotate(0deg); }\n" +
      "  100% { transform: rotate(360deg); }\n" +
      "}\n" +
      "\n" +
      ".spinner-border-sm {\n" +
      "  width: 1rem;\n" +
      "  height: 1rem;\n" +
      "}\n" +
      "\n" +
      ".form-status {\n" +
      "  background-color: #f8f9fa;\n" +
      "  padding: 1rem;\n" +
      "  border-radius: 0.25rem;\n" +
      "  border: 1px solid #dee2e6;\n" +
      "}\n" +
      "\n" +
      ".alert {\n" +
      "  padding: 0.75rem 1.25rem;\n" +
      "  margin-bottom: 1rem;\n" +
      "  border: 1px solid transparent;\n" +
      "  border-radius: 0.25rem;\n" +
      "}\n" +
      "\n" +
      ".alert-danger {\n" +
      "  color: #721c24;\n" +
      "  background-color: #f8d7da;\n" +
      "  border-color: #f5c6cb;\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices for Async Validators:**\n" +
      "- Use debouncing to avoid excessive API calls\n" +
      "- Implement proper error handling\n" +
      "- Use caching to improve performance\n" +
      "- Provide visual feedback for pending validation\n" +
      "- Handle network errors gracefully\n" +
      "- Use distinctUntilChanged to avoid duplicate calls\n" +
      "- Consider implementing retry logic for failed validations\n" +
      "- Test async validators thoroughly\n" +
      "- Use proper TypeScript types for better type safety",
    category: "Forms",
    difficulty: "advanced",
    tags: ["forms", "reactive", "async-validators", "validation", "rxjs"],
  },
  {
    id: 175,
    question: "How do you implement form arrays with nested form groups in Angular reactive forms?",
    answer:
      "Form arrays with nested form groups allow you to create complex dynamic forms with multiple levels of data structure:\n\n" +
      "**Complex Form Array Implementation:**\n" +
      "```typescript\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { FormBuilder, FormGroup, FormArray, FormControl, Validators } from '@angular/forms';\n" +
      "\n" +
      "interface Address {\n" +
      "  street: string;\n" +
      "  city: string;\n" +
      "  zipCode: string;\n" +
      "  country: string;\n" +
      "}\n" +
      "\n" +
      "interface Contact {\n" +
      "  type: string;\n" +
      "  value: string;\n" +
      "  isPrimary: boolean;\n" +
      "}\n" +
      "\n" +
      "interface Employee {\n" +
      "  name: string;\n" +
      "  position: string;\n" +
      "  salary: number;\n" +
      "  addresses: Address[];\n" +
      "  contacts: Contact[];\n" +
      "}\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-complex-form',\n" +
      "  templateUrl: './complex-form.component.html'\n" +
      "})\n" +
      "export class ComplexFormComponent implements OnInit {\n" +
      "  employeeForm: FormGroup;\n" +
      "  \n" +
      "  contactTypes = [\n" +
      "    { value: 'email', label: 'Email' },\n" +
      "    { value: 'phone', label: 'Phone' },\n" +
      "    { value: 'mobile', label: 'Mobile' }\n" +
      "  ];\n" +
      "  \n" +
      "  countries = [\n" +
      "    { code: 'US', name: 'United States' },\n" +
      "    { code: 'CA', name: 'Canada' },\n" +
      "    { code: 'UK', name: 'United Kingdom' },\n" +
      "    { code: 'DE', name: 'Germany' }\n" +
      "  ];\n" +
      "\n" +
      "  constructor(private fb: FormBuilder) {\n" +
      "    this.employeeForm = this.fb.group({\n" +
      "      name: ['', [Validators.required, Validators.minLength(2)]],\n" +
      "      position: ['', Validators.required],\n" +
      "      salary: [null, [Validators.required, Validators.min(0)]],\n" +
      "      addresses: this.fb.array([\n" +
      "        this.createAddressGroup()\n" +
      "      ]),\n" +
      "      contacts: this.fb.array([\n" +
      "        this.createContactGroup()\n" +
      "      ])\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    // Load existing data if available\n" +
      "    this.loadEmployeeData();\n" +
      "  }\n" +
      "\n" +
      "  // Create address FormGroup\n" +
      "  createAddressGroup(): FormGroup {\n" +
      "    return this.fb.group({\n" +
      "      street: ['', Validators.required],\n" +
      "      city: ['', Validators.required],\n" +
      "      zipCode: ['', [Validators.required, Validators.pattern(/^[0-9]{5}$/)]],\n" +
      "      country: ['', Validators.required]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Create contact FormGroup\n" +
      "  createContactGroup(): FormGroup {\n" +
      "    return this.fb.group({\n" +
      "      type: ['email', Validators.required],\n" +
      "      value: ['', Validators.required],\n" +
      "      isPrimary: [false]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Get FormArray getters\n" +
      "  get addressesArray(): FormArray {\n" +
      "    return this.employeeForm.get('addresses') as FormArray;\n" +
      "  }\n" +
      "\n" +
      "  get contactsArray(): FormArray {\n" +
      "    return this.employeeForm.get('contacts') as FormArray;\n" +
      "  }\n" +
      "\n" +
      "  // Address methods\n" +
      "  addAddress() {\n" +
      "    this.addressesArray.push(this.createAddressGroup());\n" +
      "  }\n" +
      "\n" +
      "  removeAddress(index: number) {\n" +
      "    if (this.addressesArray.length > 1) {\n" +
      "      this.addressesArray.removeAt(index);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  getAddressGroup(index: number): FormGroup {\n" +
      "    return this.addressesArray.at(index) as FormGroup;\n" +
      "  }\n" +
      "\n" +
      "  // Contact methods\n" +
      "  addContact() {\n" +
      "    this.contactsArray.push(this.createContactGroup());\n" +
      "  }\n" +
      "\n" +
      "  removeContact(index: number) {\n" +
      "    if (this.contactsArray.length > 1) {\n" +
      "      this.contactsArray.removeAt(index);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  getContactGroup(index: number): FormGroup {\n" +
      "    return this.contactsArray.at(index) as FormGroup;\n" +
      "  }\n" +
      "\n" +
      "  // Handle primary contact selection\n" +
      "  onPrimaryContactChange(selectedIndex: number) {\n" +
      "    this.contactsArray.controls.forEach((control, index) => {\n" +
      "      if (index !== selectedIndex) {\n" +
      "        control.get('isPrimary')?.setValue(false);\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Load employee data (simulate API call)\n" +
      "  loadEmployeeData() {\n" +
      "    const employeeData: Employee = {\n" +
      "      name: 'John Doe',\n" +
      "      position: 'Senior Developer',\n" +
      "      salary: 75000,\n" +
      "      addresses: [\n" +
      "        {\n" +
      "          street: '123 Main St',\n" +
      "          city: 'New York',\n" +
      "          zipCode: '10001',\n" +
      "          country: 'US'\n" +
      "        }\n" +
      "      ],\n" +
      "      contacts: [\n" +
      "        {\n" +
      "          type: 'email',\n" +
      "          value: 'john.doe@example.com',\n" +
      "          isPrimary: true\n" +
      "        },\n" +
      "        {\n" +
      "          type: 'phone',\n" +
      "          value: '+1-555-123-4567',\n" +
      "          isPrimary: false\n" +
      "        }\n" +
      "      ]\n" +
      "    };\n" +
      "\n" +
      "    this.populateForm(employeeData);\n" +
      "  }\n" +
      "\n" +
      "  // Populate form with data\n" +
      "  populateForm(employeeData: Employee) {\n" +
      "    // Set basic fields\n" +
      "    this.employeeForm.patchValue({\n" +
      "      name: employeeData.name,\n" +
      "      position: employeeData.position,\n" +
      "      salary: employeeData.salary\n" +
      "    });\n" +
      "\n" +
      "    // Clear existing arrays\n" +
      "    this.addressesArray.clear();\n" +
      "    this.contactsArray.clear();\n" +
      "\n" +
      "    // Add addresses\n" +
      "    employeeData.addresses.forEach(address => {\n" +
      "      this.addressesArray.push(this.fb.group({\n" +
      "        street: [address.street, Validators.required],\n" +
      "        city: [address.city, Validators.required],\n" +
      "        zipCode: [address.zipCode, [Validators.required, Validators.pattern(/^[0-9]{5}$/)]],\n" +
      "        country: [address.country, Validators.required]\n" +
      "      }));\n" +
      "    });\n" +
      "\n" +
      "    // Add contacts\n" +
      "    employeeData.contacts.forEach(contact => {\n" +
      "      this.contactsArray.push(this.fb.group({\n" +
      "        type: [contact.type, Validators.required],\n" +
      "        value: [contact.value, Validators.required],\n" +
      "        isPrimary: [contact.isPrimary]\n" +
      "      }));\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Form submission\n" +
      "  onSubmit() {\n" +
      "    if (this.employeeForm.valid) {\n" +
      "      console.log('Form submitted:', this.employeeForm.value);\n" +
      "      console.log('Raw form value:', this.employeeForm.getRawValue());\n" +
      "      \n" +
      "      // Process the form data\n" +
      "      this.processFormData();\n" +
      "    } else {\n" +
      "      this.markFormGroupTouched(this.employeeForm);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Process form data\n" +
      "  processFormData() {\n" +
      "    const formValue = this.employeeForm.value;\n" +
      "    \n" +
      "    // Find primary contact\n" +
      "    const primaryContact = formValue.contacts.find((contact: Contact) => contact.isPrimary);\n" +
      "    \n" +
      "    // Process addresses\n" +
      "    const processedAddresses = formValue.addresses.map((address: Address) => ({\n" +
      "      ...address,\n" +
      "      fullAddress: `${address.street}, ${address.city}, ${address.zipCode}, ${address.country}`\n" +
      "    }));\n" +
      "    \n" +
      "    const processedData = {\n" +
      "      ...formValue,\n" +
      "      addresses: processedAddresses,\n" +
      "      primaryContact: primaryContact,\n" +
      "      totalContacts: formValue.contacts.length,\n      " +
      "      totalAddresses: formValue.addresses.length\n" +
      "    };\n" +
      "    \n" +
      "    console.log('Processed data:', processedData);\n" +
      "  }\n" +
      "\n" +
      "  // Mark all form controls as touched\n" +
      "  private markFormGroupTouched(formGroup: FormGroup) {\n" +
      "    Object.keys(formGroup.controls).forEach(key => {\n" +
      "      const control = formGroup.get(key);\n" +
      "      \n" +
      "      if (control instanceof FormGroup) {\n" +
      "        this.markFormGroupTouched(control);\n" +
      "      } else if (control instanceof FormArray) {\n" +
      "        control.controls.forEach(arrayControl => {\n" +
      "          if (arrayControl instanceof FormGroup) {\n" +
      "            this.markFormGroupTouched(arrayControl);\n" +
      "          } else {\n" +
      "            arrayControl.markAsTouched();\n" +
      "          }\n" +
      "        });\n" +
      "      } else {\n" +
      "        control?.markAsTouched();\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  // Reset form\n" +
      "  resetForm() {\n" +
      "    this.employeeForm.reset();\n" +
      "    \n" +
      "    // Reset arrays to have one item each\n" +
      "    this.addressesArray.clear();\n" +
      "    this.contactsArray.clear();\n" +
      "    \n" +
      "    this.addressesArray.push(this.createAddressGroup());\n" +
      "    this.contactsArray.push(this.createContactGroup());\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template Implementation:**\n" +
      "```html\n" +
      "<!-- complex-form.component.html -->\n" +
      '<form [formGroup]="employeeForm" (ngSubmit)="onSubmit()">\n' +
      "  <!-- Basic Information -->\n" +
      '  <div class="form-section">\n' +
      "    <h3>Basic Information</h3>\n" +
      "    \n" +
      '    <div class="form-row">\n' +
      '      <div class="form-group">\n' +
      "        <label>Name:</label>\n" +
      '        <input formControlName="name" placeholder="Enter employee name" />\n' +
      "        <div *ngIf=\"employeeForm.get('name')?.invalid && employeeForm.get('name')?.touched\" class=\"error\">\n" +
      "          Name is required and must be at least 2 characters\n" +
      "        </div>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="form-group">\n' +
      "        <label>Position:</label>\n" +
      '        <input formControlName="position" placeholder="Enter position" />\n' +
      "        <div *ngIf=\"employeeForm.get('position')?.invalid && employeeForm.get('position')?.touched\" class=\"error\">\n" +
      "          Position is required\n" +
      "        </div>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="form-group">\n' +
      "        <label>Salary:</label>\n" +
      '        <input type="number" formControlName="salary" placeholder="Enter salary" />\n' +
      "        <div *ngIf=\"employeeForm.get('salary')?.invalid && employeeForm.get('salary')?.touched\" class=\"error\">\n" +
      "          Salary is required and must be positive\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Addresses Section -->\n" +
      '  <div class="form-section">\n' +
      "    <h3>Addresses</h3>\n" +
      "    \n" +
      '    <div formArrayName="addresses">\n' +
      "      <div \n" +
      '        *ngFor="let address of addressesArray.controls; let i = index" \n' +
      '        [formGroupName]="i"\n' +
      '        class="address-item"\n' +
      "      >\n" +
      '        <div class="address-header">\n' +
      "          <h4>Address {{i + 1}}</h4>\n" +
      "          <button \n" +
      '            type="button" \n' +
      '            (click)="removeAddress(i)"\n' +
      '            [disabled]="addressesArray.length <= 1"\n' +
      '            class="btn btn-danger btn-sm"\n' +
      "          >\n" +
      "            Remove\n" +
      "          </button>\n" +
      "        </div>\n" +
      "        \n" +
      '        <div class="form-row">\n' +
      '          <div class="form-group">\n' +
      "            <label>Street:</label>\n" +
      '            <input formControlName="street" placeholder="Enter street address" />\n' +
      "            <div *ngIf=\"getAddressGroup(i).get('street')?.invalid && getAddressGroup(i).get('street')?.touched\" class=\"error\">\n" +
      "              Street is required\n" +
      "            </div>\n" +
      "          </div>\n" +
      "          \n" +
      '          <div class="form-group">\n' +
      "            <label>City:</label>\n" +
      '            <input formControlName="city" placeholder="Enter city" />\n' +
      "            <div *ngIf=\"getAddressGroup(i).get('city')?.invalid && getAddressGroup(i).get('city')?.touched\" class=\"error\">\n" +
      "              City is required\n" +
      "            </div>\n" +
      "          </div>\n" +
      "        </div>\n" +
      "        \n" +
      '        <div class="form-row">\n' +
      '          <div class="form-group">\n' +
      "            <label>ZIP Code:</label>\n" +
      '            <input formControlName="zipCode" placeholder="Enter ZIP code" />\n' +
      "            <div *ngIf=\"getAddressGroup(i).get('zipCode')?.invalid && getAddressGroup(i).get('zipCode')?.touched\" class=\"error\">\n" +
      "              ZIP code is required and must be 5 digits\n" +
      "            </div>\n" +
      "          </div>\n" +
      "          \n" +
      '          <div class="form-group">\n' +
      "            <label>Country:</label>\n" +
      '            <select formControlName="country">\n' +
      '              <option value="">Select Country</option>\n' +
      '              <option *ngFor="let country of countries" [value]="country.code">\n' +
      "                {{ country.name }}\n" +
      "              </option>\n" +
      "            </select>\n" +
      "            <div *ngIf=\"getAddressGroup(i).get('country')?.invalid && getAddressGroup(i).get('country')?.touched\" class=\"error\">\n" +
      "              Country is required\n" +
      "            </div>\n" +
      "          </div>\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      '    <button type="button" (click)="addAddress()" class="btn btn-primary">\n' +
      "      Add Address\n" +
      "    </button>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Contacts Section -->\n" +
      '  <div class="form-section">\n' +
      "    <h3>Contacts</h3>\n" +
      "    \n" +
      '    <div formArrayName="contacts">\n' +
      "      <div \n" +
      '        *ngFor="let contact of contactsArray.controls; let i = index" \n' +
      '        [formGroupName]="i"\n' +
      '        class="contact-item"\n' +
      "      >\n" +
      '        <div class="contact-header">\n' +
      "          <h4>Contact {{i + 1}}</h4>\n" +
      "          <button \n" +
      '            type="button" \n' +
      '            (click)="removeContact(i)"\n' +
      '            [disabled]="contactsArray.length <= 1"\n' +
      '            class="btn btn-danger btn-sm"\n' +
      "          >\n" +
      "            Remove\n" +
      "          </button>\n" +
      "        </div>\n" +
      "        \n" +
      '        <div class="form-row">\n' +
      '          <div class="form-group">\n' +
      "            <label>Type:</label>\n" +
      '            <select formControlName="type">\n' +
      '              <option *ngFor="let type of contactTypes" [value]="type.value">\n' +
      "                {{ type.label }}\n" +
      "              </option>\n" +
      "            </select>\n" +
      "            <div *ngIf=\"getContactGroup(i).get('type')?.invalid && getContactGroup(i).get('type')?.touched\" class=\"error\">\n" +
      "              Contact type is required\n" +
      "            </div>\n" +
      "          </div>\n" +
      "          \n" +
      '          <div class="form-group">\n' +
      "            <label>Value:</label>\n" +
      '            <input formControlName="value" placeholder="Enter contact value" />\n' +
      "            <div *ngIf=\"getContactGroup(i).get('value')?.invalid && getContactGroup(i).get('value')?.touched\" class=\"error\">\n" +
      "              Contact value is required\n" +
      "            </div>\n" +
      "          </div>\n" +
      "          \n" +
      '          <div class="form-group">\n' +
      '            <div class="form-check">\n' +
      "              <input \n" +
      '                type="checkbox" \n' +
      '                formControlName="isPrimary"\n' +
      '                (change)="onPrimaryContactChange(i)"\n' +
      '                id="primary_{{i}}"\n' +
      "              />\n" +
      '              <label for="primary_{{i}}">Primary Contact</label>\n' +
      "            </div>\n" +
      "          </div>\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      '    <button type="button" (click)="addContact()" class="btn btn-primary">\n' +
      "      Add Contact\n" +
      "    </button>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Form Actions -->\n" +
      '  <div class="form-actions">\n' +
      '    <button type="submit" [disabled]="employeeForm.invalid" class="btn btn-success">\n' +
      "      Submit\n" +
      "    </button>\n" +
      "    \n" +
      '    <button type="button" (click)="resetForm()" class="btn btn-secondary">\n' +
      "      Reset\n" +
      "    </button>\n" +
      "    \n" +
      '    <button type="button" (click)="loadEmployeeData()" class="btn btn-info">\n' +
      "      Load Sample Data\n" +
      "    </button>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Form Debug Info -->\n" +
      '  <div class="form-debug" *ngIf="employeeForm.touched">\n' +
      "    <h4>Form Debug Information:</h4>\n" +
      "    <pre>{{ employeeForm.value | json }}</pre>\n" +
      "    <pre>{{ employeeForm.errors | json }}</pre>\n" +
      "  </div>\n" +
      "</form>\n" +
      "```\n\n" +
      "**CSS for Complex Forms:**\n" +
      "```css\n" +
      "/* complex-form.component.css */\n" +
      ".form-section {\n" +
      "  margin-bottom: 2rem;\n" +
      "  padding: 1.5rem;\n" +
      "  border: 1px solid #dee2e6;\n" +
      "  border-radius: 0.5rem;\n" +
      "  background-color: #f8f9fa;\n" +
      "}\n" +
      "\n" +
      ".form-section h3 {\n" +
      "  margin-bottom: 1.5rem;\n" +
      "  color: #495057;\n" +
      "  border-bottom: 2px solid #007bff;\n" +
      "  padding-bottom: 0.5rem;\n" +
      "}\n" +
      "\n" +
      ".form-row {\n" +
      "  display: flex;\n" +
      "  gap: 1rem;\n" +
      "  margin-bottom: 1rem;\n" +
      "}\n" +
      "\n" +
      ".form-group {\n" +
      "  flex: 1;\n" +
      "  margin-bottom: 1rem;\n" +
      "}\n" +
      "\n" +
      ".form-group label {\n" +
      "  display: block;\n" +
      "  margin-bottom: 0.5rem;\n" +
      "  font-weight: bold;\n" +
      "  color: #495057;\n" +
      "}\n" +
      "\n" +
      ".form-group input,\n" +
      ".form-group select {\n" +
      "  width: 100%;\n" +
      "  padding: 0.5rem;\n" +
      "  border: 1px solid #ced4da;\n" +
      "  border-radius: 0.25rem;\n" +
      "  font-size: 1rem;\n" +
      "}\n" +
      "\n" +
      ".address-item,\n" +
      ".contact-item {\n" +
      "  margin-bottom: 1.5rem;\n" +
      "  padding: 1rem;\n" +
      "  background-color: white;\n" +
      "  border: 1px solid #dee2e6;\n" +
      "  border-radius: 0.25rem;\n" +
      "}\n" +
      "\n" +
      ".address-header,\n" +
      ".contact-header {\n" +
      "  display: flex;\n" +
      "  justify-content: space-between;\n" +
      "  align-items: center;\n" +
      "  margin-bottom: 1rem;\n" +
      "}\n" +
      "\n" +
      ".address-header h4,\n" +
      ".contact-header h4 {\n" +
      "  margin: 0;\n" +
      "  color: #495057;\n" +
      "}\n" +
      "\n" +
      ".form-check {\n" +
      "  display: flex;\n" +
      "  align-items: center;\n" +
      "  margin-top: 1.5rem;\n" +
      "}\n" +
      "\n" +
      ".form-check input {\n" +
      "  width: auto;\n" +
      "  margin-right: 0.5rem;\n" +
      "}\n" +
      "\n" +
      ".form-check label {\n" +
      "  margin: 0;\n" +
      "  font-weight: normal;\n" +
      "}\n" +
      "\n" +
      ".error {\n" +
      "  color: #dc3545;\n" +
      "  font-size: 0.875rem;\n" +
      "  margin-top: 0.25rem;\n" +
      "}\n" +
      "\n" +
      ".form-actions {\n" +
      "  margin-top: 2rem;\n" +
      "  display: flex;\n" +
      "  gap: 1rem;\n" +
      "  justify-content: center;\n" +
      "}\n" +
      "\n" +
      ".btn {\n" +
      "  padding: 0.5rem 1rem;\n" +
      "  border: none;\n" +
      "  border-radius: 0.25rem;\n" +
      "  cursor: pointer;\n" +
      "  font-size: 1rem;\n" +
      "}\n" +
      "\n" +
      ".btn-primary {\n" +
      "  background-color: #007bff;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-danger {\n" +
      "  background-color: #dc3545;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-success {\n" +
      "  background-color: #28a745;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-secondary {\n" +
      "  background-color: #6c757d;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-info {\n" +
      "  background-color: #17a2b8;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-sm {\n" +
      "  padding: 0.25rem 0.5rem;\n" +
      "  font-size: 0.875rem;\n" +
      "}\n" +
      "\n" +
      ".btn:disabled {\n" +
      "  opacity: 0.6;\n" +
      "  cursor: not-allowed;\n" +
      "}\n" +
      "\n" +
      ".form-debug {\n" +
      "  margin-top: 2rem;\n" +
      "  padding: 1rem;\n" +
      "  background-color: #f8f9fa;\n" +
      "  border: 1px solid #dee2e6;\n" +
      "  border-radius: 0.25rem;\n" +
      "}\n" +
      "\n" +
      ".form-debug pre {\n" +
      "  background-color: #e9ecef;\n" +
      "  padding: 0.5rem;\n" +
      "  border-radius: 0.25rem;\n" +
      "  overflow-x: auto;\n" +
      "  font-size: 0.875rem;\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices for Complex Form Arrays:**\n" +
      "- Use proper TypeScript interfaces for type safety\n" +
      "- Implement proper validation at all levels\n" +
      "- Use getter methods for cleaner template access\n" +
      "- Handle form state properly (touched, dirty, valid)\n" +
      "- Implement proper error handling and display\n" +
      "- Use consistent naming conventions\n" +
      "- Provide clear visual feedback\n" +
      "- Test complex form scenarios thoroughly\n" +
      "- Consider performance implications of large forms\n" +
      "- Implement proper form reset functionality",
    category: "Forms",
    difficulty: "advanced",
    tags: ["forms", "reactive", "FormArray", "nested", "complex"],
  },
  {
    id: 176,
    question:
      "How do you implement form validation with conditional logic in Angular reactive forms?",
    answer:
      "Conditional validation in Angular reactive forms allows you to dynamically add/remove validators based on form state or user input:\n\n" +
      "**Conditional Validation Implementation:**\n" +
      "```typescript\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { FormBuilder, FormGroup, Validators, AbstractControl } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-conditional-form',\n" +
      "  templateUrl: './conditional-form.component.html'\n" +
      "})\n" +
      "export class ConditionalFormComponent implements OnInit {\n" +
      "  userForm: FormGroup;\n" +
      "  \n" +
      "  userTypes = [\n" +
      "    { value: 'individual', label: 'Individual' },\n" +
      "    { value: 'company', label: 'Company' },\n" +
      "    { value: 'nonprofit', label: 'Non-Profit' }\n" +
      "  ];\n" +
      "  \n" +
      "  countries = [\n" +
      "    { code: 'US', name: 'United States' },\n" +
      "    { code: 'CA', name: 'Canada' },\n" +
      "    { code: 'UK', name: 'United Kingdom' }\n" +
      "  ];\n" +
      "\n" +
      "  constructor(private fb: FormBuilder) {\n" +
      "    this.userForm = this.fb.group({\n" +
      "      userType: ['individual', Validators.required],\n" +
      "      \n" +
      "      // Individual fields\n" +
      "      firstName: ['', Validators.required],\n" +
      "      lastName: ['', Validators.required],\n" +
      "      dateOfBirth: ['', Validators.required],\n" +
      "      \n" +
      "      // Company fields\n" +
      "      companyName: [''],\n" +
      "      taxId: [''],\n" +
      "      businessType: [''],\n" +
      "      \n" +
      "      // Non-profit fields\n" +
      "      nonprofitName: [''],\n" +
      "      registrationNumber: [''],\n" +
      "      \n" +
      "      // Common fields\n" +
      "      email: ['', [Validators.required, Validators.email]],\n" +
      "      phone: ['', Validators.required],\n" +
      "      address: this.fb.group({\n" +
      "        street: ['', Validators.required],\n" +
      "        city: ['', Validators.required],\n" +
      "        zipCode: ['', Validators.required],\n" +
      "        country: ['', Validators.required]\n" +
      "      }),\n" +
      "      \n" +
      "      // Conditional fields\n" +
      "      hasSpouse: [false],\n" +
      "      spouseName: [''],\n" +
      "      spouseEmail: [''],\n      " +
      "      \n" +
      "      // Age-dependent fields\n" +
      "      isMinor: [false],\n" +
      "      guardianName: [''],\n" +
      "      guardianPhone: [''],\n" +
      "      \n" +
      "      // Country-specific fields\n" +
      "      ssn: [''],\n" +
      "      sin: [''],\n" +
      "      ni: [''],\n" +
      "      \n" +
      "      // Terms and conditions\n" +
      "      acceptTerms: [false, Validators.requiredTrue],\n" +
      "      acceptMarketing: [false]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    // Set up conditional validation\n" +
      "    this.setupConditionalValidation();\n" +
      "  }\n" +
      "\n" +
      "  setupConditionalValidation() {\n" +
      "    // User type change handler\n" +
      "    this.userForm.get('userType')?.valueChanges.subscribe(userType => {\n" +
      "      this.handleUserTypeChange(userType);\n" +
      "    });\n" +
      "\n" +
      "    // Spouse fields handler\n" +
      "    this.userForm.get('hasSpouse')?.valueChanges.subscribe(hasSpouse => {\n" +
      "      this.handleSpouseFields(hasSpouse);\n" +
      "    });\n" +
      "\n" +
      "    // Age-dependent fields handler\n" +
      "    this.userForm.get('dateOfBirth')?.valueChanges.subscribe(dateOfBirth => {\n" +
      "      this.handleAgeDependentFields(dateOfBirth);\n" +
      "    });\n" +
      "\n" +
      "    // Country-specific fields handler\n" +
      "    this.userForm.get('address.country')?.valueChanges.subscribe(country => {\n" +
      "      this.handleCountrySpecificFields(country);\n" +
      "    });\n" +
      "\n" +
      "    // Initial setup\n" +
      "    this.handleUserTypeChange(this.userForm.get('userType')?.value);\n" +
      "    this.handleSpouseFields(this.userForm.get('hasSpouse')?.value);\n" +
      "    this.handleAgeDependentFields(this.userForm.get('dateOfBirth')?.value);\n" +
      "    this.handleCountrySpecificFields(this.userForm.get('address.country')?.value);\n" +
      "  }\n" +
      "\n" +
      "  handleUserTypeChange(userType: string) {\n" +
      "    const companyName = this.userForm.get('companyName');\n" +
      "    const taxId = this.userForm.get('taxId');\n" +
      "    const businessType = this.userForm.get('businessType');\n" +
      "    const nonprofitName = this.userForm.get('nonprofitName');\n" +
      "    const registrationNumber = this.userForm.get('registrationNumber');\n" +
      "\n" +
      "    if (userType === 'company') {\n" +
      "      // Enable company fields\n" +
      "      companyName?.setValidators([Validators.required, Validators.minLength(2)]);\n" +
      "      taxId?.setValidators([Validators.required, Validators.pattern(/^[0-9]{2}-[0-9]{7}$/)]);\n" +
      "      businessType?.setValidators([Validators.required]);\n" +
      "      \n" +
      "      // Disable non-profit fields\n" +
      "      nonprofitName?.clearValidators();\n" +
      "      registrationNumber?.clearValidators();\n" +
      "      nonprofitName?.setValue('');\n" +
      "      registrationNumber?.setValue('');\n" +
      "    } else if (userType === 'nonprofit') {\n" +
      "      // Enable non-profit fields\n" +
      "      nonprofitName?.setValidators([Validators.required, Validators.minLength(2)]);\n" +
      "      registrationNumber?.setValidators([Validators.required, Validators.pattern(/^[A-Z]{2}[0-9]{6}$/)]);\n" +
      "      \n" +
      "      // Disable company fields\n" +
      "      companyName?.clearValidators();\n" +
      "      taxId?.clearValidators();\n" +
      "      businessType?.clearValidators();\n" +
      "      companyName?.setValue('');\n" +
      "      taxId?.setValue('');\n" +
      "      businessType?.setValue('');\n" +
      "    } else {\n" +
      "      // Individual - disable both company and non-profit fields\n" +
      "      companyName?.clearValidators();\n" +
      "      taxId?.clearValidators();\n" +
      "      businessType?.clearValidators();\n" +
      "      nonprofitName?.clearValidators();\n" +
      "      registrationNumber?.clearValidators();\n" +
      "      \n" +
      "      companyName?.setValue('');\n" +
      "      taxId?.setValue('');\n" +
      "      businessType?.setValue('');\n" +
      "      nonprofitName?.setValue('');\n" +
      "      registrationNumber?.setValue('');\n" +
      "    }\n" +
      "\n" +
      "    // Update validation\n" +
      "    companyName?.updateValueAndValidity();\n" +
      "    taxId?.updateValueAndValidity();\n" +
      "    businessType?.updateValueAndValidity();\n" +
      "    nonprofitName?.updateValueAndValidity();\n" +
      "    registrationNumber?.updateValueAndValidity();\n" +
      "  }\n" +
      "\n" +
      "  handleSpouseFields(hasSpouse: boolean) {\n" +
      "    const spouseName = this.userForm.get('spouseName');\n" +
      "    const spouseEmail = this.userForm.get('spouseEmail');\n" +
      "\n" +
      "    if (hasSpouse) {\n" +
      "      spouseName?.setValidators([Validators.required, Validators.minLength(2)]);\n" +
      "      spouseEmail?.setValidators([Validators.required, Validators.email]);\n" +
      "    } else {\n" +
      "      spouseName?.clearValidators();\n" +
      "      spouseEmail?.clearValidators();\n" +
      "      spouseName?.setValue('');\n" +
      "      spouseEmail?.setValue('');\n" +
      "    }\n" +
      "\n" +
      "    spouseName?.updateValueAndValidity();\n" +
      "    spouseEmail?.updateValueAndValidity();\n" +
      "  }\n" +
      "\n" +
      "  handleAgeDependentFields(dateOfBirth: string) {\n" +
      "    if (!dateOfBirth) return;\n" +
      "\n" +
      "    const birthDate = new Date(dateOfBirth);\n" +
      "    const today = new Date();\n" +
      "    const age = today.getFullYear() - birthDate.getFullYear();\n" +
      "    const isMinor = age < 18;\n" +
      "\n" +
      "    const guardianName = this.userForm.get('guardianName');\n" +
      "    const guardianPhone = this.userForm.get('guardianPhone');\n" +
      "\n" +
      "    this.userForm.patchValue({ isMinor });\n" +
      "\n" +
      "    if (isMinor) {\n" +
      "      guardianName?.setValidators([Validators.required, Validators.minLength(2)]);\n" +
      "      guardianPhone?.setValidators([Validators.required, Validators.pattern(/^[0-9]{10}$/)]);\n" +
      "    } else {\n" +
      "      guardianName?.clearValidators();\n" +
      "      guardianPhone?.clearValidators();\n" +
      "      guardianName?.setValue('');\n" +
      "      guardianPhone?.setValue('');\n" +
      "    }\n" +
      "\n" +
      "    guardianName?.updateValueAndValidity();\n" +
      "    guardianPhone?.updateValueAndValidity();\n" +
      "  }\n" +
      "\n" +
      "  handleCountrySpecificFields(country: string) {\n" +
      "    const ssn = this.userForm.get('ssn');\n" +
      "    const sin = this.userForm.get('sin');\n" +
      "    const ni = this.userForm.get('ni');\n" +
      "\n" +
      "    // Clear all country-specific fields\n" +
      "    ssn?.clearValidators();\n" +
      "    sin?.clearValidators();\n" +
      "    ni?.clearValidators();\n" +
      "    ssn?.setValue('');\n" +
      "    sin?.setValue('');\n" +
      "    ni?.setValue('');\n" +
      "\n" +
      "    if (country === 'US') {\n" +
      "      ssn?.setValidators([Validators.required, Validators.pattern(/^[0-9]{3}-[0-9]{2}-[0-9]{4}$/)]);\n" +
      "    } else if (country === 'CA') {\n" +
      "      sin?.setValidators([Validators.required, Validators.pattern(/^[0-9]{3} [0-9]{3} [0-9]{3}$/)]);\n" +
      "    } else if (country === 'UK') {\n" +
      "      ni?.setValidators([Validators.required, Validators.pattern(/^[A-Z]{2}[0-9]{6}[A-Z]$/)]);\n" +
      "    }\n" +
      "\n" +
      "    ssn?.updateValueAndValidity();\n" +
      "    sin?.updateValueAndValidity();\n" +
      "    ni?.updateValueAndValidity();\n" +
      "  }\n" +
      "\n" +
      "  // Custom validator for conditional validation\n" +
      "  conditionalValidator(condition: () => boolean, validator: any) {\n" +
      "    return (control: AbstractControl) => {\n" +
      "      if (condition()) {\n" +
      "        return validator(control);\n" +
      "      }\n" +
      "      return null;\n" +
      "    };\n" +
      "  }\n" +
      "\n" +
      "  // Get error message for control\n" +
      "  getErrorMessage(controlName: string): string {\n" +
      "    const control = this.userForm.get(controlName);\n" +
      "    if (!control || !control.errors) return '';\n" +
      "\n" +
      "    const errors = control.errors;\n" +
      "    \n" +
      "    if (errors['required']) return `${controlName} is required`;\n" +
      "    if (errors['email']) return 'Please enter a valid email';\n      " +
      "    if (errors['minlength']) return `${controlName} must be at least ${errors['minlength'].requiredLength} characters`;\n" +
      "    if (errors['pattern']) return `${controlName} format is invalid`;\n" +
      "    if (errors['requiredTrue']) return 'You must accept the terms and conditions';\n" +
      "    \n" +
      "    return 'Invalid input';\n" +
      "  }\n" +
      "\n" +
      "  // Check if control should show error\n" +
      "  shouldShowError(controlName: string): boolean {\n" +
      "    const control = this.userForm.get(controlName);\n" +
      "    return control ? (control.invalid && (control.dirty || control.touched)) : false;\n" +
      "  }\n" +
      "\n" +
      "  // Check if field should be visible\n" +
      "  isFieldVisible(fieldName: string): boolean {\n" +
      "    const userType = this.userForm.get('userType')?.value;\n" +
      "    const hasSpouse = this.userForm.get('hasSpouse')?.value;\n" +
      "    const isMinor = this.userForm.get('isMinor')?.value;\n" +
      "    const country = this.userForm.get('address.country')?.value;\n" +
      "\n" +
      "    switch (fieldName) {\n" +
      "      case 'companyName':\n" +
      "      case 'taxId':\n" +
      "      case 'businessType':\n" +
      "        return userType === 'company';\n" +
      "      \n" +
      "      case 'nonprofitName':\n" +
      "      case 'registrationNumber':\n" +
      "        return userType === 'nonprofit';\n" +
      "      \n" +
      "      case 'spouseName':\n" +
      "      case 'spouseEmail':\n" +
      "        return hasSpouse;\n" +
      "      \n" +
      "      case 'guardianName':\n" +
      "      case 'guardianPhone':\n" +
      "        return isMinor;\n" +
      "      \n" +
      "      case 'ssn':\n" +
      "        return country === 'US';\n" +
      "      \n" +
      "      case 'sin':\n" +
      "        return country === 'CA';\n" +
      "      \n" +
      "      case 'ni':\n" +
      "        return country === 'UK';\n" +
      "      \n" +
      "      default:\n" +
      "        return true;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  onSubmit() {\n" +
      "    if (this.userForm.valid) {\n" +
      "      console.log('Form submitted:', this.userForm.value);\n" +
      "      \n" +
      "      // Process form data based on user type\n" +
      "      this.processFormData();\n" +
      "    } else {\n" +
      "      this.markFormGroupTouched(this.userForm);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  processFormData() {\n" +
      "    const formValue = this.userForm.value;\n" +
      "    const userType = formValue.userType;\n" +
      "    \n" +
      "    let processedData;\n      " +
      "    \n" +
      "    if (userType === 'company') {\n" +
      "      processedData = {\n" +
      "        type: 'company',\n" +
      "        companyName: formValue.companyName,\n" +
      "        taxId: formValue.taxId,\n" +
      "        businessType: formValue.businessType,\n" +
      "        email: formValue.email,\n" +
      "        phone: formValue.phone,\n" +
      "        address: formValue.address\n" +
      "      };\n" +
      "    } else if (userType === 'nonprofit') {\n" +
      "      processedData = {\n" +
      "        type: 'nonprofit',\n" +
      "        nonprofitName: formValue.nonprofitName,\n" +
      "        registrationNumber: formValue.registrationNumber,\n" +
      "        email: formValue.email,\n" +
      "        phone: formValue.phone,\n" +
      "        address: formValue.address\n" +
      "      };\n" +
      "    } else {\n" +
      "      processedData = {\n" +
      "        type: 'individual',\n      " +
      "        firstName: formValue.firstName,\n" +
      "        lastName: formValue.lastName,\n" +
      "        dateOfBirth: formValue.dateOfBirth,\n" +
      "        email: formValue.email,\n" +
      "        phone: formValue.phone,\n" +
      "        address: formValue.address,\n" +
      "        hasSpouse: formValue.hasSpouse,\n" +
      "        spouseName: formValue.spouseName,\n" +
      "        spouseEmail: formValue.spouseEmail,\n" +
      "        isMinor: formValue.isMinor,\n" +
      "        guardianName: formValue.guardianName,\n" +
      "        guardianPhone: formValue.guardianPhone\n" +
      "      };\n" +
      "    }\n" +
      "    \n" +
      "    // Add country-specific ID\n" +
      "    const country = formValue.address.country;\n" +
      "    if (country === 'US') {\n" +
      "      processedData.ssn = formValue.ssn;\n" +
      "    } else if (country === 'CA') {\n" +
      "      processedData.sin = formValue.sin;\n" +
      "    } else if (country === 'UK') {\n" +
      "      processedData.ni = formValue.ni;\n" +
      "    }\n" +
      "    \n" +
      "    console.log('Processed data:', processedData);\n" +
      "  }\n" +
      "\n" +
      "  // Mark all form controls as touched\n" +
      "  private markFormGroupTouched(formGroup: FormGroup) {\n" +
      "    Object.keys(formGroup.controls).forEach(key => {\n" +
      "      const control = formGroup.get(key);\n" +
      "      \n" +
      "      if (control instanceof FormGroup) {\n" +
      "        this.markFormGroupTouched(control);\n" +
      "      } else {\n" +
      "        control?.markAsTouched();\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template Implementation:**\n" +
      "```html\n" +
      "<!-- conditional-form.component.html -->\n" +
      '<form [formGroup]="userForm" (ngSubmit)="onSubmit()">\n' +
      "  <!-- User Type Selection -->\n" +
      '  <div class="form-section">\n' +
      "    <h3>User Type</h3>\n" +
      '    <div class="form-group">\n' +
      "      <label>Select User Type:</label>\n" +
      '      <select formControlName="userType">\n' +
      '        <option *ngFor="let type of userTypes" [value]="type.value">\n' +
      "          {{ type.label }}\n" +
      "        </option>\n" +
      "      </select>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Individual Fields -->\n" +
      "  <div class=\"form-section\" *ngIf=\"userForm.get('userType')?.value === 'individual'\">\n" +
      "    <h3>Personal Information</h3>\n" +
      "    \n" +
      '    <div class="form-row">\n' +
      '      <div class="form-group">\n' +
      "        <label>First Name:</label>\n" +
      '        <input formControlName="firstName" placeholder="Enter first name" />\n' +
      '        <div *ngIf="shouldShowError(\'firstName\')" class="error">\n' +
      "          {{ getErrorMessage('firstName') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "      \n      " +
      '      <div class="form-group">\n' +
      "        <label>Last Name:</label>\n" +
      '        <input formControlName="lastName" placeholder="Enter last name" />\n' +
      '        <div *ngIf="shouldShowError(\'lastName\')" class="error">\n' +
      "          {{ getErrorMessage('lastName') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="form-group">\n' +
      "        <label>Date of Birth:</label>\n" +
      '        <input type="date" formControlName="dateOfBirth" />\n' +
      '        <div *ngIf="shouldShowError(\'dateOfBirth\')" class="error">\n' +
      "          {{ getErrorMessage('dateOfBirth') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Company Fields -->\n" +
      "  <div class=\"form-section\" *ngIf=\"userForm.get('userType')?.value === 'company'\">\n" +
      "    <h3>Company Information</h3>\n" +
      "    \n" +
      '    <div class="form-row">\n' +
      '      <div class="form-group">\n' +
      "        <label>Company Name:</label>\n" +
      '        <input formControlName="companyName" placeholder="Enter company name" />\n' +
      '        <div *ngIf="shouldShowError(\'companyName\')" class="error">\n' +
      "          {{ getErrorMessage('companyName') }}\n" +
      "        </div>\n" +
      "      </div>\n      " +
      "      \n" +
      '      <div class="form-group">\n' +
      "        <label>Tax ID:</label>\n" +
      '        <input formControlName="taxId" placeholder="XX-XXXXXXX" />\n' +
      '        <div *ngIf="shouldShowError(\'taxId\')" class="error">\n' +
      "          {{ getErrorMessage('taxId') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="form-group">\n' +
      "        <label>Business Type:</label>\n" +
      '        <select formControlName="businessType">\n' +
      '          <option value="">Select Business Type</option>\n' +
      '          <option value="corporation">Corporation</option>\n' +
      '          <option value="llc">LLC</option>\n' +
      '          <option value="partnership">Partnership</option>\n' +
      '          <option value="sole-proprietorship">Sole Proprietorship</option>\n' +
      "        </select>\n" +
      '        <div *ngIf="shouldShowError(\'businessType\')" class="error">\n' +
      "          {{ getErrorMessage('businessType') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Non-Profit Fields -->\n" +
      "  <div class=\"form-section\" *ngIf=\"userForm.get('userType')?.value === 'nonprofit'\">\n" +
      "    <h3>Non-Profit Information</h3>\n" +
      "    \n" +
      '    <div class="form-row">\n' +
      '      <div class="form-group">\n' +
      "        <label>Non-Profit Name:</label>\n" +
      '        <input formControlName="nonprofitName" placeholder="Enter non-profit name" />\n' +
      '        <div *ngIf="shouldShowError(\'nonprofitName\')" class="error">\n' +
      "          {{ getErrorMessage('nonprofitName') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="form-group">\n' +
      "        <label>Registration Number:</label>\n" +
      '        <input formControlName="registrationNumber" placeholder="XX123456" />\n' +
      '        <div *ngIf="shouldShowError(\'registrationNumber\')" class="error">\n' +
      "          {{ getErrorMessage('registrationNumber') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Spouse Fields (Conditional) -->\n" +
      "  <div class=\"form-section\" *ngIf=\"userForm.get('userType')?.value === 'individual'\">\n" +
      "    <h3>Spouse Information</h3>\n" +
      "    \n" +
      '    <div class="form-group">\n' +
      '      <div class="form-check">\n' +
      '        <input type="checkbox" formControlName="hasSpouse" id="hasSpouse" />\n' +
      '        <label for="hasSpouse">I have a spouse</label>\n' +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      '    <div *ngIf="isFieldVisible(\'spouseName\')" class="form-row">\n' +
      '      <div class="form-group">\n' +
      "        <label>Spouse Name:</label>\n" +
      '        <input formControlName="spouseName" placeholder="Enter spouse name" />\n' +
      '        <div *ngIf="shouldShowError(\'spouseName\')" class="error">\n' +
      "          {{ getErrorMessage('spouseName') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="form-group">\n' +
      "        <label>Spouse Email:</label>\n" +
      '        <input formControlName="spouseEmail" placeholder="Enter spouse email" />\n' +
      '        <div *ngIf="shouldShowError(\'spouseEmail\')" class="error">\n' +
      "          {{ getErrorMessage('spouseEmail') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Guardian Fields (Age-dependent) -->\n" +
      '  <div class="form-section" *ngIf="isFieldVisible(\'guardianName\')">\n' +
      "    <h3>Guardian Information</h3>\n" +
      "    \n" +
      '    <div class="form-row">\n' +
      '      <div class="form-group">\n' +
      "        <label>Guardian Name:</label>\n" +
      '        <input formControlName="guardianName" placeholder="Enter guardian name" />\n' +
      '        <div *ngIf="shouldShowError(\'guardianName\')" class="error">\n' +
      "          {{ getErrorMessage('guardianName') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="form-group">\n' +
      "        <label>Guardian Phone:</label>\n" +
      '        <input formControlName="guardianPhone" placeholder="Enter guardian phone" />\n' +
      '        <div *ngIf="shouldShowError(\'guardianPhone\')" class="error">\n' +
      "          {{ getErrorMessage('guardianPhone') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Country-specific ID Fields -->\n" +
      '  <div class="form-section">\n' +
      "    <h3>Identification</h3>\n" +
      "    \n" +
      '    <div class="form-group" *ngIf="isFieldVisible(\'ssn\')">\n' +
      "      <label>Social Security Number:</label>\n" +
      '      <input formControlName="ssn" placeholder="XXX-XX-XXXX" />\n' +
      '      <div *ngIf="shouldShowError(\'ssn\')" class="error">\n' +
      "        {{ getErrorMessage('ssn') }}\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      '    <div class="form-group" *ngIf="isFieldVisible(\'sin\')">\n' +
      "      <label>SIN (Social Insurance Number):</label>\n" +
      '      <input formControlName="sin" placeholder="XXX XXX XXX" />\n' +
      '      <div *ngIf="shouldShowError(\'sin\')" class="error">\n' +
      "        {{ getErrorMessage('sin') }}\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      '    <div class="form-group" *ngIf="isFieldVisible(\'ni\')">\n' +
      "      <label>National Insurance Number:</label>\n" +
      '      <input formControlName="ni" placeholder="XX123456X" />\n' +
      '      <div *ngIf="shouldShowError(\'ni\')" class="error">\n' +
      "        {{ getErrorMessage('ni') }}\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Terms and Conditions -->\n" +
      '  <div class="form-section">\n' +
      "    <h3>Terms and Conditions</h3>\n" +
      "    \n" +
      '    <div class="form-group">\n' +
      '      <div class="form-check">\n' +
      '        <input type="checkbox" formControlName="acceptTerms" id="acceptTerms" />\n' +
      '        <label for="acceptTerms">I accept the terms and conditions</label>\n' +
      '        <div *ngIf="shouldShowError(\'acceptTerms\')" class="error">\n' +
      "          {{ getErrorMessage('acceptTerms') }}\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      '    <div class="form-group">\n' +
      '      <div class="form-check">\n' +
      '        <input type="checkbox" formControlName="acceptMarketing" id="acceptMarketing" />\n' +
      '        <label for="acceptMarketing">I would like to receive marketing communications</label>\n' +
      "      </div>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "\n" +
      "  <!-- Submit Button -->\n" +
      '  <div class="form-actions">\n' +
      '    <button type="submit" [disabled]="userForm.invalid" class="btn btn-primary">\n' +
      "      Submit\n" +
      "    </button>\n" +
      "  </div>\n" +
      "</form>\n" +
      "```\n\n" +
      "**Best Practices for Conditional Validation:**\n" +
      "- Use valueChanges to react to form changes\n" +
      "- Implement proper cleanup of conditional fields\n" +
      "- Use clearValidators() and setValidators() appropriately\n" +
      "- Always call updateValueAndValidity() after changing validators\n" +
      "- Implement proper error handling\n" +
      "- Use TypeScript for better type safety\n" +
      "- Test all conditional scenarios thoroughly\n" +
      "- Consider performance implications of complex conditional logic\n" +
      "- Use proper naming conventions for conditional fields\n" +
      "- Implement proper form state management",
    category: "Forms",
    difficulty: "advanced",
    tags: ["forms", "reactive", "conditional", "validation", "dynamic"],
  },
  {
    id: 177,
    question: "What are Parent-Child Components in Angular and how do they communicate?",
    answer:
      "Parent-Child Components in Angular represent a hierarchical relationship where one component (parent) contains another component (child) in its template, enabling data flow and communication between them.\n\n" +
      "**Parent-Child Component Structure:**\n" +
      "```typescript\n" +
      "// parent.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-parent',\n" +
      "  template: `\n" +
      '    <div class="parent-container">\n' +
      "      <h2>Parent Component</h2>\n" +
      "      <p>Parent Data: {{ parentMessage }}</p>\n" +
      "      <p>Child Data Received: {{ childData }}</p>\n" +
      "      \n" +
      "      <!-- Child component with data binding -->\n" +
      "      <app-child \n" +
      '        [parentData]="parentMessage"\n' +
      '        [userData]="user"\n' +
      '        (childEvent)="onChildEvent($event)"\n' +
      '        (dataChange)="onDataChange($event)"\n' +
      "      ></app-child>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .parent-container {\n" +
      "      padding: 20px;\n" +
      "      border: 2px solid #007bff;\n" +
      "      margin: 10px;\n" +
      "      background-color: #f8f9fa;\n" +
      "    }\n" +
      "  `]\n" +
      "})\n" +
      "export class ParentComponent {\n" +
      "  parentMessage = 'Hello from Parent!';\n" +
      "  childData = '';\n" +
      "  \n" +
      "  user = {\n" +
      "    name: 'John Doe',\n" +
      "    email: 'john@example.com',\n" +
      "    age: 30\n" +
      "  };\n" +
      "\n" +
      "  // Handle events from child\n" +
      "  onChildEvent(eventData: string) {\n" +
      "    console.log('Received from child:', eventData);\n" +
      "    this.childData = eventData;\n" +
      "  }\n" +
      "\n" +
      "  onDataChange(newData: any) {\n" +
      "    console.log('Data changed in child:', newData);\n" +
      "    // Update parent data based on child changes\n" +
      "    this.user = { ...this.user, ...newData };\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "```typescript\n" +
      "// child.component.ts\n" +
      "import { Component, Input, Output, EventEmitter, OnInit, OnChanges, SimpleChanges } from '@angular/core';\n" +
      "\n" +
      "interface User {\n" +
      "  name: string;\n" +
      "  email: string;\n" +
      "  age: number;\n" +
      "}\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-child',\n" +
      "  template: `\n" +
      '    <div class="child-container">\n' +
      "      <h3>Child Component</h3>\n" +
      "      <p>Parent Data Received: {{ parentData }}</p>\n" +
      "      <p>User Name: {{ userData?.name }}</p>\n" +
      "      <p>User Email: {{ userData?.email }}</p>\n" +
      "      \n" +
      '      <div class="child-actions">\n' +
      '        <button (click)="sendMessageToParent()">Send Message to Parent</button>\n' +
      '        <button (click)="updateUserData()">Update User Data</button>\n' +
      '        <button (click)="emitCustomEvent()">Emit Custom Event</button>\n' +
      "      </div>\n" +
      "      \n" +
      '      <div class="child-form">\n' +
      "        <input \n" +
      '          [(ngModel)]="localMessage" \n' +
      '          placeholder="Enter message"\n' +
      '          (input)="onInputChange()"\n' +
      "        />\n" +
      "        <p>Local Message: {{ localMessage }}</p>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .child-container {\n" +
      "      padding: 15px;\n" +
      "      border: 1px solid #28a745;\n" +
      "      margin: 10px;\n" +
      "      background-color: #d4edda;\n" +
      "    }\n" +
      "    .child-actions {\n" +
      "      margin: 10px 0;\n" +
      "    }\n" +
      "    .child-actions button {\n" +
      "      margin: 5px;\n" +
      "      padding: 8px 12px;\n" +
      "      background-color: #28a745;\n" +
      "      color: white;\n" +
      "      border: none;\n" +
      "      border-radius: 4px;\n" +
      "      cursor: pointer;\n" +
      "    }\n" +
      "    .child-form {\n" +
      "      margin-top: 10px;\n" +
      "    }\n" +
      "    .child-form input {\n" +
      "      padding: 8px;\n" +
      "      border: 1px solid #ccc;\n" +
      "      border-radius: 4px;\n" +
      "      width: 200px;\n" +
      "    }\n" +
      "  `]\n" +
      "})\n" +
      "export class ChildComponent implements OnInit, OnChanges {\n" +
      "  @Input() parentData: string = '';\n" +
      "  @Input() userData: User | null = null;\n" +
      "  \n" +
      "  @Output() childEvent = new EventEmitter<string>();\n" +
      "  @Output() dataChange = new EventEmitter<any>();\n" +
      "  @Output() customEvent = new EventEmitter<{ type: string; data: any }>();\n" +
      "  \n" +
      "  localMessage = '';\n" +
      "  changeCount = 0;\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    console.log('Child component initialized');\n" +
      "    console.log('Initial parent data:', this.parentData);\n" +
      "    console.log('Initial user data:', this.userData);\n" +
      "  }\n" +
      "\n" +
      "  ngOnChanges(changes: SimpleChanges) {\n" +
      "    console.log('Child component changes detected:', changes);\n" +
      "    \n" +
      "    if (changes['parentData']) {\n" +
      "      console.log('Parent data changed:', changes['parentData'].currentValue);\n" +
      "    }\n" +
      "    \n" +
      "    if (changes['userData']) {\n" +
      "      console.log('User data changed:', changes['userData'].currentValue);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  sendMessageToParent() {\n" +
      "    const message = `Message from child at ${new Date().toLocaleTimeString()}`;\n" +
      "    this.childEvent.emit(message);\n" +
      "  }\n" +
      "\n" +
      "  updateUserData() {\n" +
      "    const updatedData = {\n" +
      "      name: 'Jane Smith',\n" +
      "      email: 'jane@example.com',\n" +
      "      age: 25\n" +
      "    };\n" +
      "    this.dataChange.emit(updatedData);\n" +
      "  }\n" +
      "\n" +
      "  emitCustomEvent() {\n" +
      "    this.customEvent.emit({\n" +
      "      type: 'custom',\n" +
      "      data: { timestamp: new Date(), message: 'Custom event from child' }\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  onInputChange() {\n" +
      "    this.changeCount++;\n" +
      "    // Emit input changes to parent\n" +
      "    this.childEvent.emit(`Input changed ${this.changeCount} times: ${this.localMessage}`);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Communication Patterns:**\n" +
      "```typescript\n" +
      "// 1. Parent to Child (Input Properties)\n" +
      "// Parent passes data to child using property binding\n" +
      '// <app-child [parentData]="parentMessage"></app-child>\n' +
      "\n" +
      "// 2. Child to Parent (Output Events)\n" +
      "// Child emits events to parent using event binding\n" +
      '// <app-child (childEvent)="onChildEvent($event)"></app-child>\n' +
      "\n" +
      "// 3. Two-way Data Binding\n" +
      '// <app-child [(data)]="parentData"></app-child>\n' +
      '// Equivalent to: [data]="parentData" (dataChange)="parentData = $event"\n' +
      "\n" +
      "// 4. Template Reference Variables\n" +
      "// <app-child #childRef></app-child>\n" +
      '// <button (click)="childRef.someMethod()">Call Child Method</button>\n' +
      "```\n\n" +
      "**Advanced Parent-Child Communication:**\n" +
      "```typescript\n" +
      "// parent.component.ts - Advanced example\n" +
      "import { Component, ViewChild, AfterViewInit } from '@angular/core';\n" +
      "import { ChildComponent } from './child.component';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-advanced-parent',\n" +
      "  template: `\n" +
      '    <div class="advanced-parent">\n' +
      "      <h2>Advanced Parent Component</h2>\n" +
      "      \n" +
      "      <!-- Multiple children -->\n" +
      '      <div class="children-container">\n' +
      "        <app-child \n" +
      '          *ngFor="let child of children; let i = index"\n' +
      '          [parentData]="parentMessage"\n' +
      '          [childId]="i"\n' +
      '          (childEvent)="onChildEvent($event, i)"\n' +
      "          #childRef\n" +
      "        ></app-child>\n" +
      "      </div>\n" +
      "      \n" +
      "      <!-- Parent controls -->\n" +
      '      <div class="parent-controls">\n' +
      '        <button (click)="addChild()">Add Child</button>\n' +
      '        <button (click)="removeChild()">Remove Child</button>\n' +
      '        <button (click)="updateAllChildren()">Update All Children</button>\n' +
      '        <button (click)="callChildMethod()">Call Child Method</button>\n' +
      "      </div>\n" +
      "      \n" +
      "      <!-- Child communication log -->\n" +
      '      <div class="communication-log">\n' +
      "        <h4>Communication Log:</h4>\n" +
      "        <ul>\n" +
      '          <li *ngFor="let log of communicationLog">{{ log }}</li>\n' +
      "        </ul>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class AdvancedParentComponent implements AfterViewInit {\n" +
      "  @ViewChild(ChildComponent) childComponent!: ChildComponent;\n" +
      "  \n" +
      "  parentMessage = 'Advanced Parent Message';\n" +
      "  children = [1, 2, 3]; // Array of child IDs\n" +
      "  communicationLog: string[] = [];\n" +
      "\n" +
      "  ngAfterViewInit() {\n" +
      "    console.log('Parent view initialized');\n" +
      "    // Access child component after view init\n" +
      "    if (this.childComponent) {\n" +
      "      console.log('Child component reference:', this.childComponent);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  onChildEvent(eventData: string, childIndex: number) {\n" +
      "    const logEntry = `Child ${childIndex}: ${eventData}`;\n" +
      "    this.communicationLog.push(logEntry);\n" +
      "    console.log(logEntry);\n" +
      "  }\n" +
      "\n" +
      "  addChild() {\n" +
      "    this.children.push(this.children.length + 1);\n" +
      "    this.communicationLog.push(`Added child ${this.children.length}`);\n" +
      "  }\n" +
      "\n" +
      "  removeChild() {\n" +
      "    if (this.children.length > 1) {\n" +
      "      const removed = this.children.pop();\n" +
      "      this.communicationLog.push(`Removed child ${removed}`);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  updateAllChildren() {\n" +
      "    this.parentMessage = `Updated at ${new Date().toLocaleTimeString()}`;\n" +
      "    this.communicationLog.push('Updated all children');\n" +
      "  }\n" +
      "\n" +
      "  callChildMethod() {\n" +
      "    if (this.childComponent) {\n" +
      "      // Call method directly on child component\n" +
      "      this.childComponent.sendMessageToParent();\n" +
      "      this.communicationLog.push('Called child method directly');\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices for Parent-Child Communication:**\n" +
      "- Use @Input() for data flow from parent to child\n" +
      "- Use @Output() with EventEmitter for child to parent communication\n" +
      "- Implement OnChanges to react to input changes\n" +
      "- Use ViewChild for direct component access when needed\n" +
      "- Avoid tight coupling between components\n" +
      "- Use interfaces for type safety\n" +
      "- Implement proper error handling\n" +
      "- Consider using services for complex communication patterns\n" +
      "- Use ChangeDetectionStrategy.OnPush for performance optimization\n" +
      "- Document component interfaces clearly",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "parent-child", "communication", "input", "output"],
  },
  {
    id: 178,
    question: "What is @Input Decorator and how to transfer data from Parent to Child component?",
    answer:
      "The @Input decorator in Angular is used to mark a property as an input property, allowing a parent component to pass data to a child component through property binding.\n\n" +
      "**Basic @Input Usage:**\n" +
      "```typescript\n" +
      "// child.component.ts\n" +
      "import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-child',\n" +
      "  template: `\n" +
      '    <div class="child-component">\n' +
      "      <h3>Child Component</h3>\n" +
      "      <p>Received from parent: {{ parentMessage }}</p>\n" +
      "      <p>User Name: {{ userName }}</p>\n" +
      "      <p>User Age: {{ userAge }}</p>\n" +
      "      <p>Is Active: {{ isActive ? 'Yes' : 'No' }}</p>\n" +
      "      \n" +
      "      <!-- Display user object -->\n" +
      '      <div *ngIf="userData">\n' +
      "        <h4>User Details:</h4>\n" +
      "        <p>Name: {{ userData.name }}</p>\n" +
      "        <p>Email: {{ userData.email }}</p>\n" +
      "        <p>Role: {{ userData.role }}</p>\n" +
      "      </div>\n" +
      "      \n" +
      "      <!-- Display array data -->\n" +
      '      <div *ngIf="items && items.length > 0">\n' +
      "        <h4>Items List:</h4>\n" +
      "        <ul>\n" +
      '          <li *ngFor="let item of items">{{ item }}</li>\n' +
      "        </ul>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ChildComponent implements OnChanges {\n" +
      "  // Basic string input\n" +
      "  @Input() parentMessage: string = '';\n" +
      "  \n" +
      "  // Input with alias\n" +
      "  @Input('user-name') userName: string = '';\n" +
      "  \n" +
      "  // Input with default value\n" +
      "  @Input() userAge: number = 0;\n" +
      "  \n" +
      "  // Boolean input\n" +
      "  @Input() isActive: boolean = false;\n" +
      "  \n" +
      "  // Object input\n" +
      "  @Input() userData: { name: string; email: string; role: string } | null = null;\n" +
      "  \n" +
      "  // Array input\n" +
      "  @Input() items: string[] = [];\n" +
      "  \n" +
      "  // Input with setter (computed property)\n" +
      "  private _computedValue: string = '';\n" +
      "  \n" +
      "  @Input()\n" +
      "  set computedValue(value: string) {\n" +
      "    this._computedValue = value.toUpperCase();\n" +
      "  }\n" +
      "  \n" +
      "  get computedValue(): string {\n" +
      "    return this._computedValue;\n" +
      "  }\n" +
      "\n" +
      "  ngOnChanges(changes: SimpleChanges) {\n" +
      "    console.log('Input changes detected:', changes);\n" +
      "    \n" +
      "    // Handle specific input changes\n" +
      "    if (changes['parentMessage']) {\n" +
      "      console.log('Parent message changed:', changes['parentMessage'].currentValue);\n" +
      "    }\n" +
      "    \n" +
      "    if (changes['userData']) {\n" +
      "      console.log('User data changed:', changes['userData'].currentValue);\n" +
      "    }\n" +
      "    \n" +
      "    if (changes['items']) {\n      " +
      "      console.log('Items array changed:', changes['items'].currentValue);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Parent Component Implementation:**\n" +
      "```typescript\n" +
      "// parent.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-parent',\n" +
      "  template: `\n" +
      '    <div class="parent-component">\n' +
      "      <h2>Parent Component</h2>\n" +
      "      \n" +
      "      <!-- Basic property binding -->\n" +
      "      <app-child \n" +
      '        [parentMessage]="message"\n' +
      '        [user-name]="user.name"\n' +
      '        [userAge]="user.age"\n' +
      '        [isActive]="isUserActive"\n' +
      '        [userData]="user"\n' +
      '        [items]="itemList"\n' +
      '        [computedValue]="message"\n' +
      "      ></app-child>\n" +
      "      \n" +
      "      <!-- Dynamic data binding -->\n" +
      '      <div class="parent-controls">\n' +
      '        <button (click)="updateMessage()">Update Message</button>\n' +
      '        <button (click)="updateUser()">Update User</button>\n' +
      '        <button (click)="addItem()">Add Item</button>\n' +
      '        <button (click)="toggleActive()">Toggle Active</button>\n' +
      "      </div>\n" +
      "      \n" +
      "      <!-- Form to update data -->\n" +
      '      <div class="parent-form">\n' +
      '        <input [(ngModel)]="message" placeholder="Enter message" />\n' +
      '        <input [(ngModel)]="user.name" placeholder="Enter name" />\n' +
      '        <input [(ngModel)]="user.email" placeholder="Enter email" />\n' +
      '        <input [(ngModel)]="user.age" type="number" placeholder="Enter age" />\n' +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ParentComponent {\n" +
      "  message = 'Hello from Parent!';\n" +
      "  isUserActive = true;\n" +
      "  \n" +
      "  user = {\n" +
      "    name: 'John Doe',\n" +
      "    email: 'john@example.com',\n" +
      "    age: 30,\n" +
      "    role: 'Developer'\n" +
      "  };\n" +
      "  \n" +
      "  itemList = ['Item 1', 'Item 2', 'Item 3'];\n" +
      "\n" +
      "  updateMessage() {\n" +
      "    this.message = `Updated at ${new Date().toLocaleTimeString()}`;\n" +
      "  }\n" +
      "\n" +
      "  updateUser() {\n" +
      "    this.user = {\n" +
      "      name: 'Jane Smith',\n" +
      "      email: 'jane@example.com',\n" +
      "      age: 25,\n" +
      "      role: 'Designer'\n" +
      "    };\n" +
      "  }\n" +
      "\n" +
      "  addItem() {\n" +
      "    this.itemList.push(`Item ${this.itemList.length + 1}`);\n" +
      "  }\n" +
      "\n" +
      "  toggleActive() {\n" +
      "    this.isUserActive = !this.isUserActive;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Advanced @Input Patterns:**\n" +
      "```typescript\n" +
      "// advanced-child.component.ts\n" +
      "import { Component, Input, OnChanges, SimpleChanges, OnInit } from '@angular/core';\n" +
      "\n" +
      "interface Config {\n" +
      "  theme: 'light' | 'dark';\n" +
      "  size: 'small' | 'medium' | 'large';\n" +
      "  showHeader: boolean;\n" +
      "}\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-advanced-child',\n" +
      "  template: `\n" +
      '    <div [class]="getComponentClasses()">\n' +
      '      <h3 *ngIf="config.showHeader">Advanced Child Component</h3>\n' +
      "      \n" +
      "      <!-- Conditional rendering based on input -->\n" +
      '      <div *ngIf="data; else noDataTemplate">\n' +
      "        <p>Data: {{ data }}</p>\n" +
      "      </div>\n" +
      "      \n      " +
      "      <ng-template #noDataTemplate>\n" +
      "        <p>No data provided</p>\n" +
      "      </ng-template>\n" +
      "      \n" +
      "      <!-- Dynamic content based on input -->\n" +
      '      <div [ngSwitch]="dataType">\n' +
      "        <div *ngSwitchCase=\"'string'\">String data: {{ data }}</div>\n" +
      "        <div *ngSwitchCase=\"'number'\">Number data: {{ data }}</div>\n" +
      "        <div *ngSwitchCase=\"'object'\">Object data: {{ data | json }}</div>\n" +
      "        <div *ngSwitchDefault>Unknown data type</div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .component {\n" +
      "      padding: 20px;\n" +
      "      border: 1px solid #ccc;\n" +
      "      margin: 10px;\n" +
      "    }\n" +
      "    .theme-light { background-color: #f8f9fa; color: #333; }\n" +
      "    .theme-dark { background-color: #333; color: #f8f9fa; }\n" +
      "    .size-small { font-size: 12px; }\n" +
      "    .size-medium { font-size: 16px; }\n" +
      "    .size-large { font-size: 20px; }\n" +
      "  `]\n" +
      "})\n" +
      "export class AdvancedChildComponent implements OnInit, OnChanges {\n" +
      "  // Input with validation\n" +
      "  @Input() data: any;\n" +
      "  \n" +
      "  // Input with default value and validation\n" +
      "  @Input() config: Config = {\n" +
      "    theme: 'light',\n" +
      "    size: 'medium',\n      " +
      "    showHeader: true\n" +
      "  };\n" +
      "  \n" +
      "  // Computed property based on input\n" +
      "  dataType: string = '';\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    this.updateDataType();\n" +
      "  }\n" +
      "\n" +
      "  ngOnChanges(changes: SimpleChanges) {\n" +
      "    if (changes['data']) {\n" +
      "      this.updateDataType();\n" +
      "    }\n" +
      "    \n" +
      "    if (changes['config']) {\n" +
      "      console.log('Config changed:', changes['config'].currentValue);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  private updateDataType() {\n" +
      "    if (this.data === null || this.data === undefined) {\n" +
      "      this.dataType = 'null';\n" +
      "    } else {\n" +
      "      this.dataType = typeof this.data;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  getComponentClasses(): string {\n" +
      "    return `component theme-${this.config.theme} size-${this.config.size}`;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Input with Transform Functions:**\n" +
      "```typescript\n" +
      "// transform-child.component.ts\n" +
      "import { Component, Input } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-transform-child',\n" +
      "  template: `\n" +
      "    <div>\n" +
      "      <h3>Transform Child Component</h3>\n" +
      "      <p>Raw Input: {{ rawInput }}</p>\n" +
      "      <p>Transformed Input: {{ transformedInput }}</p>\n" +
      "      <p>Processed Data: {{ processedData }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class TransformChildComponent {\n" +
      "  // Input with transform function\n" +
      "  @Input({ transform: (value: string) => value?.toUpperCase() || '' })\n" +
      "  rawInput: string = '';\n" +
      "  \n" +
      "  // Input with complex transform\n" +
      "  @Input({ \n" +
      "    transform: (value: any) => {\n" +
      "      if (typeof value === 'string') {\n" +
      "        return value.split('').reverse().join('');\n" +
      "      }\n" +
      "      return value;\n" +
      "    }\n" +
      "  })\n" +
      "  transformedInput: string = '';\n" +
      "  \n" +
      "  // Input with validation and transform\n" +
      "  @Input({ \n" +
      "    transform: (value: number) => {\n" +
      "      return Math.max(0, Math.min(100, value || 0));\n" +
      "    }\n" +
      "  })\n" +
      "  processedData: number = 0;\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices for @Input:**\n" +
      "- Always provide default values for optional inputs\n" +
      "- Use TypeScript interfaces for complex object inputs\n" +
      "- Implement OnChanges to react to input changes\n" +
      "- Use input aliases for better API design\n" +
      "- Validate input data in setters or ngOnChanges\n" +
      "- Use transform functions for data processing\n" +
      "- Document input properties clearly\n" +
      "- Consider using OnPush change detection for performance\n" +
      "- Avoid mutating input objects directly\n" +
      "- Use readonly inputs when data shouldn't be modified",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "input", "decorator", "parent-child", "data-binding"],
  },
  {
    id: 179,
    question: "What is @Output Decorator and EventEmitter in Angular?",
    answer:
      "The @Output decorator in Angular is used to mark a property as an output property, allowing a child component to emit events to its parent component. EventEmitter is a class that extends RxJS Subject and is used to emit custom events.\n\n" +
      "**Basic @Output and EventEmitter Usage:**\n" +
      "```typescript\n" +
      "// child.component.ts\n" +
      "import { Component, Output, EventEmitter } from '@angular/core';\n" +
      "\n" +
      "interface User {\n" +
      "  name: string;\n" +
      "  email: string;\n" +
      "  age: number;\n" +
      "}\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-child',\n" +
      "  template: `\n" +
      '    <div class="child-component">\n' +
      "      <h3>Child Component</h3>\n" +
      "      \n" +
      "      <!-- Basic event emission -->\n" +
      '      <button (click)="emitSimpleEvent()">Emit Simple Event</button>\n' +
      "      \n" +
      "      <!-- Event with data -->\n" +
      '      <button (click)="emitDataEvent()">Emit Data Event</button>\n' +
      "      \n" +
      "      <!-- Event with object -->\n" +
      '      <button (click)="emitUserEvent()">Emit User Event</button>\n' +
      "      \n" +
      "      <!-- Form submission event -->\n" +
      '      <form (ngSubmit)="onFormSubmit($event)">\n' +
      '        <input [(ngModel)]="formData.name" name="name" placeholder="Name" required />\n' +
      '        <input [(ngModel)]="formData.email" name="email" placeholder="Email" required />\n' +
      '        <button type="submit">Submit Form</button>\n' +
      "      </form>\n" +
      "      \n" +
      "      <!-- Custom event with multiple parameters -->\n" +
      '      <button (click)="emitCustomEvent()">Emit Custom Event</button>\n' +
      "      \n" +
      "      <!-- Event with validation -->\n" +
      "      <div>\n" +
      '        <input [(ngModel)]="validationData" placeholder="Enter data" />\n' +
      '        <button (click)="emitValidatedEvent()">Emit Validated Event</button>\n' +
      '        <p *ngIf="errorMessage" class="error">{{ errorMessage }}</p>\n' +
      "      </div>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .child-component {\n" +
      "      padding: 20px;\n" +
      "      border: 1px solid #28a745;\n" +
      "      margin: 10px;\n" +
      "      background-color: #d4edda;\n" +
      "    }\n" +
      "    button {\n" +
      "      margin: 5px;\n" +
      "      padding: 8px 12px;\n" +
      "      background-color: #28a745;\n" +
      "      color: white;\n" +
      "      border: none;\n" +
      "      border-radius: 4px;\n" +
      "      cursor: pointer;\n" +
      "    }\n" +
      "    input {\n" +
      "      margin: 5px;\n" +
      "      padding: 8px;\n" +
      "      border: 1px solid #ccc;\n" +
      "      border-radius: 4px;\n" +
      "    }\n" +
      "    .error {\n" +
      "      color: #dc3545;\n" +
      "      font-size: 12px;\n" +
      "    }\n" +
      "  `]\n" +
      "})\n" +
      "export class ChildComponent {\n" +
      "  // Basic string event\n" +
      "  @Output() simpleEvent = new EventEmitter<string>();\n" +
      "  \n" +
      "  // Event with data\n" +
      "  @Output() dataEvent = new EventEmitter<{ id: number; message: string }>();\n" +
      "  \n" +
      "  // Event with user object\n" +
      "  @Output() userEvent = new EventEmitter<User>();\n" +
      "  \n" +
      "  // Form submission event\n" +
      "  @Output() formSubmit = new EventEmitter<{ name: string; email: string }>();\n" +
      "  \n" +
      "  // Custom event with multiple parameters\n" +
      "  @Output() customEvent = new EventEmitter<{\n" +
      "    type: string;\n" +
      "    data: any;\n" +
      "    timestamp: Date;\n" +
      "  }>();\n" +
      "  \n" +
      "  // Event with validation\n" +
      "  @Output() validatedEvent = new EventEmitter<string>();\n" +
      "  \n" +
      "  // Event with alias\n" +
      "  @Output('user-selected') userSelected = new EventEmitter<User>();\n" +
      "  \n" +
      "  formData = {\n" +
      "    name: '',\n" +
      "    email: ''\n" +
      "  };\n" +
      "  \n" +
      "  validationData = '';\n" +
      "  errorMessage = '';\n" +
      "\n" +
      "  emitSimpleEvent() {\n" +
      "    const message = `Simple event emitted at ${new Date().toLocaleTimeString()}`;\n" +
      "    this.simpleEvent.emit(message);\n" +
      "  }\n" +
      "\n" +
      "  emitDataEvent() {\n" +
      "    const data = {\n" +
      "      id: Math.floor(Math.random() * 1000),\n" +
      "      message: 'Data event with ID and message'\n" +
      "    };\n" +
      "    this.dataEvent.emit(data);\n" +
      "  }\n" +
      "\n" +
      "  emitUserEvent() {\n" +
      "    const user: User = {\n" +
      "      name: 'John Doe',\n" +
      "      email: 'john@example.com',\n" +
      "      age: 30\n" +
      "    };\n" +
      "    this.userEvent.emit(user);\n" +
      "    this.userSelected.emit(user); // Also emit with alias\n" +
      "  }\n" +
      "\n" +
      "  onFormSubmit(event: Event) {\n" +
      "    event.preventDefault();\n" +
      "    \n" +
      "    if (this.formData.name && this.formData.email) {\n" +
      "      this.formSubmit.emit({\n" +
      "        name: this.formData.name,\n" +
      "        email: this.formData.email\n" +
      "      });\n" +
      "      \n" +
      "      // Reset form\n" +
      "      this.formData = { name: '', email: '' };\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  emitCustomEvent() {\n" +
      "    const customData = {\n" +
      "      type: 'custom',\n" +
      "      data: {\n" +
      "        action: 'button-click',\n" +
      "        component: 'child',\n" +
      "        metadata: { version: '1.0', build: '123' }\n" +
      "      },\n" +
      "      timestamp: new Date()\n" +
      "    };\n" +
      "    this.customEvent.emit(customData);\n" +
      "  }\n" +
      "\n" +
      "  emitValidatedEvent() {\n" +
      "    this.errorMessage = '';\n" +
      "    \n" +
      "    if (!this.validationData) {\n" +
      "      this.errorMessage = 'Data is required';\n" +
      "      return;\n" +
      "    }\n" +
      "    \n" +
      "    if (this.validationData.length < 3) {\n" +
      "      this.errorMessage = 'Data must be at least 3 characters';\n" +
      "      return;\n" +
      "    }\n" +
      "    \n" +
      "    this.validatedEvent.emit(this.validationData);\n" +
      "    this.validationData = '';\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Parent Component Implementation:**\n" +
      "```typescript\n" +
      "// parent.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-parent',\n" +
      "  template: `\n" +
      '    <div class="parent-component">\n' +
      "      <h2>Parent Component</h2>\n" +
      "      \n" +
      "      <!-- Event handling -->\n" +
      "      <app-child \n" +
      '        (simpleEvent)="onSimpleEvent($event)"\n' +
      '        (dataEvent)="onDataEvent($event)"\n' +
      '        (userEvent)="onUserEvent($event)"\n' +
      '        (formSubmit)="onFormSubmit($event)"\n' +
      '        (customEvent)="onCustomEvent($event)"\n' +
      '        (validatedEvent)="onValidatedEvent($event)"\n' +
      '        (user-selected)="onUserSelected($event)"\n' +
      "      ></app-child>\n" +
      "      \n" +
      "      <!-- Event log display -->\n" +
      '      <div class="event-log">\n' +
      "        <h3>Event Log:</h3>\n" +
      "        <ul>\n" +
      '          <li *ngFor="let log of eventLog">{{ log }}</li>\n' +
      "        </ul>\n" +
      "      </div>\n" +
      "      \n" +
      "      <!-- Data display -->\n" +
      '      <div class="data-display">\n' +
      "        <h3>Received Data:</h3>\n" +
      "        <p><strong>Last User:</strong> {{ lastUser | json }}</p>\n" +
      "        <p><strong>Form Data:</strong> {{ formData | json }}</p>\n" +
      "        <p><strong>Validated Data:</strong> {{ validatedData }}</p>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .parent-component {\n" +
      "      padding: 20px;\n" +
      "      border: 2px solid #007bff;\n" +
      "      margin: 10px;\n" +
      "      background-color: #f8f9fa;\n" +
      "    }\n" +
      "    .event-log {\n" +
      "      margin: 20px 0;\n" +
      "      padding: 15px;\n" +
      "      background-color: #e9ecef;\n" +
      "      border-radius: 4px;\n" +
      "    }\n" +
      "    .event-log ul {\n" +
      "      list-style-type: none;\n" +
      "      padding: 0;\n" +
      "    }\n" +
      "    .event-log li {\n" +
      "      padding: 5px 0;\n" +
      "      border-bottom: 1px solid #dee2e6;\n" +
      "    }\n" +
      "    .data-display {\n" +
      "      margin: 20px 0;\n" +
      "      padding: 15px;\n" +
      "      background-color: #d1ecf1;\n" +
      "      border-radius: 4px;\n" +
      "    }\n" +
      "  `]\n" +
      "})\n" +
      "export class ParentComponent {\n" +
      "  eventLog: string[] = [];\n" +
      "  lastUser: any = null;\n" +
      "  formData: any = null;\n" +
      "  validatedData: string = '';\n" +
      "\n" +
      "  onSimpleEvent(message: string) {\n" +
      "    this.addToLog(`Simple Event: ${message}`);\n" +
      "  }\n" +
      "\n" +
      "  onDataEvent(data: { id: number; message: string }) {\n" +
      "    this.addToLog(`Data Event: ID=${data.id}, Message=${data.message}`);\n" +
      "  }\n" +
      "\n" +
      "  onUserEvent(user: any) {\n" +
      "    this.lastUser = user;\n" +
      "    this.addToLog(`User Event: ${user.name} (${user.email})`);\n" +
      "  }\n" +
      "\n" +
      "  onFormSubmit(data: { name: string; email: string }) {\n" +
      "    this.formData = data;\n" +
      "    this.addToLog(`Form Submit: ${data.name} - ${data.email}`);\n" +
      "  }\n" +
      "\n" +
      "  onCustomEvent(event: any) {\n" +
      "    this.addToLog(`Custom Event: ${event.type} at ${event.timestamp.toLocaleTimeString()}`);\n" +
      "    console.log('Custom event data:', event.data);\n" +
      "  }\n" +
      "\n" +
      "  onValidatedEvent(data: string) {\n" +
      "    this.validatedData = data;\n" +
      "    this.addToLog(`Validated Event: ${data}`);\n" +
      "  }\n" +
      "\n" +
      "  onUserSelected(user: any) {\n" +
      "    this.addToLog(`User Selected (Alias): ${user.name}`);\n" +
      "  }\n" +
      "\n" +
      "  private addToLog(message: string) {\n" +
      "    const timestamp = new Date().toLocaleTimeString();\n" +
      "    this.eventLog.unshift(`[${timestamp}] ${message}`);\n" +
      "    \n" +
      "    // Keep only last 10 events\n" +
      "    if (this.eventLog.length > 10) {\n" +
      "      this.eventLog = this.eventLog.slice(0, 10);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Advanced EventEmitter Patterns:**\n" +
      "```typescript\n" +
      "// advanced-child.component.ts\n" +
      "import { Component, Output, EventEmitter, OnDestroy } from '@angular/core';\n" +
      "import { Subject, interval } from 'rxjs';\n" +
      "import { takeUntil } from 'rxjs/operators';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-advanced-child',\n" +
      "  template: `\n" +
      '    <div class="advanced-child">\n' +
      "      <h3>Advanced Child Component</h3>\n" +
      "      \n" +
      "      <!-- Periodic event emission -->\n" +
      '      <button (click)="startPeriodicEvents()">Start Periodic Events</button>\n' +
      '      <button (click)="stopPeriodicEvents()">Stop Periodic Events</button>\n' +
      "      <p>Periodic Events: {{ periodicCount }}</p>\n" +
      "      \n" +
      "      <!-- Batch event emission -->\n" +
      '      <button (click)="emitBatchEvents()">Emit Batch Events</button>\n' +
      "      \n" +
      "      <!-- Conditional event emission -->\n" +
      "      <div>\n" +
      '        <input [(ngModel)]="conditionalData" placeholder="Enter data" />\n' +
      '        <button (click)="emitConditionalEvent()">Emit Conditional Event</button>\n' +
      "      </div>\n" +
      "      \n" +
      "      <!-- Event with error handling -->\n" +
      '      <button (click)="emitEventWithError()">Emit Event with Error</button>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class AdvancedChildComponent implements OnDestroy {\n" +
      "  @Output() periodicEvent = new EventEmitter<number>();\n" +
      "  @Output() batchEvent = new EventEmitter<string[]>();\n" +
      "  @Output() conditionalEvent = new EventEmitter<string>();\n" +
      "  @Output() errorEvent = new EventEmitter<{ error: string; message: string }>();\n" +
      "  \n" +
      "  private destroy$ = new Subject<void>();\n" +
      "  private periodicSubscription: any;\n" +
      "  \n" +
      "  periodicCount = 0;\n" +
      "  conditionalData = '';\n" +
      "\n" +
      "  startPeriodicEvents() {\n" +
      "    this.periodicCount = 0;\n" +
      "    this.periodicSubscription = interval(1000)\n" +
      "      .pipe(takeUntil(this.destroy$))\n" +
      "      .subscribe(() => {\n" +
      "        this.periodicCount++;\n" +
      "        this.periodicEvent.emit(this.periodicCount);\n" +
      "      });\n" +
      "  }\n" +
      "\n" +
      "  stopPeriodicEvents() {\n" +
      "    if (this.periodicSubscription) {\n" +
      "      this.periodicSubscription.unsubscribe();\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  emitBatchEvents() {\n" +
      "    const batch = [\n" +
      "      'Event 1',\n" +
      "      'Event 2',\n" +
      "      'Event 3',\n" +
      "      'Event 4',\n" +
      "      'Event 5'\n" +
      "    ];\n" +
      "    this.batchEvent.emit(batch);\n" +
      "  }\n" +
      "\n" +
      "  emitConditionalEvent() {\n" +
      "    if (this.conditionalData && this.conditionalData.length > 0) {\n" +
      "      this.conditionalEvent.emit(this.conditionalData);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  emitEventWithError() {\n" +
      "    try {\n" +
      "      // Simulate an error\n" +
      "      throw new Error('Simulated error in child component');\n" +
      "    } catch (error) {\n" +
      "      this.errorEvent.emit({\n" +
      "        error: error.message,\n" +
      "        message: 'Error occurred in child component'\n" +
      "      });\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  ngOnDestroy() {\n" +
      "    this.destroy$.next();\n" +
      "    this.destroy$.complete();\n" +
      "    this.stopPeriodicEvents();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**EventEmitter vs Subject:**\n" +
      "```typescript\n" +
      "// Custom EventEmitter implementation\n" +
      "import { EventEmitter } from '@angular/core';\n" +
      "import { Subject } from 'rxjs';\n" +
      "\n" +
      "// EventEmitter extends Subject\n" +
      "// EventEmitter<T> extends Subject<T>\n" +
      "\n" +
      "// Custom event emitter with additional functionality\n" +
      "class CustomEventEmitter<T> extends EventEmitter<T> {\n" +
      "  private eventHistory: T[] = [];\n" +
      "  private maxHistory = 10;\n" +
      "\n" +
      "  emit(value: T): void {\n" +
      "    // Store in history\n" +
      "    this.eventHistory.unshift(value);\n" +
      "    if (this.eventHistory.length > this.maxHistory) {\n" +
      "      this.eventHistory = this.eventHistory.slice(0, this.maxHistory);\n" +
      "    }\n" +
      "    \n" +
      "    // Emit the value\n" +
      "    super.emit(value);\n" +
      "  }\n" +
      "\n" +
      "  getHistory(): T[] {\n" +
      "    return [...this.eventHistory];\n" +
      "  }\n" +
      "\n" +
      "  clearHistory(): void {\n" +
      "    this.eventHistory = [];\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices for @Output and EventEmitter:**\n" +
      "- Use descriptive event names\n" +
      "- Emit meaningful data with events\n" +
      "- Use TypeScript interfaces for event data\n" +
      "- Handle errors in event emission\n" +
      "- Clean up subscriptions in ngOnDestroy\n" +
      "- Use event aliases for better API design\n" +
      "- Avoid emitting too frequently (debounce if needed)\n" +
      "- Document event signatures clearly\n" +
      "- Consider using services for complex event patterns\n" +
      "- Test event emission and handling thoroughly",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "output", "eventemitter", "events", "parent-child"],
  },
  {
    id: 180,
    question: "What are Lifecycle Hooks in Angular and how do they work?",
    answer:
      "Lifecycle hooks in Angular are methods that Angular calls at specific points in a component's lifecycle, allowing you to tap into key moments in the component's existence to perform custom logic.\n\n" +
      "**Angular Component Lifecycle Hooks:**\n" +
      "```typescript\n" +
      "// lifecycle-demo.component.ts\n" +
      "import {\n" +
      "  Component,\n" +
      "  OnInit,\n" +
      "  OnDestroy,\n" +
      "  OnChanges,\n" +
      "  AfterViewInit,\n" +
      "  AfterViewChecked,\n" +
      "  AfterContentInit,\n" +
      "  AfterContentChecked,\n" +
      "  DoCheck,\n" +
      "  SimpleChanges,\n" +
      "  Input,\n      " +
      "  ViewChild,\n" +
      "  ElementRef\n" +
      "} from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-lifecycle-demo',\n" +
      "  template: `\n" +
      '    <div class="lifecycle-demo">\n' +
      "      <h3>Lifecycle Demo Component</h3>\n" +
      "      <p>Input Value: {{ inputValue }}</p>\n" +
      "      <p>Component Data: {{ componentData }}</p>\n" +
      "      <p>View Initialized: {{ viewInitialized }}</p>\n" +
      "      \n" +
      "      <div #contentRef>\n" +
      "        <p>Content Reference Element</p>\n" +
      "      </div>\n" +
      "      \n" +
      '      <button (click)="updateData()">Update Data</button>\n' +
      '      <button (click)="triggerChangeDetection()">Trigger Change Detection</button>\n' +
      "      \n" +
      '      <div class="lifecycle-log">\n' +
      "        <h4>Lifecycle Log:</h4>\n" +
      "        <ul>\n" +
      '          <li *ngFor="let log of lifecycleLog">{{ log }}</li>\n' +
      "        </ul>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .lifecycle-demo {\n" +
      "      padding: 20px;\n" +
      "      border: 1px solid #007bff;\n" +
      "      margin: 10px;\n" +
      "      background-color: #f8f9fa;\n" +
      "    }\n" +
      "    .lifecycle-log {\n" +
      "      margin-top: 20px;\n" +
      "      padding: 15px;\n" +
      "      background-color: #e9ecef;\n" +
      "      border-radius: 4px;\n" +
      "    }\n" +
      "    .lifecycle-log ul {\n" +
      "      list-style-type: none;\n" +
      "      padding: 0;\n" +
      "    }\n" +
      "    .lifecycle-log li {\n" +
      "      padding: 2px 0;\n" +
      "      font-family: monospace;\n" +
      "      font-size: 12px;\n" +
      "    }\n" +
      "  `]\n" +
      "})\n" +
      "export class LifecycleDemoComponent implements\n" +
      "  OnInit,\n" +
      "  OnDestroy,\n" +
      "  OnChanges,\n" +
      "  AfterViewInit,\n" +
      "  AfterViewChecked,\n" +
      "  AfterContentInit,\n" +
      "  AfterContentChecked,\n" +
      "  DoCheck {\n" +
      "\n" +
      "  @Input() inputValue: string = '';\n" +
      "  @ViewChild('contentRef') contentRef!: ElementRef;\n" +
      "\n" +
      "  componentData = 'Initial Data';\n" +
      "  viewInitialized = false;\n" +
      "  lifecycleLog: string[] = [];\n" +
      "  private changeDetectionCount = 0;\n" +
      "\n" +
      "  // 1. Constructor - Called first\n" +
      "  constructor() {\n" +
      "    this.addToLog('Constructor called');\n" +
      "    console.log('Constructor: Component instance created');\n" +
      "  }\n" +
      "\n" +
      "  // 2. ngOnChanges - Called when input properties change\n" +
      "  ngOnChanges(changes: SimpleChanges): void {\n" +
      "    this.addToLog('ngOnChanges called');\n" +
      "    console.log('ngOnChanges: Input changes detected', changes);\n" +
      "    \n" +
      "    if (changes['inputValue']) {\n" +
      "      console.log('Input value changed from', changes['inputValue'].previousValue, 'to', changes['inputValue'].currentValue);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // 3. ngOnInit - Called once after first ngOnChanges\n" +
      "  ngOnInit(): void {\n" +
      "    this.addToLog('ngOnInit called');\n" +
      "    console.log('ngOnInit: Component initialized');\n" +
      "    \n" +
      "    // Perfect place for:\n" +
      "    // - Initial data loading\n" +
      "    // - Setting up subscriptions\n" +
      "    // - Component initialization logic\n" +
      "    this.loadInitialData();\n" +
      "  }\n" +
      "\n" +
      "  // 4. ngDoCheck - Called during every change detection cycle\n" +
      "  ngDoCheck(): void {\n" +
      "    this.changeDetectionCount++;\n" +
      "    this.addToLog(`ngDoCheck called (${this.changeDetectionCount})`);\n" +
      "    \n" +
      "    // Use sparingly - called very frequently\n" +
      "    // Good for custom change detection logic\n" +
      "  }\n" +
      "\n" +
      "  // 5. ngAfterContentInit - Called once after content projection\n" +
      "  ngAfterContentInit(): void {\n" +
      "    this.addToLog('ngAfterContentInit called');\n" +
      "    console.log('ngAfterContentInit: Content projection initialized');\n" +
      "  }\n" +
      "\n" +
      "  // 6. ngAfterContentChecked - Called after every content check\n" +
      "  ngAfterContentChecked(): void {\n" +
      "    this.addToLog('ngAfterContentChecked called');\n" +
      "    // Called after every change detection cycle\n" +
      "  }\n" +
      "\n" +
      "  // 7. ngAfterViewInit - Called once after view initialization\n" +
      "  ngAfterViewInit(): void {\n" +
      "    this.addToLog('ngAfterViewInit called');\n" +
      "    this.viewInitialized = true;\n" +
      "    console.log('ngAfterViewInit: View initialized');\n" +
      "    \n" +
      "    // Perfect place for:\n" +
      "    // - Accessing ViewChild elements\n" +
      "    // - Setting up third-party libraries\n" +
      "    // - DOM manipulation\n" +
      "    if (this.contentRef) {\n" +
      "      console.log('Content ref element:', this.contentRef.nativeElement);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // 8. ngAfterViewChecked - Called after every view check\n" +
      "  ngAfterViewChecked(): void {\n" +
      "    this.addToLog('ngAfterViewChecked called');\n" +
      "    // Called after every change detection cycle\n" +
      "    // Be careful not to modify data here to avoid infinite loops\n" +
      "  }\n" +
      "\n" +
      "  // 9. ngOnDestroy - Called before component destruction\n" +
      "  ngOnDestroy(): void {\n" +
      "    this.addToLog('ngOnDestroy called');\n" +
      "    console.log('ngOnDestroy: Component being destroyed');\n" +
      "    \n" +
      "    // Perfect place for:\n" +
      "    // - Cleaning up subscriptions\n" +
      "    // - Removing event listeners\n" +
      "    // - Clearing timers\n" +
      "    // - Saving data\n" +
      "    this.cleanup();\n" +
      "  }\n" +
      "\n" +
      "  updateData() {\n" +
      "    this.componentData = `Updated at ${new Date().toLocaleTimeString()}`;\n" +
      "    this.addToLog('Data updated manually');\n" +
      "  }\n" +
      "\n" +
      "  triggerChangeDetection() {\n" +
      "    // This will trigger ngDoCheck, ngAfterContentChecked, and ngAfterViewChecked\n" +
      "    this.addToLog('Change detection triggered manually');\n" +
      "  }\n" +
      "\n" +
      "  private loadInitialData() {\n" +
      "    // Simulate data loading\n" +
      "    setTimeout(() => {\n" +
      "      this.componentData = 'Data loaded from server';\n" +
      "      this.addToLog('Initial data loaded');\n" +
      "    }, 1000);\n" +
      "  }\n" +
      "\n" +
      "  private cleanup() {\n" +
      "    // Cleanup logic\n" +
      "    console.log('Cleaning up resources...');\n" +
      "  }\n" +
      "\n" +
      "  private addToLog(message: string) {\n" +
      "    const timestamp = new Date().toLocaleTimeString();\n" +
      "    this.lifecycleLog.unshift(`[${timestamp}] ${message}`);\n" +
      "    \n" +
      "    // Keep only last 20 log entries\n" +
      "    if (this.lifecycleLog.length > 20) {\n" +
      "      this.lifecycleLog = this.lifecycleLog.slice(0, 20);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Lifecycle Hook Execution Order:**\n" +
      "```typescript\n" +
      "// Execution order for component lifecycle:\n" +
      "// 1. Constructor\n" +
      "// 2. ngOnChanges (if inputs exist)\n" +
      "// 3. ngOnInit\n" +
      "// 4. ngDoCheck\n" +
      "// 5. ngAfterContentInit\n" +
      "// 6. ngAfterContentChecked\n" +
      "// 7. ngAfterViewInit\n" +
      "// 8. ngAfterViewChecked\n" +
      "// 9. ngDoCheck (on subsequent change detection cycles)\n" +
      "// 10. ngAfterContentChecked (on subsequent change detection cycles)\n" +
      "// 11. ngAfterViewChecked (on subsequent change detection cycles)\n" +
      "// 12. ngOnDestroy (when component is destroyed)\n" +
      "\n" +
      "// For subsequent change detection cycles:\n" +
      "// - ngOnChanges (only if inputs change)\n" +
      "// - ngDoCheck\n" +
      "// - ngAfterContentChecked\n" +
      "// - ngAfterViewChecked\n" +
      "```\n\n" +
      "**Practical Lifecycle Hook Examples:**\n" +
      "```typescript\n" +
      "// data-service.component.ts\n" +
      "import { Component, OnInit, OnDestroy } from '@angular/core';\n" +
      "import { DataService } from './data.service';\n" +
      "import { Subscription } from 'rxjs';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-data-service',\n" +
      "  template: `\n" +
      '    <div class="data-service">\n' +
      "      <h3>Data Service Component</h3>\n" +
      '      <div *ngIf="loading">Loading...</div>\n' +
      '      <div *ngIf="!loading && data">\n' +
      "        <h4>Data:</h4>\n" +
      "        <pre>{{ data | json }}</pre>\n" +
      "      </div>\n" +
      '      <div *ngIf="error">Error: {{ error }}</div>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class DataServiceComponent implements OnInit, OnDestroy {\n" +
      "  data: any = null;\n" +
      "  loading = false;\n" +
      "  error: string | null = null;\n" +
      "  \n" +
      "  private subscription: Subscription = new Subscription();\n" +
      "\n" +
      "  constructor(private dataService: DataService) {}\n" +
      "\n" +
      "  ngOnInit(): void {\n" +
      "    this.loadData();\n" +
      "    this.setupRealTimeUpdates();\n" +
      "  }\n" +
      "\n" +
      "  ngOnDestroy(): void {\n" +
      "    // Clean up all subscriptions\n" +
      "    this.subscription.unsubscribe();\n" +
      "  }\n" +
      "\n" +
      "  private loadData(): void {\n" +
      "    this.loading = true;\n" +
      "    this.error = null;\n" +
      "    \n" +
      "    const dataSub = this.dataService.getData().subscribe({\n" +
      "      next: (data) => {\n" +
      "        this.data = data;\n" +
      "        this.loading = false;\n" +
      "      },\n" +
      "      error: (error) => {\n" +
      "        this.error = error.message;\n" +
      "        this.loading = false;\n" +
      "      }\n" +
      "    });\n" +
      "    \n" +
      "    this.subscription.add(dataSub);\n" +
      "  }\n" +
      "\n" +
      "  private setupRealTimeUpdates(): void {\n" +
      "    const realTimeSub = this.dataService.getRealTimeUpdates().subscribe({\n" +
      "      next: (update) => {\n" +
      "        this.data = { ...this.data, ...update };\n" +
      "      },\n" +
      "      error: (error) => {\n" +
      "        console.error('Real-time update error:', error);\n" +
      "      }\n" +
      "    });\n" +
      "    \n" +
      "    this.subscription.add(realTimeSub);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices for Lifecycle Hooks:**\n" +
      "- Use ngOnInit for initialization logic\n" +
      "- Use ngOnDestroy for cleanup\n" +
      "- Use ngOnChanges to react to input changes\n" +
      "- Use ngAfterViewInit for DOM access\n" +
      "- Avoid heavy operations in ngDoCheck\n" +
      "- Don't modify data in ngAfterViewChecked\n" +
      "- Always unsubscribe in ngOnDestroy\n" +
      "- Use OnPush change detection when possible\n" +
      "- Implement interfaces for better TypeScript support\n" +
      "- Test lifecycle hooks thoroughly",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "lifecycle", "hooks", "ngOnInit", "ngOnDestroy"],
  },
  {
    id: 181,
    question: "What is a Constructor in Angular and how does it work?",
    answer:
      "The constructor in Angular is a TypeScript class constructor that is called when a component instance is created. It's the first method that runs in a component's lifecycle and is primarily used for dependency injection.\n\n" +
      "**Constructor Basics:**\n" +
      "```typescript\n" +
      "// basic-constructor.component.ts\n" +
      "import { Component, Inject } from '@angular/core';\n" +
      "import { DOCUMENT } from '@angular/common';\n" +
      "import { Router } from '@angular/router';\n" +
      "import { DataService } from './data.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-basic-constructor',\n" +
      "  template: `\n" +
      '    <div class="constructor-demo">\n' +
      "      <h3>Constructor Demo</h3>\n" +
      "      <p>Service Data: {{ serviceData }}</p>\n" +
      "      <p>Router URL: {{ routerUrl }}</p>\n" +
      "      <p>Document Title: {{ documentTitle }}</p>\n" +
      "      <p>Constructor Called: {{ constructorCalled }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class BasicConstructorComponent {\n" +
      "  serviceData: string = '';\n" +
      "  routerUrl: string = '';\n" +
      "  documentTitle: string = '';\n" +
      "  constructorCalled: string = '';\n" +
      "\n" +
      "  constructor(\n" +
      "    private dataService: DataService,\n" +
      "    private router: Router,\n" +
      "    @Inject(DOCUMENT) private document: Document\n" +
      "  ) {\n" +
      "    console.log('Constructor called');\n" +
      "    this.constructorCalled = `Called at ${new Date().toLocaleTimeString()}`;\n" +
      "    \n" +
      "    // Basic initialization\n" +
      "    this.serviceData = this.dataService.getInitialData();\n" +
      "    this.routerUrl = this.router.url;\n" +
      "    this.documentTitle = this.document.title;\n" +
      "    \n" +
      "    // Log constructor execution\n" +
      "    console.log('Constructor execution completed');\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Advanced Constructor Patterns:**\n" +
      "```typescript\n" +
      "// advanced-constructor.component.ts\n" +
      "import { Component, Inject, Optional, SkipSelf, Self } from '@angular/core';\n" +
      "import { APP_CONFIG, AppConfig } from './app.config';\n" +
      "import { LoggerService } from './logger.service';\n" +
      "import { CacheService } from './cache.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-advanced-constructor',\n" +
      "  template: `\n" +
      '    <div class="advanced-constructor">\n' +
      "      <h3>Advanced Constructor Demo</h3>\n" +
      "      <p>App Config: {{ appConfig | json }}</p>\n" +
      "      <p>Logger Available: {{ loggerAvailable }}</p>\n" +
      "      <p>Cache Available: {{ cacheAvailable }}</p>\n" +
      "      <p>Parent Service: {{ parentService }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class AdvancedConstructorComponent {\n" +
      "  appConfig: AppConfig | null = null;\n" +
      "  loggerAvailable = false;\n" +
      "  cacheAvailable = false;\n" +
      "  parentService: string = '';\n" +
      "\n" +
      "  constructor(\n" +
      "    // Required dependency injection\n" +
      "    @Inject(APP_CONFIG) private config: AppConfig,\n" +
      "    \n" +
      "    // Optional dependency injection\n" +
      "    @Optional() private logger?: LoggerService,\n" +
      "    \n" +
      "    // Skip self and look in parent injector\n" +
      "    @SkipSelf() private parentCache?: CacheService,\n" +
      "    \n" +
      "    // Only use self injector (don't look in parent)\n" +
      "    @Self() private selfCache?: CacheService\n" +
      "  ) {\n" +
      "    console.log('Advanced constructor called');\n" +
      "    \n" +
      "    // Handle required dependencies\n" +
      "    this.appConfig = this.config;\n" +
      "    \n" +
      "    // Handle optional dependencies\n" +
      "    if (this.logger) {\n" +
      "      this.loggerAvailable = true;\n" +
      "      this.logger.log('Logger service available');\n" +
      "    } else {\n" +
      "      console.warn('Logger service not available');\n" +
      "    }\n" +
      "    \n" +
      "    // Handle parent service\n" +
      "    if (this.parentCache) {\n" +
      "      this.cacheAvailable = true;\n" +
      "      this.parentService = 'Parent cache service found';\n" +
      "    } else {\n" +
      "      this.parentService = 'No parent cache service';\n" +
      "    }\n" +
      "    \n" +
      "    // Handle self service\n" +
      "    if (this.selfCache) {\n" +
      "      console.log('Self cache service found');\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Constructor with Multiple Dependencies:**\n" +
      "```typescript\n" +
      "// multi-dependency.component.ts\n" +
      "import { Component, Inject } from '@angular/core';\n" +
      "import { HttpClient } from '@angular/common/http';\n" +
      "import { Router } from '@angular/router';\n" +
      "import { ActivatedRoute } from '@angular/router';\n" +
      "import { FormBuilder } from '@angular/forms';\n" +
      "import { MatSnackBar } from '@angular/material/snack-bar';\n" +
      "import { TranslateService } from '@ngx-translate/core';\n" +
      "\n" +
      "interface ComponentConfig {\n" +
      "  apiUrl: string;\n" +
      "  timeout: number;\n" +
      "  retries: number;\n" +
      "}\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-multi-dependency',\n" +
      "  template: `\n" +
      '    <div class="multi-dependency">\n' +
      "      <h3>Multi-Dependency Constructor</h3>\n" +
      "      <p>API URL: {{ config.apiUrl }}</p>\n" +
      "      <p>Timeout: {{ config.timeout }}ms</p>\n" +
      "      <p>Retries: {{ config.retries }}</p>\n" +
      "      <p>Current Route: {{ currentRoute }}</p>\n" +
      "      <p>Language: {{ currentLanguage }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class MultiDependencyComponent {\n" +
      "  config: ComponentConfig;\n" +
      "  currentRoute: string = '';\n" +
      "  currentLanguage: string = '';\n" +
      "\n" +
      "  constructor(\n" +
      "    // HTTP client for API calls\n" +
      "    private http: HttpClient,\n" +
      "    \n" +
      "    // Router for navigation\n" +
      "    private router: Router,\n" +
      "    \n" +
      "    // Activated route for current route info\n" +
      "    private route: ActivatedRoute,\n" +
      "    \n" +
      "    // Form builder for reactive forms\n" +
      "    private fb: FormBuilder,\n" +
      "    \n" +
      "    // Material snackbar for notifications\n" +
      "    private snackBar: MatSnackBar,\n" +
      "    \n" +
      "    // Translation service\n" +
      "    private translate: TranslateService,\n" +
      "    \n" +
      "    // Custom configuration\n" +
      "    @Inject('COMPONENT_CONFIG') private componentConfig: ComponentConfig\n" +
      "  ) {\n" +
      "    console.log('Multi-dependency constructor called');\n" +
      "    \n" +
      "    // Initialize configuration\n" +
      "    this.config = this.componentConfig;\n" +
      "    \n" +
      "    // Get current route information\n" +
      "    this.currentRoute = this.router.url;\n" +
      "    \n" +
      "    // Get current language\n" +
      "    this.currentLanguage = this.translate.currentLang || 'en';\n" +
      "    \n" +
      "    // Log all dependencies\n" +
      "    console.log('All dependencies injected successfully');\n" +
      "    console.log('HTTP Client:', this.http);\n" +
      "    console.log('Router:', this.router);\n" +
      "    console.log('Form Builder:', this.fb);\n" +
      "    console.log('Snack Bar:', this.snackBar);\n" +
      "    console.log('Translate Service:', this.translate);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Constructor Best Practices:**\n" +
      "```typescript\n" +
      "// best-practices.component.ts\n" +
      "import { Component, Inject } from '@angular/core';\n" +
      "import { DataService } from './data.service';\n" +
      "import { LoggerService } from './logger.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-best-practices',\n" +
      "  template: `\n" +
      '    <div class="best-practices">\n' +
      "      <h3>Constructor Best Practices</h3>\n" +
      "      <p>Service Initialized: {{ serviceInitialized }}</p>\n" +
      "      <p>Logger Ready: {{ loggerReady }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class BestPracticesComponent {\n" +
      "  serviceInitialized = false;\n" +
      "  loggerReady = false;\n" +
      "\n" +
      "  constructor(\n" +
      "    // Use private for services that are only used internally\n" +
      "    private dataService: DataService,\n" +
      "    \n" +
      "    // Use readonly for services that shouldn't be reassigned\n" +
      "    private readonly logger: LoggerService,\n" +
      "    \n" +
      "    // Use specific types instead of any\n" +
      "    @Inject('API_BASE_URL') private readonly apiBaseUrl: string\n" +
      "  ) {\n" +
      "    // DO: Keep constructor lightweight\n" +
      "    // DO: Only perform dependency injection\n" +
      "    // DO: Initialize simple properties\n" +
      "    \n" +
      "    this.serviceInitialized = true;\n" +
      "    this.loggerReady = this.logger.isReady();\n" +
      "    \n" +
      "    // DON'T: Perform heavy operations\n" +
      "    // DON'T: Make HTTP requests\n" +
      "    // DON'T: Access DOM elements\n" +
      "    // DON'T: Subscribe to observables\n" +
      "    \n" +
      "    console.log('Constructor completed - ready for ngOnInit');\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Constructor vs ngOnInit:**\n" +
      "```typescript\n" +
      "// constructor-vs-ngoninit.component.ts\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { DataService } from './data.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-constructor-vs-ngoninit',\n" +
      "  template: `\n" +
      '    <div class="comparison">\n' +
      "      <h3>Constructor vs ngOnInit</h3>\n" +
      "      <p>Constructor Data: {{ constructorData }}</p>\n" +
      "      <p>ngOnInit Data: {{ ngOnInitData }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ConstructorVsNgOnInitComponent implements OnInit {\n" +
      "  constructorData: string = '';\n" +
      "  ngOnInitData: string = '';\n" +
      "\n" +
      "  constructor(private dataService: DataService) {\n" +
      "    console.log('1. Constructor called');\n" +
      "    \n" +
      "    // Constructor: Dependency injection only\n" +
      "    // Constructor: Simple property initialization\n" +
      "    // Constructor: No access to @Input properties\n" +
      "    // Constructor: No access to DOM elements\n" +
      "    \n" +
      "    this.constructorData = 'Constructor executed';\n" +
      "    console.log('Constructor data:', this.constructorData);\n" +
      "  }\n" +
      "\n" +
      "  ngOnInit(): void {\n" +
      "    console.log('2. ngOnInit called');\n" +
      "    \n" +
      "    // ngOnInit: Component initialization\n" +
      "    // ngOnInit: Access to @Input properties\n" +
      "    // ngOnInit: HTTP requests\n" +
      "    // ngOnInit: Subscriptions\n" +
      "    // ngOnInit: Complex initialization logic\n" +
      "    \n" +
      "    this.ngOnInitData = 'ngOnInit executed';\n" +
      "    console.log('ngOnInit data:', this.ngOnInitData);\n" +
      "    \n" +
      "    // This is where you would typically load data\n" +
      "    // this.dataService.getData().subscribe(...);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Points about Constructors:**\n" +
      "- Called first in component lifecycle\n" +
      "- Used primarily for dependency injection\n" +
      "- Should be kept lightweight\n" +
      "- No access to @Input properties\n" +
      "- No access to DOM elements\n" +
      "- Perfect for simple property initialization\n" +
      "- Avoid heavy operations or HTTP calls\n" +
      "- Use TypeScript access modifiers (private, readonly)\n" +
      "- Handle optional dependencies with @Optional()\n" +
      "- Use @Inject() for custom tokens\n" +
      "- Consider using @SkipSelf() and @Self() for complex injection scenarios",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "constructor", "dependency-injection", "lifecycle"],
  },
  {
    id: 182,
    question: "What is ngOnChanges lifecycle hook in Angular?",
    answer:
      "ngOnChanges is a lifecycle hook in Angular that is called whenever Angular detects changes to input properties of a component. It provides access to both the current and previous values of the changed properties.\n\n" +
      "**Basic ngOnChanges Usage:**\n" +
      "```typescript\n" +
      "// ngOnchanges-demo.component.ts\n" +
      "import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';\n" +
      "\n" +
      "interface User {\n" +
      "  id: number;\n" +
      "  name: string;\n" +
      "  email: string;\n" +
      "}\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-ngonchanges-demo',\n" +
      "  template: `\n" +
      '    <div class="ngonchanges-demo">\n' +
      "      <h3>ngOnChanges Demo</h3>\n      " +
      "      <p>User Name: {{ userName }}</p>\n" +
      "      <p>User Age: {{ userAge }}</p>\n" +
      "      <p>User Object: {{ userObject | json }}</p>\n" +
      "      <p>Change Count: {{ changeCount }}</p>\n" +
      "      \n" +
      '      <div class="change-log">\n' +
      "        <h4>Change Log:</h4>\n" +
      "        <ul>\n" +
      '          <li *ngFor="let log of changeLog">{{ log }}</li>\n' +
      "        </ul>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .ngonchanges-demo {\n" +
      "      padding: 20px;\n" +
      "      border: 1px solid #28a745;\n" +
      "      margin: 10px;\n" +
      "      background-color: #d4edda;\n" +
      "    }\n" +
      "    .change-log {\n" +
      "      margin-top: 20px;\n" +
      "      padding: 15px;\n" +
      "      background-color: #e9ecef;\n" +
      "      border-radius: 4px;\n" +
      "    }\n" +
      "    .change-log ul {\n" +
      "      list-style-type: none;\n" +
      "      padding: 0;\n" +
      "    }\n" +
      "    .change-log li {\n" +
      "      padding: 2px 0;\n" +
      "      font-family: monospace;\n" +
      "      font-size: 12px;\n" +
      "    }\n" +
      "  `]\n" +
      "})\n" +
      "export class NgOnChangesDemoComponent implements OnChanges {\n" +
      "  @Input() userName: string = '';\n" +
      "  @Input() userAge: number = 0;\n" +
      "  @Input() userObject: User | null = null;\n" +
      "  \n" +
      "  changeCount = 0;\n" +
      "  changeLog: string[] = [];\n" +
      "\n" +
      "  ngOnChanges(changes: SimpleChanges): void {\n" +
      "    console.log('ngOnChanges called with changes:', changes);\n" +
      "    \n" +
      "    this.changeCount++;\n" +
      "    const timestamp = new Date().toLocaleTimeString();\n" +
      "    \n" +
      "    // Log all changes\n" +
      "    Object.keys(changes).forEach(key => {\n" +
      "      const change = changes[key];\n" +
      "      const logEntry = `[${timestamp}] ${key}: ${change.previousValue} → ${change.currentValue}`;\n" +
      "      this.changeLog.unshift(logEntry);\n" +
      "      \n" +
      "      console.log(`Property ${key} changed:`, {\n" +
      "        previousValue: change.previousValue,\n" +
      "        currentValue: change.currentValue,\n" +
      "        firstChange: change.firstChange,\n" +
      "        isFirstChange: change.isFirstChange()\n" +
      "      });\n" +
      "    });\n" +
      "    \n" +
      "    // Keep only last 10 log entries\n" +
      "    if (this.changeLog.length > 10) {\n" +
      "      this.changeLog = this.changeLog.slice(0, 10);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Advanced ngOnChanges Patterns:**\n" +
      "```typescript\n" +
      "// advanced-ngonchanges.component.ts\n" +
      "import { Component, Input, OnChanges, SimpleChanges, OnInit } from '@angular/core';\n" +
      "import { DataService } from './data.service';\n" +
      "\n" +
      "interface Config {\n" +
      "  theme: 'light' | 'dark';\n" +
      "  language: string;\n" +
      "  features: string[];\n" +
      "}\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-advanced-ngonchanges',\n" +
      "  template: `\n" +
      '    <div [class]="getComponentClasses()">\n' +
      "      <h3>Advanced ngOnChanges</h3>\n" +
      "      <p>Theme: {{ config.theme }}</p>\n" +
      "      <p>Language: {{ config.language }}</p>\n" +
      "      <p>Features: {{ config.features.join(', ') }}</p>\n" +
      "      <p>Data Loaded: {{ dataLoaded }}</p>\n" +
      "      <p>Last Update: {{ lastUpdate }}</p>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .component {\n" +
      "      padding: 20px;\n" +
      "      border: 1px solid #ccc;\n" +
      "      margin: 10px;\n" +
      "    }\n" +
      "    .theme-light { background-color: #f8f9fa; color: #333; }\n" +
      "    .theme-dark { background-color: #333; color: #f8f9fa; }\n" +
      "  `]\n" +
      "})\n" +
      "export class AdvancedNgOnChangesComponent implements OnChanges, OnInit {\n" +
      "  @Input() config: Config = {\n" +
      "    theme: 'light',\n" +
      "    language: 'en',\n" +
      "    features: []\n" +
      "  };\n" +
      "  \n" +
      "  @Input() userId: number = 0;\n" +
      "  \n" +
      "  dataLoaded = false;\n" +
      "  lastUpdate: string = '';\n" +
      "  private previousConfig: Config | null = null;\n" +
      "\n" +
      "  constructor(private dataService: DataService) {}\n" +
      "\n" +
      "  ngOnInit(): void {\n" +
      "    console.log('ngOnInit called');\n" +
      "    this.loadInitialData();\n" +
      "  }\n" +
      "\n" +
      "  ngOnChanges(changes: SimpleChanges): void {\n" +
      "    console.log('ngOnChanges called with changes:', changes);\n" +
      "    \n" +
      "    // Handle config changes\n" +
      "    if (changes['config']) {\n" +
      "      this.handleConfigChange(changes['config']);\n" +
      "    }\n" +
      "    \n" +
      "    // Handle user ID changes\n" +
      "    if (changes['userId']) {\n" +
      "      this.handleUserIdChange(changes['userId']);\n" +
      "    }\n" +
      "    \n" +
      "    // Handle multiple changes\n" +
      "    if (changes['config'] && changes['userId']) {\n" +
      "      this.handleMultipleChanges();\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  private handleConfigChange(change: any): void {\n" +
      "    console.log('Config changed:', change);\n" +
      "    \n" +
      "    // Check if theme changed\n" +
      "    if (change.previousValue?.theme !== change.currentValue?.theme) {\n" +
      "      console.log('Theme changed from', change.previousValue?.theme, 'to', change.currentValue?.theme);\n" +
      "      this.applyTheme(change.currentValue.theme);\n" +
      "    }\n" +
      "    \n" +
      "    // Check if language changed\n" +
      "    if (change.previousValue?.language !== change.currentValue?.language) {\n" +
      "      console.log('Language changed from', change.previousValue?.language, 'to', change.currentValue?.language);\n" +
      "      this.updateLanguage(change.currentValue.language);\n" +
      "    }\n" +
      "    \n" +
      "    // Check if features changed\n" +
      "    if (JSON.stringify(change.previousValue?.features) !== JSON.stringify(change.currentValue?.features)) {\n" +
      "      console.log('Features changed');\n" +
      "      this.updateFeatures(change.currentValue.features);\n" +
      "    }\n" +
      "    \n" +
      "    this.previousConfig = change.currentValue;\n" +
      "  }\n" +
      "\n" +
      "  private handleUserIdChange(change: any): void {\n" +
      "    console.log('User ID changed from', change.previousValue, 'to', change.currentValue);\n" +
      "    \n" +
      "    if (change.currentValue && change.currentValue !== change.previousValue) {\n" +
      "      this.loadUserData(change.currentValue);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  private handleMultipleChanges(): void {\n" +
      "    console.log('Multiple properties changed simultaneously');\n" +
      "    this.lastUpdate = new Date().toLocaleTimeString();\n" +
      "  }\n" +
      "\n" +
      "  private applyTheme(theme: string): void {\n" +
      "    console.log('Applying theme:', theme);\n" +
      "    // Theme application logic\n" +
      "  }\n" +
      "\n" +
      "  private updateLanguage(language: string): void {\n" +
      "    console.log('Updating language:', language);\n" +
      "    // Language update logic\n" +
      "  }\n" +
      "\n" +
      "  private updateFeatures(features: string[]): void {\n" +
      "    console.log('Updating features:', features);\n" +
      "    // Features update logic\n" +
      "  }\n" +
      "\n" +
      "  private loadUserData(userId: number): void {\n" +
      "    console.log('Loading data for user:', userId);\n" +
      "    this.dataLoaded = true;\n" +
      "    // Data loading logic\n" +
      "  }\n" +
      "\n" +
      "  private loadInitialData(): void {\n" +
      "    console.log('Loading initial data');\n" +
      "    // Initial data loading logic\n" +
      "  }\n" +
      "\n" +
      "  getComponentClasses(): string {\n" +
      "    return `component theme-${this.config.theme}`;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**ngOnChanges with Object Comparison:**\n" +
      "```typescript\n" +
      "// object-comparison.component.ts\n" +
      "import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';\n" +
      "\n" +
      "interface ComplexObject {\n" +
      "  id: number;\n" +
      "  name: string;\n" +
      "  metadata: {\n" +
      "    tags: string[];\n" +
      "    settings: Record<string, any>;\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-object-comparison',\n" +
      "  template: `\n" +
      '    <div class="object-comparison">\n' +
      "      <h3>Object Comparison in ngOnChanges</h3>\n" +
      "      <p>Object ID: {{ complexObject.id }}</p>\n" +
      "      <p>Object Name: {{ complexObject.name }}</p>\n      " +
      "      <p>Tags: {{ complexObject.metadata.tags.join(', ') }}</p>\n" +
      "      <p>Settings: {{ complexObject.metadata.settings | json }}</p>\n" +
      "      <p>Deep Change Detected: {{ deepChangeDetected }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ObjectComparisonComponent implements OnChanges {\n" +
      "  @Input() complexObject: ComplexObject = {\n" +
      "    id: 0,\n" +
      "    name: '',\n" +
      "    metadata: {\n" +
      "      tags: [],\n" +
      "      settings: {}\n" +
      "    }\n" +
      "  };\n" +
      "  \n" +
      "  deepChangeDetected = false;\n" +
      "  private previousObject: ComplexObject | null = null;\n" +
      "\n" +
      "  ngOnChanges(changes: SimpleChanges): void {\n" +
      "    if (changes['complexObject']) {\n" +
      "      const change = changes['complexObject'];\n      " +
      "      \n" +
      "      // Angular only detects reference changes for objects\n" +
      "      // It doesn't detect deep changes within objects\n" +
      "      console.log('Object reference changed:', change);\n" +
      "      \n" +
      "      // Manual deep comparison\n" +
      "      if (this.previousObject && this.hasDeepChanges(this.previousObject, change.currentValue)) {\n" +
      "        this.deepChangeDetected = true;\n" +
      "        console.log('Deep changes detected in object');\n" +
      "        this.handleDeepChanges(this.previousObject, change.currentValue);\n" +
      "      } else {\n" +
      "        this.deepChangeDetected = false;\n" +
      "      }\n" +
      "      \n" +
      "      this.previousObject = change.currentValue;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  private hasDeepChanges(previous: ComplexObject, current: ComplexObject): boolean {\n" +
      "    // Compare primitive properties\n" +
      "    if (previous.id !== current.id || previous.name !== current.name) {\n" +
      "      return true;\n" +
      "    }\n" +
      "    \n" +
      "    // Compare arrays\n" +
      "    if (JSON.stringify(previous.metadata.tags) !== JSON.stringify(current.metadata.tags)) {\n" +
      "      return true;\n" +
      "    }\n" +
      "    \n" +
      "    // Compare nested objects\n" +
      "    if (JSON.stringify(previous.metadata.settings) !== JSON.stringify(current.metadata.settings)) {\n" +
      "      return true;\n" +
      "    }\n" +
      "    \n" +
      "    return false;\n" +
      "  }\n" +
      "\n" +
      "  private handleDeepChanges(previous: ComplexObject, current: ComplexObject): void {\n" +
      "    console.log('Handling deep changes:');\n" +
      "    console.log('Previous:', previous);\n" +
      "    console.log('Current:', current);\n" +
      "    \n" +
      "    // Handle specific deep changes\n" +
      "    if (previous.metadata.tags.length !== current.metadata.tags.length) {\n" +
      "      console.log('Tags array length changed');\n" +
      "    }\n" +
      "    \n" +
      "    if (Object.keys(previous.metadata.settings).length !== Object.keys(current.metadata.settings).length) {\n" +
      "      console.log('Settings object properties changed');\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Points about ngOnChanges:**\n" +
      "- Called before ngOnInit and whenever input properties change\n" +
      "- Receives SimpleChanges object with change information\n" +
      "- Only detects reference changes for objects (not deep changes)\n" +
      "- Use for reacting to input property changes\n" +
      "- Perfect for validation, data processing, and side effects\n" +
      "- Can be called multiple times during component lifecycle\n" +
      "- First call happens before ngOnInit\n" +
      "- Use change.isFirstChange() to detect first change\n" +
      "- Compare previousValue and currentValue for change detection\n" +
      "- Consider performance implications for complex objects\n" +
      "- Use OnPush change detection strategy for better performance",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "ngOnChanges", "lifecycle", "input", "changes"],
  },
  {
    id: 183,
    question: "What is ngOnInit lifecycle hook in Angular?",
    answer:
      "ngOnInit is a lifecycle hook in Angular that is called once after the component's first ngOnChanges. It's the perfect place to perform component initialization logic, such as loading data, setting up subscriptions, and accessing @Input properties.\n\n" +
      "**Basic ngOnInit Usage:**\n" +
      "```typescript\n" +
      "// ngOnInit-demo.component.ts\n" +
      "import { Component, OnInit, Input } from '@angular/core';\n" +
      "import { DataService } from './data.service';\n" +
      "import { Subscription } from 'rxjs';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-ngoninit-demo',\n" +
      "  template: `\n" +
      '    <div class="ngoninit-demo">\n' +
      "      <h3>ngOnInit Demo</h3>\n" +
      "      <p>User ID: {{ userId }}</p>\n" +
      "      <p>User Data: {{ userData | json }}</p>\n" +
      "      <p>Loading: {{ loading }}</p>\n" +
      "      <p>Error: {{ error }}</p>\n" +
      "      <p>Initialization Complete: {{ initializationComplete }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class NgOnInitDemoComponent implements OnInit {\n" +
      "  @Input() userId: number = 0;\n" +
      "  \n" +
      "  userData: any = null;\n" +
      "  loading = false;\n" +
      "  error: string | null = null;\n" +
      "  initializationComplete = false;\n" +
      "  \n" +
      "  private subscription: Subscription = new Subscription();\n" +
      "\n" +
      "  constructor(private dataService: DataService) {\n" +
      "    console.log('Constructor called - userId not yet available:', this.userId);\n" +
      "  }\n" +
      "\n" +
      "  ngOnInit(): void {\n" +
      "    console.log('ngOnInit called - userId now available:', this.userId);\n" +
      "    \n" +
      "    // Perfect place for:\n" +
      "    // 1. Initial data loading\n" +
      "    // 2. Setting up subscriptions\n" +
      "    // 3. Component initialization logic\n" +
      "    // 4. Accessing @Input properties\n" +
      "    \n" +
      "    this.loadUserData();\n" +
      "    this.setupSubscriptions();\n" +
      "    this.performInitialization();\n" +
      "  }\n" +
      "\n" +
      "  private loadUserData(): void {\n" +
      "    if (this.userId > 0) {\n" +
      "      this.loading = true;\n" +
      "      this.error = null;\n" +
      "      \n" +
      "      const userSub = this.dataService.getUser(this.userId).subscribe({\n" +
      "        next: (user) => {\n" +
      "          this.userData = user;\n" +
      "          this.loading = false;\n" +
      "          console.log('User data loaded:', user);\n" +
      "        },\n" +
      "        error: (error) => {\n" +
      "          this.error = error.message;\n" +
      "          this.loading = false;\n" +
      "          console.error('Error loading user data:', error);\n" +
      "        }\n" +
      "      });\n" +
      "      \n" +
      "      this.subscription.add(userSub);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  private setupSubscriptions(): void {\n" +
      "    console.log('Setting up subscriptions');\n" +
      "    \n" +
      "    // Example: Listen to global events\n" +
      "    const globalEventSub = this.dataService.getGlobalEvents().subscribe({\n" +
      "      next: (event) => {\n" +
      "        console.log('Global event received:', event);\n" +
      "        this.handleGlobalEvent(event);\n" +
      "      },\n" +
      "      error: (error) => {\n" +
      "        console.error('Global event error:', error);\n" +
      "      }\n" +
      "    });\n" +
      "    \n" +
      "    this.subscription.add(globalEventSub);\n" +
      "  }\n" +
      "\n" +
      "  private performInitialization(): void {\n" +
      "    console.log('Performing component initialization');\n" +
      "    \n" +
      "    // Initialize component state\n" +
      "    this.initializationComplete = true;\n" +
      "    \n" +
      "    // Set up component-specific logic\n" +
      "    this.setupComponentLogic();\n" +
      "  }\n" +
      "\n" +
      "  private setupComponentLogic(): void {\n" +
      "    console.log('Setting up component-specific logic');\n" +
      "    // Component-specific initialization\n" +
      "  }\n" +
      "\n" +
      "  private handleGlobalEvent(event: any): void {\n" +
      "    console.log('Handling global event:', event);\n" +
      "    // Handle global events\n" +
      "  }\n" +
      "\n" +
      "  ngOnDestroy(): void {\n" +
      "    console.log('ngOnDestroy called - cleaning up subscriptions');\n" +
      "    this.subscription.unsubscribe();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Points about ngOnInit:**\n" +
      "- Called once after first ngOnChanges\n" +
      "- Perfect for component initialization\n" +
      "- Access to @Input properties\n" +
      "- Ideal for HTTP requests and subscriptions\n" +
      "- Called before ngAfterViewInit\n" +
      "- Use for complex initialization logic\n" +
      "- Always implement OnInit interface\n" +
      "- Clean up subscriptions in ngOnDestroy",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "ngOnInit", "lifecycle", "initialization"],
  },
  {
    id: 184,
    question: "What is the difference between constructor and ngOnInit in Angular?",
    answer:
      "The constructor and ngOnInit serve different purposes in Angular components. Understanding their differences is crucial for proper component initialization and lifecycle management.\n\n" +
      "**Key Differences:**\n\n" +
      "**1. Execution Order:**\n" +
      "```typescript\n" +
      "// execution-order.component.ts\n" +
      "import { Component, OnInit, Input, OnChanges, SimpleChanges } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-execution-order',\n" +
      "  template: `\n" +
      '    <div class="execution-order">\n' +
      "      <h3>Execution Order Demo</h3>\n" +
      "      <p>Input Value: {{ inputValue }}</p>\n" +
      "      <p>Execution Log:</p>\n" +
      "      <ul>\n" +
      '        <li *ngFor="let log of executionLog">{{ log }}</li>\n' +
      "      </ul>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ExecutionOrderComponent implements OnInit, OnChanges {\n" +
      "  @Input() inputValue: string = '';\n" +
      "  executionLog: string[] = [];\n" +
      "\n" +
      "  constructor() {\n" +
      "    this.addLog('1. Constructor called');\n" +
      "    console.log('Constructor - inputValue:', this.inputValue); // Will be empty\n" +
      "  }\n" +
      "\n" +
      "  ngOnChanges(changes: SimpleChanges): void {\n" +
      "    this.addLog('2. ngOnChanges called');\n" +
      "    console.log('ngOnChanges - inputValue:', this.inputValue);\n" +
      "  }\n" +
      "\n" +
      "  ngOnInit(): void {\n" +
      "    this.addLog('3. ngOnInit called');\n" +
      "    console.log('ngOnInit - inputValue:', this.inputValue); // Now has value\n" +
      "  }\n" +
      "\n" +
      "  private addLog(message: string): void {\n" +
      "    const timestamp = new Date().toLocaleTimeString();\n" +
      "    this.executionLog.push(`[${timestamp}] ${message}`);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**2. Access to @Input Properties:**\n" +
      "```typescript\n" +
      "// input-access.component.ts\n" +
      "import { Component, OnInit, Input } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-input-access',\n" +
      "  template: `\n" +
      '    <div class="input-access">\n' +
      "      <h3>@Input Access Demo</h3>\n" +
      "      <p>User ID: {{ userId }}</p>\n" +
      "      <p>User Name: {{ userName }}</p>\n" +
      "      <p>Constructor Access: {{ constructorAccess }}</p>\n" +
      "      <p>ngOnInit Access: {{ ngOnInitAccess }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class InputAccessComponent implements OnInit {\n" +
      "  @Input() userId: number = 0;\n" +
      "  @Input() userName: string = '';\n" +
      "  \n" +
      "  constructorAccess: string = '';\n" +
      "  ngOnInitAccess: string = '';\n" +
      "\n" +
      "  constructor() {\n" +
      "    // @Input properties are NOT available in constructor\n" +
      "    this.constructorAccess = `User ID: ${this.userId}, Name: ${this.userName}`;\n" +
      "    console.log('Constructor - @Input values:', { userId: this.userId, userName: this.userName });\n" +
      "  }\n" +
      "\n" +
      "  ngOnInit(): void {\n" +
      "    // @Input properties ARE available in ngOnInit\n" +
      "    this.ngOnInitAccess = `User ID: ${this.userId}, Name: ${this.userName}`;\n" +
      "    console.log('ngOnInit - @Input values:', { userId: this.userId, userName: this.userName });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. Purpose and Usage:**\n" +
      "```typescript\n" +
      "// purpose-comparison.component.ts\n" +
      "import { Component, OnInit, Input } from '@angular/core';\n" +
      "import { DataService } from './data.service';\n" +
      "import { Subscription } from 'rxjs';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-purpose-comparison',\n" +
      "  template: `\n" +
      '    <div class="purpose-comparison">\n' +
      "      <h3>Purpose Comparison</h3>\n" +
      "      <p>Data Loaded: {{ dataLoaded }}</p>\n" +
      "      <p>Service Ready: {{ serviceReady }}</p>\n" +
      "      <p>Initialization Complete: {{ initializationComplete }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class PurposeComparisonComponent implements OnInit {\n" +
      "  @Input() userId: number = 0;\n" +
      "  \n" +
      "  dataLoaded = false;\n" +
      "  serviceReady = false;\n" +
      "  initializationComplete = false;\n" +
      "  \n" +
      "  private subscription: Subscription = new Subscription();\n" +
      "\n" +
      "  constructor(private dataService: DataService) {\n" +
      "    // CONSTRUCTOR PURPOSE:\n" +
      "    // - Dependency injection\n" +
      "    // - Simple property initialization\n" +
      "    // - Basic setup\n" +
      "    \n" +
      "    console.log('Constructor: Setting up dependencies');\n" +
      "    this.serviceReady = true;\n" +
      "    \n" +
      "    // DON'T do these in constructor:\n" +
      "    // - HTTP requests\n" +
      "    // - Complex initialization\n" +
      "    // - Access @Input properties\n" +
      "    // - DOM manipulation\n" +
      "  }\n" +
      "\n" +
      "  ngOnInit(): void {\n" +
      "    // NGONINIT PURPOSE:\n" +
      "    // - Component initialization\n" +
      "    // - Data loading\n" +
      "    // - Setting up subscriptions\n" +
      "    // - Accessing @Input properties\n" +
      "    \n" +
      "    console.log('ngOnInit: Starting component initialization');\n" +
      "    \n" +
      "    if (this.userId > 0) {\n" +
      "      this.loadData();\n" +
      "    }\n" +
      "    \n" +
      "    this.setupSubscriptions();\n" +
      "    this.initializationComplete = true;\n" +
      "  }\n" +
      "\n" +
      "  private loadData(): void {\n" +
      "    console.log('Loading data for user:', this.userId);\n" +
      "    \n" +
      "    const dataSub = this.dataService.getUserData(this.userId).subscribe({\n" +
      "      next: (data) => {\n" +
      "        this.dataLoaded = true;\n" +
      "        console.log('Data loaded successfully');\n" +
      "      },\n" +
      "      error: (error) => {\n" +
      "        console.error('Error loading data:', error);\n" +
      "      }\n" +
      "    });\n" +
      "    \n" +
      "    this.subscription.add(dataSub);\n" +
      "  }\n" +
      "\n" +
      "  private setupSubscriptions(): void {\n" +
      "    console.log('Setting up subscriptions');\n" +
      "    // Subscription setup logic\n" +
      "  }\n" +
      "\n" +
      "  ngOnDestroy(): void {\n" +
      "    this.subscription.unsubscribe();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Summary of Differences:**\n\n" +
      "| Aspect | Constructor | ngOnInit |\n" +
      "|--------|-------------|----------|\n" +
      "| **Purpose** | Dependency injection | Component initialization |\n" +
      "| **Execution** | First (before ngOnChanges) | After first ngOnChanges |\n" +
      "| **@Input Access** | ❌ Not available | ✅ Available |\n" +
      "| **DOM Access** | ❌ Not available | ❌ Not available (use ngAfterViewInit) |\n" +
      "| **HTTP Requests** | ❌ Avoid | ✅ Perfect place |\n" +
      "| **Subscriptions** | ❌ Avoid | ✅ Perfect place |\n" +
      "| **Heavy Operations** | ❌ Avoid | ✅ Can handle |\n" +
      "| **Called** | Once per instance | Once per instance |\n" +
      "| **Best For** | Simple setup, DI | Complex initialization |\n\n" +
      "**Best Practices:**\n" +
      "- Use constructor for dependency injection only\n" +
      "- Use ngOnInit for component initialization\n" +
      "- Keep constructor lightweight\n" +
      "- Always implement OnInit interface\n" +
      "- Clean up subscriptions in ngOnDestroy\n" +
      "- Don't access @Input properties in constructor\n" +
      "- Use ngOnInit for data loading and setup",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "constructor", "ngOnInit", "lifecycle", "comparison"],
  },
  {
    id: 185,
    question: "What are the various ways to communicate between components in Angular?",
    answer:
      "Angular provides multiple ways for components to communicate with each other, each suited for different scenarios and component relationships.\n\n" +
      "**1. Parent to Child Communication (@Input):**\n" +
      "```typescript\n" +
      "// parent.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-parent',\n" +
      "  template: `\n" +
      '    <div class="parent">\n' +
      "      <h3>Parent Component</h3>\n" +
      "      <p>Parent Data: {{ parentData }}</p>\n" +
      '      <button (click)="updateData()">Update Data</button>\n' +
      "      \n" +
      "      <!-- Pass data to child -->\n" +
      "      <app-child \n" +
      '        [childInput]="parentData" \n' +
      '        [userInfo]="userInfo"\n' +
      '        [config]="config">\n' +
      "      </app-child>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ParentComponent {\n" +
      "  parentData = 'Initial Parent Data';\n" +
      "  userInfo = {\n" +
      "    name: 'John Doe',\n" +
      "    email: 'john@example.com',\n" +
      "    role: 'admin'\n" +
      "  };\n" +
      "  config = {\n" +
      "    theme: 'dark',\n" +
      "    language: 'en',\n" +
      "    features: ['feature1', 'feature2']\n" +
      "  };\n" +
      "\n" +
      "  updateData() {\n" +
      "    this.parentData = `Updated at ${new Date().toLocaleTimeString()}`;\n" +
      "    this.userInfo.name = 'Jane Smith';\n" +
      "    this.config.theme = this.config.theme === 'dark' ? 'light' : 'dark';\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "// child.component.ts\n" +
      "import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-child',\n" +
      "  template: `\n" +
      '    <div class="child">\n' +
      "      <h4>Child Component</h4>\n" +
      "      <p>Received Data: {{ childInput }}</p>\n" +
      "      <p>User: {{ userInfo.name }} ({{ userInfo.email }})</p>\n" +
      "      <p>Theme: {{ config.theme }}</p>\n" +
      "      <p>Features: {{ config.features.join(', ') }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ChildComponent implements OnChanges {\n" +
      "  @Input() childInput: string = '';\n" +
      "  @Input() userInfo: any = {};\n" +
      "  @Input() config: any = {};\n" +
      "\n" +
      "  ngOnChanges(changes: SimpleChanges): void {\n" +
      "    console.log('Child received changes:', changes);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**2. Child to Parent Communication (@Output + EventEmitter):**\n" +
      "```typescript\n" +
      "// child.component.ts\n" +
      "import { Component, Output, EventEmitter } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-child-output',\n" +
      "  template: `\n" +
      '    <div class="child-output">\n' +
      "      <h4>Child Component with Output</h4>\n" +
      '      <input [(ngModel)]="childData" placeholder="Enter data">\n' +
      '      <button (click)="sendDataToParent()">Send to Parent</button>\n' +
      '      <button (click)="notifyParent()">Notify Parent</button>\n' +
      '      <button (click)="requestUpdate()">Request Update</button>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ChildOutputComponent {\n" +
      "  childData = '';\n" +
      "\n" +
      "  // Output events to parent\n" +
      "  @Output() dataChanged = new EventEmitter<string>();\n" +
      "  @Output() notification = new EventEmitter<{type: string, message: string}>();\n" +
      "  @Output() updateRequested = new EventEmitter<void>();\n" +
      "\n" +
      "  sendDataToParent() {\n" +
      "    this.dataChanged.emit(this.childData);\n" +
      "  }\n" +
      "\n" +
      "  notifyParent() {\n" +
      "    this.notification.emit({\n" +
      "      type: 'info',\n" +
      "      message: 'Child component notification'\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  requestUpdate() {\n" +
      "    this.updateRequested.emit();\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "// parent.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-parent-output',\n" +
      "  template: `\n" +
      '    <div class="parent-output">\n' +
      "      <h3>Parent Component</h3>\n" +
      "      <p>Received from Child: {{ receivedData }}</p>\n" +
      "      <p>Last Notification: {{ lastNotification }}</p>\n" +
      "      <p>Update Count: {{ updateCount }}</p>\n" +
      "      \n" +
      "      <app-child-output\n" +
      '        (dataChanged)="onDataChanged($event)"\n' +
      '        (notification)="onNotification($event)"\n' +
      '        (updateRequested)="onUpdateRequested()">\n' +
      "      </app-child-output>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ParentOutputComponent {\n" +
      "  receivedData = '';\n" +
      "  lastNotification = '';\n" +
      "  updateCount = 0;\n" +
      "\n" +
      "  onDataChanged(data: string) {\n" +
      "    this.receivedData = data;\n" +
      "    console.log('Parent received data:', data);\n" +
      "  }\n" +
      "\n" +
      "  onNotification(notification: {type: string, message: string}) {\n" +
      "    this.lastNotification = `${notification.type}: ${notification.message}`;\n" +
      "    console.log('Parent received notification:', notification);\n" +
      "  }\n" +
      "\n" +
      "  onUpdateRequested() {\n" +
      "    this.updateCount++;\n" +
      "    console.log('Parent received update request');\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. Sibling Component Communication (Service + Subject):**\n" +
      "```typescript\n" +
      "// communication.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { Subject, BehaviorSubject } from 'rxjs';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class CommunicationService {\n" +
      "  // Subject for one-time events\n" +
      "  private messageSubject = new Subject<string>();\n" +
      "  public message$ = this.messageSubject.asObservable();\n" +
      "\n" +
      "  // BehaviorSubject for state that needs initial value\n" +
      "  private stateSubject = new BehaviorSubject<any>({ count: 0, data: null });\n" +
      "  public state$ = this.stateSubject.asObservable();\n" +
      "\n" +
      "  // Methods to send data\n" +
      "  sendMessage(message: string) {\n" +
      "    this.messageSubject.next(message);\n" +
      "  }\n" +
      "\n" +
      "  updateState(newState: any) {\n" +
      "    this.stateSubject.next(newState);\n" +
      "  }\n" +
      "\n" +
      "  getCurrentState() {\n" +
      "    return this.stateSubject.value;\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "// sibling1.component.ts\n" +
      "import { Component, OnInit, OnDestroy } from '@angular/core';\n" +
      "import { CommunicationService } from './communication.service';\n" +
      "import { Subscription } from 'rxjs';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-sibling1',\n" +
      "  template: `\n" +
      '    <div class="sibling1">\n' +
      "      <h4>Sibling 1</h4>\n" +
      '      <input [(ngModel)]="message" placeholder="Enter message">\n' +
      '      <button (click)="sendMessage()">Send Message</button>\n' +
      '      <button (click)="updateState()">Update State</button>\n' +
      "      <p>Received State: {{ receivedState | json }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class Sibling1Component implements OnInit, OnDestroy {\n" +
      "  message = '';\n" +
      "  receivedState: any = {};\n" +
      "  private subscription: Subscription = new Subscription();\n" +
      "\n" +
      "  constructor(private communicationService: CommunicationService) {}\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    // Listen to state changes\n" +
      "    const stateSub = this.communicationService.state$.subscribe(state => {\n" +
      "      this.receivedState = state;\n" +
      "    });\n" +
      "    this.subscription.add(stateSub);\n" +
      "  }\n" +
      "\n" +
      "  sendMessage() {\n" +
      "    this.communicationService.sendMessage(this.message);\n" +
      "  }\n" +
      "\n" +
      "  updateState() {\n" +
      "    const newState = {\n" +
      "      count: this.receivedState.count + 1,\n" +
      "      data: `Updated by Sibling1 at ${new Date().toLocaleTimeString()}`\n" +
      "    };\n" +
      "    this.communicationService.updateState(newState);\n" +
      "  }\n" +
      "\n" +
      "  ngOnDestroy() {\n" +
      "    this.subscription.unsubscribe();\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "// sibling2.component.ts\n" +
      "import { Component, OnInit, OnDestroy } from '@angular/core';\n" +
      "import { CommunicationService } from './communication.service';\n" +
      "import { Subscription } from 'rxjs';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-sibling2',\n" +
      "  template: `\n" +
      '    <div class="sibling2">\n' +
      "      <h4>Sibling 2</h4>\n" +
      "      <p>Received Messages:</p>\n" +
      "      <ul>\n" +
      '        <li *ngFor="let msg of messages">{{ msg }}</li>\n' +
      "      </ul>\n" +
      "      <p>Current State: {{ currentState | json }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class Sibling2Component implements OnInit, OnDestroy {\n" +
      "  messages: string[] = [];\n" +
      "  currentState: any = {};\n" +
      "  private subscription: Subscription = new Subscription();\n" +
      "\n" +
      "  constructor(private communicationService: CommunicationService) {}\n" +
      "\n" +
      "  ngOnInit() {\n" +
      "    // Listen to messages\n" +
      "    const messageSub = this.communicationService.message$.subscribe(message => {\n" +
      "      this.messages.push(message);\n" +
      "    });\n" +
      "    this.subscription.add(messageSub);\n" +
      "\n" +
      "    // Listen to state changes\n" +
      "    const stateSub = this.communicationService.state$.subscribe(state => {\n" +
      "      this.currentState = state;\n" +
      "    });\n" +
      "    this.subscription.add(stateSub);\n" +
      "  }\n" +
      "\n" +
      "  ngOnDestroy() {\n" +
      "    this.subscription.unsubscribe();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**4. ViewChild Communication:**\n" +
      "```typescript\n" +
      "// child-viewchild.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-child-viewchild',\n" +
      "  template: `\n" +
      '    <div class="child-viewchild">\n' +
      "      <h4>Child Component (ViewChild)</h4>\n" +
      "      <p>Child Data: {{ childData }}</p>\n" +
      '      <button (click)="updateData()">Update Child Data</button>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ChildViewchildComponent {\n" +
      "  childData = 'Initial Child Data';\n" +
      "\n" +
      "  updateData() {\n" +
      "    this.childData = `Updated at ${new Date().toLocaleTimeString()}`;\n" +
      "  }\n" +
      "\n" +
      "  getData() {\n" +
      "    return this.childData;\n" +
      "  }\n" +
      "\n" +
      "  setData(newData: string) {\n" +
      "    this.childData = newData;\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "// parent-viewchild.component.ts\n" +
      "import { Component, ViewChild, AfterViewInit } from '@angular/core';\n" +
      "import { ChildViewchildComponent } from './child-viewchild.component';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-parent-viewchild',\n" +
      "  template: `\n" +
      '    <div class="parent-viewchild">\n' +
      "      <h3>Parent Component (ViewChild)</h3>\n" +
      '      <button (click)="accessChild()">Access Child Component</button>\n' +
      '      <button (click)="updateChild()">Update Child Data</button>\n' +
      "      <p>Parent Message: {{ parentMessage }}</p>\n" +
      "      \n" +
      "      <app-child-viewchild #childRef></app-child-viewchild>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ParentViewchildComponent implements AfterViewInit {\n" +
      "  @ViewChild(ChildViewchildComponent) childComponent!: ChildViewchildComponent;\n" +
      "  @ViewChild('childRef') childRef!: ChildViewchildComponent;\n" +
      "  \n" +
      "  parentMessage = '';\n" +
      "\n" +
      "  ngAfterViewInit() {\n" +
      "    console.log('Child component available:', this.childComponent);\n" +
      "  }\n" +
      "\n" +
      "  accessChild() {\n" +
      "    if (this.childComponent) {\n" +
      "      const childData = this.childComponent.getData();\n" +
      "      this.parentMessage = `Child data: ${childData}`;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  updateChild() {\n" +
      "    if (this.childComponent) {\n" +
      "      this.childComponent.setData(`Updated by parent at ${new Date().toLocaleTimeString()}`);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**5. Content Projection Communication:**\n" +
      "```typescript\n" +
      "// content-projection.component.ts\n" +
      "import { Component, ContentChild, ContentChildren, QueryList } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-content-projection',\n" +
      "  template: `\n" +
      '    <div class="content-projection">\n' +
      "      <h3>Content Projection Component</h3>\n" +
      '      <div class="projected-content">\n' +
      "        <ng-content></ng-content>\n" +
      "      </div>\n" +
      '      <div class="named-projection">\n' +
      '        <ng-content select="[slot=header]"></ng-content>\n' +
      '        <ng-content select="[slot=body]"></ng-content>\n' +
      '        <ng-content select="[slot=footer]"></ng-content>\n' +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ContentProjectionComponent {\n" +
      "  @ContentChild('projectedChild') projectedChild: any;\n" +
      "  @ContentChildren('projectedChildren') projectedChildren!: QueryList<any>;\n" +
      "}\n" +
      "```\n\n" +
      "**Summary of Communication Methods:**\n\n" +
      "| Method | Use Case | Direction | Best For |\n" +
      "|--------|----------|-----------|----------|\n" +
      "| @Input | Parent → Child | One-way | Passing data down |\n" +
      "| @Output | Child → Parent | One-way | Events up |\n" +
      "| Service + Subject | Any → Any | Bidirectional | Sibling communication |\n" +
      "| ViewChild | Parent → Child | Direct access | Direct component access |\n" +
      "| ContentChild | Parent → Projected | Direct access | Content projection |\n" +
      "| Template Reference | Template → Component | Direct access | Template access |\n" +
      "| State Management | Global | Any direction | Complex state |\n\n" +
      "**Best Practices:**\n" +
      "- Use @Input/@Output for simple parent-child communication\n" +
      "- Use services for sibling or distant component communication\n" +
      "- Use ViewChild sparingly - prefer @Input/@Output\n" +
      "- Always unsubscribe from observables\n" +
      "- Use TypeScript interfaces for type safety\n" +
      "- Consider using state management for complex applications",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "communication", "@Input", "@Output", "ViewChild", "services"],
  },
  {
    id: 186,
    question: "What is Content Projection? What is <ng-content>?",
    answer:
      "Content Projection is an Angular feature that allows you to insert external content into a component's template. The `<ng-content>` directive is the mechanism that enables this functionality, making components more flexible and reusable.\n\n" +
      "**Basic Content Projection:**\n" +
      "```typescript\n" +
      "// card.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-card',\n" +
      "  template: `\n" +
      '    <div class="card">\n' +
      '      <div class="card-header">\n' +
      "        <h3>Card Title</h3>\n" +
      "      </div>\n" +
      '      <div class="card-body">\n' +
      "        <!-- Project content here -->\n" +
      "        <ng-content></ng-content>\n" +
      "      </div>\n" +
      '      <div class="card-footer">\n' +
      "        <p>Card Footer</p>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .card {\n" +
      "      border: 1px solid #ddd;\n" +
      "      border-radius: 8px;\n" +
      "      padding: 16px;\n" +
      "      margin: 16px;\n" +
      "      box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n" +
      "    }\n" +
      "    .card-header {\n" +
      "      border-bottom: 1px solid #eee;\n" +
      "      margin-bottom: 16px;\n" +
      "    }\n" +
      "    .card-body {\n" +
      "      min-height: 100px;\n" +
      "    }\n" +
      "    .card-footer {\n" +
      "      border-top: 1px solid #eee;\n" +
      "      margin-top: 16px;\n" +
      "      font-style: italic;\n" +
      "    }\n" +
      "  `]\n" +
      "})\n" +
      "export class CardComponent {}\n" +
      "\n" +
      "// app.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-root',\n" +
      "  template: `\n" +
      '    <div class="app">\n' +
      "      <h1>Content Projection Demo</h1>\n" +
      "      \n" +
      "      <!-- Basic projection -->\n" +
      "      <app-card>\n" +
      "        <p>This content is projected into the card!</p>\n" +
      "        <button>Click me</button>\n" +
      "        <ul>\n" +
      "          <li>Item 1</li>\n" +
      "          <li>Item 2</li>\n" +
      "          <li>Item 3</li>\n" +
      "        </ul>\n" +
      "      </app-card>\n" +
      "      \n" +
      "      <!-- Another card with different content -->\n" +
      "      <app-card>\n" +
      "        <h4>Different Content</h4>\n" +
      "        <p>This card has completely different projected content.</p>\n" +
      '        <img src="https://via.placeholder.com/150" alt="Placeholder">\n' +
      "      </app-card>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class AppComponent {}\n" +
      "```\n\n" +
      "**Named Content Projection (Multi-slot):**\n" +
      "```typescript\n" +
      "// multi-slot-card.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-multi-slot-card',\n" +
      "  template: `\n" +
      '    <div class="multi-slot-card">\n' +
      "      <!-- Header slot -->\n" +
      '      <div class="card-header">\n' +
      '        <ng-content select="[slot=header]"></ng-content>\n' +
      "        <!-- Fallback if no header provided -->\n" +
      '        <ng-content select=".default-header"></ng-content>\n' +
      "      </div>\n" +
      "      \n" +
      "      <!-- Body slot -->\n" +
      '      <div class="card-body">\n' +
      '        <ng-content select="[slot=body]"></ng-content>\n' +
      "        <!-- Default body content -->\n" +
      "        <ng-content></ng-content>\n" +
      "      </div>\n" +
      "      \n" +
      "      <!-- Footer slot -->\n" +
      '      <div class="card-footer">\n' +
      '        <ng-content select="[slot=footer]"></ng-content>\n' +
      "      </div>\n" +
      "      \n" +
      "      <!-- Actions slot -->\n" +
      '      <div class="card-actions">\n' +
      '        <ng-content select="[slot=actions]"></ng-content>\n' +
      "      </div>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .multi-slot-card {\n" +
      "      border: 1px solid #ddd;\n" +
      "      border-radius: 8px;\n" +
      "      margin: 16px;\n" +
      "      overflow: hidden;\n" +
      "    }\n" +
      "    .card-header {\n" +
      "      background-color: #f8f9fa;\n" +
      "      padding: 16px;\n" +
      "      border-bottom: 1px solid #eee;\n" +
      "    }\n" +
      "    .card-body {\n" +
      "      padding: 16px;\n" +
      "    }\n" +
      "    .card-footer {\n" +
      "      background-color: #f8f9fa;\n" +
      "      padding: 16px;\n" +
      "      border-top: 1px solid #eee;\n" +
      "      font-size: 14px;\n" +
      "    }\n" +
      "    .card-actions {\n" +
      "      padding: 16px;\n" +
      "      background-color: #f8f9fa;\n" +
      "      border-top: 1px solid #eee;\n" +
      "    }\n" +
      "  `]\n" +
      "})\n" +
      "export class MultiSlotCardComponent {}\n" +
      "\n" +
      "// Usage in parent component\n" +
      "@Component({\n" +
      "  selector: 'app-parent',\n" +
      "  template: `\n" +
      '    <div class="parent">\n' +
      "      <h2>Multi-Slot Content Projection</h2>\n" +
      "      \n" +
      "      <!-- Card with all slots filled -->\n" +
      "      <app-multi-slot-card>\n" +
      '        <div slot="header">\n' +
      "          <h3>Custom Header</h3>\n" +
      "          <p>This is a custom header content</p>\n" +
      "        </div>\n" +
      "        \n" +
      '        <div slot="body">\n' +
      "          <p>This is the main body content.</p>\n" +
      "          <p>It can contain any HTML elements.</p>\n" +
      "        </div>\n" +
      "        \n" +
      '        <div slot="footer">\n' +
      "          <small>Created on {{ currentDate | date }}</small>\n" +
      "        </div>\n" +
      "        \n" +
      '        <div slot="actions">\n' +
      '          <button class="btn btn-primary">Save</button>\n' +
      '          <button class="btn btn-secondary">Cancel</button>\n' +
      "        </div>\n" +
      "      </app-multi-slot-card>\n" +
      "      \n" +
      "      <!-- Card with only some slots -->\n" +
      "      <app-multi-slot-card>\n" +
      '        <div slot="header">\n' +
      "          <h3>Minimal Card</h3>\n" +
      "        </div>\n" +
      "        \n" +
      "        <p>This content goes to the default slot (body).</p>\n" +
      "        <p>No footer or actions provided.</p>\n" +
      "      </app-multi-slot-card>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ParentComponent {\n" +
      "  currentDate = new Date();\n" +
      "}\n" +
      "```\n\n" +
      "**Advanced Content Projection with ContentChild:**\n" +
      "```typescript\n" +
      "// advanced-projection.component.ts\n" +
      "import { Component, ContentChild, ContentChildren, QueryList, AfterContentInit } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-advanced-projection',\n" +
      "  template: `\n" +
      '    <div class="advanced-projection">\n' +
      '      <div class="projection-info">\n' +
      "        <h3>Advanced Content Projection</h3>\n" +
      "        <p>Projected Content Count: {{ projectedContentCount }}</p>\n" +
      "        <p>Has Header: {{ hasHeader }}</p>\n" +
      "        <p>Has Footer: {{ hasFooter }}</p>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="projected-content">\n' +
      "        <ng-content></ng-content>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="projection-summary">\n' +
      "        <h4>Projection Summary:</h4>\n" +
      "        <ul>\n" +
      '          <li *ngFor="let item of projectionSummary">{{ item }}</li>\n' +
      "        </ul>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class AdvancedProjectionComponent implements AfterContentInit {\n" +
      "  @ContentChild('header') headerElement: any;\n" +
      "  @ContentChildren('item') itemElements!: QueryList<any>;\n" +
      "  \n" +
      "  projectedContentCount = 0;\n" +
      "  hasHeader = false;\n" +
      "  hasFooter = false;\n" +
      "  projectionSummary: string[] = [];\n" +
      "\n" +
      "  ngAfterContentInit() {\n" +
      "    // Check if header exists\n" +
      "    this.hasHeader = !!this.headerElement;\n" +
      "    \n" +
      "    // Count projected items\n" +
      "    this.projectedContentCount = this.itemElements.length;\n" +
      "    \n" +
      "    // Build summary\n" +
      "    this.buildProjectionSummary();\n" +
      "    \n" +
      "    console.log('Content projection initialized:', {\n" +
      "      hasHeader: this.hasHeader,\n" +
      "      itemCount: this.projectedContentCount,\n" +
      "      headerElement: this.headerElement,\n" +
      "      itemElements: this.itemElements.toArray()\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  private buildProjectionSummary() {\n" +
      "    this.projectionSummary = [];\n" +
      "    \n" +
      "    if (this.hasHeader) {\n" +
      "      this.projectionSummary.push('Header content detected');\n" +
      "    }\n" +
      "    \n" +
      "    if (this.projectedContentCount > 0) {\n" +
      "      this.projectionSummary.push(`${this.projectedContentCount} items projected`);\n" +
      "    }\n" +
      "    \n" +
      "    if (this.projectionSummary.length === 0) {\n" +
      "      this.projectionSummary.push('No specific content detected');\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "// Usage\n" +
      "@Component({\n" +
      "  selector: 'app-usage',\n" +
      "  template: `\n" +
      "    <app-advanced-projection>\n" +
      '      <div #header class="custom-header">\n' +
      "        <h2>Custom Header</h2>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div #item class="custom-item">\n' +
      "        <p>Item 1</p>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div #item class="custom-item">\n' +
      "        <p>Item 2</p>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div #item class="custom-item">\n' +
      "        <p>Item 3</p>\n" +
      "      </div>\n" +
      "      \n" +
      "      <p>This is regular projected content</p>\n" +
      "    </app-advanced-projection>\n" +
      "  `\n" +
      "})\n" +
      "export class UsageComponent {}\n" +
      "```\n\n" +
      "**Content Projection Best Practices:**\n" +
      "```typescript\n" +
      "// best-practices.component.ts\n" +
      "import { Component, Input } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-best-practices',\n" +
      "  template: `\n" +
      '    <div class="best-practices" [class]="theme">\n' +
      "      <!-- Conditional projection -->\n" +
      '      <div class="header" *ngIf="showHeader">\n' +
      '        <ng-content select="[slot=header]"></ng-content>\n' +
      "      </div>\n" +
      "      \n" +
      "      <!-- Main content with fallback -->\n" +
      '      <div class="content">\n' +
      '        <ng-content select="[slot=content]"></ng-content>\n' +
      "        <!-- Fallback content -->\n" +
      "        <ng-content></ng-content>\n" +
      "      </div>\n" +
      "      \n" +
      "      <!-- Footer with default -->\n" +
      '      <div class="footer">\n' +
      '        <ng-content select="[slot=footer]"></ng-content>\n' +
      '        <div class="default-footer" *ngIf="!hasFooter">\n' +
      "          <p>Default footer content</p>\n      " +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class BestPracticesComponent {\n" +
      "  @Input() theme: 'light' | 'dark' = 'light';\n" +
      "  @Input() showHeader = true;\n" +
      "  \n" +
      "  // This would be set by ContentChild in real implementation\n" +
      "  hasFooter = false;\n" +
      "}\n" +
      "```\n\n" +
      "**Key Points about Content Projection:**\n" +
      "- `<ng-content>` projects external content into component templates\n" +
      "- Use `select` attribute for named projection slots\n" +
      "- Content is projected at runtime, not compile time\n" +
      "- Projected content maintains its original context\n" +
      "- Use ContentChild/ContentChildren to access projected elements\n" +
      "- Fallback content can be provided for empty slots\n" +
      "- CSS classes and styles are preserved in projected content\n" +
      "- Event bindings work normally in projected content\n" +
      "- Perfect for creating reusable, flexible components\n" +
      "- Use with structural directives for dynamic content",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "content-projection", "ng-content", "slots", "projection"],
  },
  {
    id: 187,
    question: "What is Template Reference Variable in Angular?",
    answer:
      "Template Reference Variables (also called template variables) are a way to reference DOM elements or Angular components directly in templates. They use the `#` syntax and provide access to elements for manipulation, data binding, or method calls.\n\n" +
      "**Basic Template Reference Variables:**\n" +
      "```typescript\n" +
      "// template-ref.component.ts\n" +
      "import { Component, ViewChild, ElementRef, AfterViewInit } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-template-ref',\n" +
      "  template: `\n" +
      '    <div class="template-ref-demo">\n' +
      "      <h3>Template Reference Variables Demo</h3>\n" +
      "      \n" +
      "      <!-- Basic DOM element reference -->\n" +
      '      <input #inputRef type="text" placeholder="Enter text">\n' +
      '      <button (click)="focusInput()">Focus Input</button>\n' +
      '      <button (click)="getInputValue()">Get Input Value</button>\n' +
      "      <p>Input Value: {{ inputValue }}</p>\n" +
      "      \n" +
      "      <!-- Div element reference -->\n" +
      '      <div #divRef class="demo-div">\n' +
      "        <p>This is a div with template reference</p>\n" +
      "      </div>\n" +
      '      <button (click)="changeDivContent()">Change Div Content</button>\n' +
      '      <button (click)="changeDivStyle()">Change Div Style</button>\n' +
      "      \n" +
      "      <!-- Component reference -->\n" +
      "      <app-child-component #childRef></app-child-component>\n" +
      '      <button (click)="callChildMethod()">Call Child Method</button>\n' +
      '      <button (click)="accessChildProperty()">Access Child Property</button>\n' +
      "      <p>Child Data: {{ childData }}</p>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .template-ref-demo {\n" +
      "      padding: 20px;\n" +
      "      border: 1px solid #ddd;\n" +
      "      margin: 10px;\n" +
      "    }\n" +
      "    .demo-div {\n" +
      "      padding: 10px;\n" +
      "      margin: 10px 0;\n" +
      "      border: 1px solid #ccc;\n" +
      "      background-color: #f9f9f9;\n" +
      "    }\n" +
      "    .highlighted {\n" +
      "      background-color: yellow !important;\n" +
      "      font-weight: bold;\n" +
      "    }\n" +
      "  `]\n" +
      "})\n" +
      "export class TemplateRefComponent implements AfterViewInit {\n" +
      "  @ViewChild('inputRef') inputElement!: ElementRef;\n" +
      "  @ViewChild('divRef') divElement!: ElementRef;\n" +
      "  @ViewChild('childRef') childComponent!: any;\n" +
      "  \n" +
      "  inputValue = '';\n" +
      "  childData = '';\n" +
      "\n" +
      "  ngAfterViewInit() {\n" +
      "    console.log('Template references available:', {\n" +
      "      inputElement: this.inputElement,\n" +
      "      divElement: this.divElement,\n" +
      "      childComponent: this.childComponent\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  focusInput() {\n" +
      "    if (this.inputElement) {\n" +
      "      this.inputElement.nativeElement.focus();\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  getInputValue() {\n" +
      "    if (this.inputElement) {\n" +
      "      this.inputValue = this.inputElement.nativeElement.value;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  changeDivContent() {\n" +
      "    if (this.divElement) {\n" +
      "      this.divElement.nativeElement.innerHTML = \n" +
      "        '<p>Content changed at ' + new Date().toLocaleTimeString() + '</p>';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  changeDivStyle() {\n" +
      "    if (this.divElement) {\n" +
      "      this.divElement.nativeElement.classList.toggle('highlighted');\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  callChildMethod() {\n" +
      "    if (this.childComponent) {\n" +
      "      this.childComponent.updateData();\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  accessChildProperty() {\n" +
      "    if (this.childComponent) {\n" +
      "      this.childData = this.childComponent.getData();\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "// child-component.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-child-component',\n" +
      "  template: `\n" +
      '    <div class="child-component">\n' +
      "      <h4>Child Component</h4>\n" +
      "      <p>Child Data: {{ childData }}</p>\n" +
      '      <button (click)="updateData()">Update Data</button>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ChildComponentComponent {\n" +
      "  childData = 'Initial Child Data';\n" +
      "\n" +
      "  updateData() {\n" +
      "    this.childData = `Updated at ${new Date().toLocaleTimeString()}`;\n" +
      "  }\n" +
      "\n" +
      "  getData() {\n" +
      "    return this.childData;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Advanced Template Reference Variables:**\n" +
      "```typescript\n" +
      "// advanced-template-ref.component.ts\n" +
      "import { Component, ViewChild, ViewChildren, QueryList, ElementRef, AfterViewInit } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-advanced-template-ref',\n" +
      "  template: `\n" +
      '    <div class="advanced-template-ref">\n' +
      "      <h3>Advanced Template Reference Variables</h3>\n" +
      "      \n" +
      "      <!-- Multiple input references -->\n" +
      '      <div class="input-group">\n' +
      '        <input #firstName type="text" placeholder="First Name">\n' +
      '        <input #lastName type="text" placeholder="Last Name">\n' +
      '        <input #email type="email" placeholder="Email">\n' +
      '        <button (click)="validateForm()">Validate Form</button>\n' +
      '        <button (click)="clearForm()">Clear Form</button>\n' +
      "      </div>\n" +
      "      \n" +
      "      <!-- Dynamic list with references -->\n" +
      '      <div class="list-group">\n' +
      "        <h4>Dynamic List</h4>\n" +
      '        <div *ngFor="let item of items; let i = index" #itemRef>\n' +
      "          <span>{{ item.name }}</span>\n" +
      '          <button (click)="removeItem(i)">Remove</button>\n' +
      '          <button (click)="highlightItem(itemRef)">Highlight</button>\n' +
      "        </div>\n" +
      "      </div>\n" +
      "      \n" +
      "      <!-- Form with template references -->\n" +
      '      <form #formRef (ngSubmit)="onSubmit(formRef)">\n' +
      '        <div class="form-group">\n' +
      "          <label>Username:</label>\n" +
      '          <input #usernameRef type="text" required>\n' +
      "        </div>\n" +
      '        <div class="form-group">\n' +
      "          <label>Password:</label>\n" +
      '          <input #passwordRef type="password" required>\n' +
      "        </div>\n" +
      '        <button type="submit">Submit</button>\n' +
      '        <button type="button" (click)="resetForm(formRef)">Reset</button>\n' +
      "      </form>\n" +
      "      \n" +
      "      <!-- Status display -->\n" +
      '      <div class="status">\n' +
      "        <p>Form Valid: {{ formValid }}</p>\n" +
      "        <p>Last Action: {{ lastAction }}</p>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .advanced-template-ref {\n" +
      "      padding: 20px;\n" +
      "      border: 1px solid #ddd;\n" +
      "      margin: 10px;\n" +
      "    }\n" +
      "    .input-group {\n" +
      "      margin: 10px 0;\n" +
      "    }\n" +
      "    .input-group input {\n" +
      "      margin: 5px;\n" +
      "      padding: 5px;\n" +
      "    }\n" +
      "    .list-group {\n" +
      "      margin: 10px 0;\n" +
      "    }\n" +
      "    .form-group {\n" +
      "      margin: 10px 0;\n" +
      "    }\n" +
      "    .form-group input {\n" +
      "      margin-left: 10px;\n" +
      "      padding: 5px;\n" +
      "    }\n" +
      "    .highlighted {\n" +
      "      background-color: yellow;\n" +
      "      font-weight: bold;\n" +
      "    }\n" +
      "    .status {\n" +
      "      margin-top: 20px;\n" +
      "      padding: 10px;\n" +
      "      background-color: #f0f0f0;\n" +
      "    }\n" +
      "  `]\n" +
      "})\n" +
      "export class AdvancedTemplateRefComponent implements AfterViewInit {\n" +
      "  @ViewChild('firstName') firstNameInput!: ElementRef;\n" +
      "  @ViewChild('lastName') lastNameInput!: ElementRef;\n" +
      "  @ViewChild('email') emailInput!: ElementRef;\n" +
      "  @ViewChild('formRef') formElement!: ElementRef;\n" +
      "  @ViewChildren('itemRef') itemElements!: QueryList<ElementRef>;\n" +
      "  \n" +
      "  items = [\n" +
      "    { name: 'Item 1' },\n" +
      "    { name: 'Item 2' },\n" +
      "    { name: 'Item 3' }\n" +
      "  ];\n" +
      "  \n" +
      "  formValid = false;\n" +
      "  lastAction = '';\n" +
      "\n" +
      "  ngAfterViewInit() {\n" +
      "    console.log('Advanced template references available:', {\n" +
      "      firstNameInput: this.firstNameInput,\n" +
      "      lastNameInput: this.lastNameInput,\n" +
      "      emailInput: this.emailInput,\n" +
      "      formElement: this.formElement,\n" +
      "      itemElements: this.itemElements.toArray()\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  validateForm() {\n" +
      "    const firstName = this.firstNameInput.nativeElement.value;\n" +
      "    const lastName = this.lastNameInput.nativeElement.value;\n" +
      "    const email = this.emailInput.nativeElement.value;\n" +
      "    \n" +
      "    this.formValid = firstName && lastName && email;\n" +
      "    this.lastAction = `Form validation: ${this.formValid ? 'Valid' : 'Invalid'}`;\n" +
      "    \n" +
      "    // Highlight invalid fields\n" +
      "    [this.firstNameInput, this.lastNameInput, this.emailInput].forEach(input => {\n" +
      "      if (!input.nativeElement.value) {\n" +
      "        input.nativeElement.style.borderColor = 'red';\n" +
      "      } else {\n" +
      "        input.nativeElement.style.borderColor = 'green';\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  clearForm() {\n" +
      "    [this.firstNameInput, this.lastNameInput, this.emailInput].forEach(input => {\n" +
      "      input.nativeElement.value = '';\n" +
      "      input.nativeElement.style.borderColor = '';\n" +
      "    });\n" +
      "    this.formValid = false;\n" +
      "    this.lastAction = 'Form cleared';\n" +
      "  }\n" +
      "\n" +
      "  removeItem(index: number) {\n" +
      "    this.items.splice(index, 1);\n" +
      "    this.lastAction = `Item ${index + 1} removed`;\n" +
      "  }\n" +
      "\n" +
      "  highlightItem(itemRef: ElementRef) {\n" +
      "    itemRef.nativeElement.classList.toggle('highlighted');\n" +
      "    this.lastAction = 'Item highlighted';\n" +
      "  }\n" +
      "\n" +
      "  onSubmit(formRef: ElementRef) {\n" +
      "    const form = formRef.nativeElement;\n" +
      "    const formData = new FormData(form);\n" +
      "    \n" +
      "    console.log('Form submitted:', formData);\n" +
      "    this.lastAction = 'Form submitted';\n" +
      "  }\n" +
      "\n" +
      "  resetForm(formRef: ElementRef) {\n" +
      "    formRef.nativeElement.reset();\n" +
      "    this.lastAction = 'Form reset';\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template Reference Variables with Directives:**\n" +
      "```typescript\n" +
      "// directive-template-ref.component.ts\n" +
      "import { Component, ViewChild, ElementRef } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-directive-template-ref',\n" +
      "  template: `\n" +
      '    <div class="directive-template-ref">\n' +
      "      <h3>Template References with Directives</h3>\n" +
      "      \n" +
      "      <!-- ngIf with template reference -->\n" +
      '      <div *ngIf="showContent" #conditionalDiv>\n' +
      "        <p>This content is conditionally shown</p>\n" +
      "      </div>\n" +
      '      <button (click)="toggleContent()">Toggle Content</button>\n' +
      '      <button (click)="accessConditionalDiv()">Access Conditional Div</button>\n' +
      "      \n" +
      "      <!-- ngFor with template reference -->\n" +
      '      <div *ngFor="let user of users; let i = index" #userDiv>\n' +
      "        <span>{{ user.name }} - {{ user.email }}</span>\n" +
      '        <button (click)="selectUser(userDiv, user)">Select</button>\n' +
      "      </div>\n" +
      "      \n" +
      "      <!-- Selected user display -->\n" +
      '      <div *ngIf="selectedUser">\n' +
      "        <h4>Selected User:</h4>\n" +
      "        <p>Name: {{ selectedUser.name }}</p>\n" +
      "        <p>Email: {{ selectedUser.email }}</p>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class DirectiveTemplateRefComponent {\n" +
      "  @ViewChild('conditionalDiv') conditionalDiv!: ElementRef;\n" +
      "  \n" +
      "  showContent = true;\n" +
      "  selectedUser: any = null;\n" +
      "  \n" +
      "  users = [\n" +
      "    { name: 'John Doe', email: 'john@example.com' },\n" +
      "    { name: 'Jane Smith', email: 'jane@example.com' },\n" +
      "    { name: 'Bob Johnson', email: 'bob@example.com' }\n" +
      "  ];\n" +
      "\n" +
      "  toggleContent() {\n" +
      "    this.showContent = !this.showContent;\n" +
      "  }\n" +
      "\n" +
      "  accessConditionalDiv() {\n" +
      "    if (this.conditionalDiv) {\n" +
      "      console.log('Conditional div accessed:', this.conditionalDiv.nativeElement);\n" +
      "      this.conditionalDiv.nativeElement.style.backgroundColor = 'lightblue';\n" +
      "    } else {\n" +
      "      console.log('Conditional div not available');\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  selectUser(userDiv: ElementRef, user: any) {\n      " +
      "    // Remove previous selection\n" +
      "    document.querySelectorAll('.selected').forEach(el => {\n" +
      "      el.classList.remove('selected');\n" +
      "    });\n" +
      "    \n" +
      "    // Add selection to current user\n" +
      "    userDiv.nativeElement.classList.add('selected');\n" +
      "    this.selectedUser = user;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Points about Template Reference Variables:**\n" +
      "- Use `#variableName` syntax to create template references\n" +
      "- Can reference DOM elements, components, or directives\n" +
      "- Available in component class via ViewChild/ViewChildren\n" +
      "- Work with both static and dynamic content\n" +
      "- Provide direct access to element properties and methods\n" +
      "- Useful for form validation and DOM manipulation\n" +
      "- Can be used in event handlers and method calls\n" +
      "- Support both single and multiple element references\n" +
      "- Work with structural directives (ngIf, ngFor)\n" +
      "- Provide type safety when used with ViewChild decorators",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "template-reference", "ViewChild", "ElementRef", "DOM"],
  },
  {
    id: 188,
    question: "What is the role of ViewChild in Angular?",
    answer:
      "ViewChild is a decorator in Angular that allows you to access child components, directives, or DOM elements from a parent component. It provides a way to get references to elements in the component's view and interact with them programmatically.\n\n" +
      "**Basic ViewChild Usage:**\n" +
      "```typescript\n" +
      "// viewchild-demo.component.ts\n" +
      "import { Component, ViewChild, AfterViewInit, ElementRef } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-viewchild-demo',\n" +
      "  template: `\n" +
      '    <div class="viewchild-demo">\n' +
      "      <h3>ViewChild Demo</h3>\n" +
      "      \n" +
      "      <!-- DOM Element Reference -->\n" +
      '      <input #inputRef type="text" placeholder="Enter text">\n' +
      '      <button (click)="focusInput()">Focus Input</button>\n' +
      '      <button (click)="getInputValue()">Get Value</button>\n' +
      "      <p>Input Value: {{ inputValue }}</p>\n" +
      "      \n" +
      "      <!-- Child Component Reference -->\n" +
      "      <app-child-viewchild #childRef></app-child-viewchild>\n" +
      '      <button (click)="callChildMethod()">Call Child Method</button>\n' +
      '      <button (click)="updateChildData()">Update Child Data</button>\n' +
      "      <p>Child Status: {{ childStatus }}</p>\n" +
      "      \n" +
      "      <!-- Div Element Reference -->\n" +
      '      <div #divRef class="demo-div">\n' +
      "        <p>This div can be manipulated via ViewChild</p>\n" +
      "      </div>\n" +
      '      <button (click)="changeDivContent()">Change Content</button>\n' +
      '      <button (click)="changeDivStyle()">Change Style</button>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ViewchildDemoComponent implements AfterViewInit {\n" +
      "  // ViewChild for DOM element\n" +
      "  @ViewChild('inputRef') inputElement!: ElementRef;\n" +
      "  \n" +
      "  // ViewChild for child component\n" +
      "  @ViewChild('childRef') childComponent!: any;\n" +
      "  \n" +
      "  // ViewChild for div element\n" +
      "  @ViewChild('divRef') divElement!: ElementRef;\n" +
      "  \n" +
      "  inputValue = '';\n" +
      "  childStatus = '';\n" +
      "\n" +
      "  ngAfterViewInit() {\n" +
      "    console.log('ViewChild elements available:', {\n" +
      "      inputElement: this.inputElement,\n" +
      "      childComponent: this.childComponent,\n" +
      "      divElement: this.divElement\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  focusInput() {\n" +
      "    if (this.inputElement) {\n" +
      "      this.inputElement.nativeElement.focus();\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  getInputValue() {\n" +
      "    if (this.inputElement) {\n" +
      "      this.inputValue = this.inputElement.nativeElement.value;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  callChildMethod() {\n" +
      "    if (this.childComponent) {\n" +
      "      this.childComponent.updateData();\n" +
      "      this.childStatus = 'Child method called';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  updateChildData() {\n" +
      "    if (this.childComponent) {\n" +
      "      this.childComponent.setData('Updated from parent');\n" +
      "      this.childStatus = 'Child data updated';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  changeDivContent() {\n" +
      "    if (this.divElement) {\n" +
      "      this.divElement.nativeElement.innerHTML = \n" +
      "        '<p>Content changed at ' + new Date().toLocaleTimeString() + '</p>';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  changeDivStyle() {\n" +
      "    if (this.divElement) {\n" +
      "      this.divElement.nativeElement.style.backgroundColor = 'lightblue';\n" +
      "      this.divElement.nativeElement.style.padding = '20px';\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**ViewChild with Different Selectors:**\n" +
      "```typescript\n" +
      "// viewchild-selectors.component.ts\n" +
      "import { Component, ViewChild, AfterViewInit, ElementRef } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-viewchild-selectors',\n" +
      "  template: `\n" +
      '    <div class="viewchild-selectors">\n' +
      "      <h3>ViewChild with Different Selectors</h3>\n" +
      "      \n" +
      "      <!-- Template Reference Variable -->\n" +
      '      <input #templateRef type="text" placeholder="Template Ref">\n' +
      "      \n" +
      "      <!-- Component Selector -->\n" +
      "      <app-child-viewchild></app-child-viewchild>\n" +
      "      \n" +
      "      <!-- CSS Class Selector -->\n" +
      '      <div class="css-selector">CSS Class Selector</div>\n' +
      "      \n" +
      "      <!-- Attribute Selector -->\n" +
      '      <div data-test="attribute-selector">Attribute Selector</div>\n' +
      "      \n" +
      "      <!-- Directive Selector -->\n      " +
      "      <div appCustomDirective>Directive Selector</div>\n" +
      "      \n" +
      '      <button (click)="accessAllElements()">Access All Elements</button>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ViewchildSelectorsComponent implements AfterViewInit {\n" +
      "  // Template reference variable\n      " +
      "  @ViewChild('templateRef') templateRef!: ElementRef;\n" +
      "  \n" +
      "  // Component selector\n      " +
      "  @ViewChild(ChildViewchildComponent) childComponent!: ChildViewchildComponent;\n" +
      "  \n" +
      "  // CSS class selector\n      " +
      "  @ViewChild('.css-selector') cssSelector!: ElementRef;\n" +
      "  \n" +
      "  // Attribute selector\n      " +
      "  @ViewChild('[data-test=\"attribute-selector\"]') attributeSelector!: ElementRef;\n" +
      "  \n" +
      "  // Directive selector\n      " +
      "  @ViewChild(CustomDirective) customDirective!: CustomDirective;\n" +
      "\n" +
      "  ngAfterViewInit() {\n" +
      "    console.log('All ViewChild elements:', {\n" +
      "      templateRef: this.templateRef,\n" +
      "      childComponent: this.childComponent,\n" +
      "      cssSelector: this.cssSelector,\n" +
      "      attributeSelector: this.attributeSelector,\n" +
      "      customDirective: this.customDirective\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  accessAllElements() {\n" +
      "    // Access template reference\n      " +
      "    if (this.templateRef) {\n" +
      "      this.templateRef.nativeElement.value = 'Updated via ViewChild';\n" +
      "    }\n" +
      "    \n" +
      "    // Access child component\n      " +
      "    if (this.childComponent) {\n" +
      "      this.childComponent.updateData();\n" +
      "    }\n" +
      "    \n" +
      "    // Access CSS selector element\n      " +
      "    if (this.cssSelector) {\n" +
      "      this.cssSelector.nativeElement.style.backgroundColor = 'yellow';\n" +
      "    }\n" +
      "    \n" +
      "    // Access attribute selector element\n      " +
      "    if (this.attributeSelector) {\n" +
      "      this.attributeSelector.nativeElement.style.border = '2px solid red';\n" +
      "    }\n" +
      "    \n" +
      "    // Access directive\n      " +
      "    if (this.customDirective) {\n" +
      "      this.customDirective.someMethod();\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**ViewChild with Static Option:**\n" +
      "```typescript\n" +
      "// viewchild-static.component.ts\n" +
      "import { Component, ViewChild, OnInit, ElementRef } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-viewchild-static',\n" +
      "  template: `\n" +
      '    <div class="viewchild-static">\n' +
      "      <h3>ViewChild with Static Option</h3>\n" +
      "      \n" +
      "      <!-- Static element (always present) -->\n      " +
      '      <div #staticElement class="static-element">\n      ' +
      "        <p>This element is always present</p>\n      " +
      "      </div>\n      " +
      "      \n" +
      "      <!-- Dynamic element (conditionally present) -->\n      " +
      '      <div *ngIf="showDynamic" #dynamicElement class="dynamic-element">\n      ' +
      "        <p>This element is conditionally present</p>\n      " +
      "      </div>\n      " +
      "      \n" +
      '      <button (click)="toggleDynamic()">Toggle Dynamic Element</button>\n      ' +
      '      <button (click)="accessElements()">Access Elements</button>\n      ' +
      "      \n" +
      "      <p>Static Element Available: {{ staticAvailable }}</p>\n      " +
      "      <p>Dynamic Element Available: {{ dynamicAvailable }}</p>\n      " +
      "    </div>\n      " +
      "  `\n      " +
      "})\n      " +
      "export class ViewchildStaticComponent implements OnInit {\n      " +
      "  // Static ViewChild - available immediately\n      " +
      "  @ViewChild('staticElement', { static: true }) staticElement!: ElementRef;\n      " +
      "  \n      " +
      "  // Dynamic ViewChild - available after view init\n      " +
      "  @ViewChild('dynamicElement', { static: false }) dynamicElement!: ElementRef;\n      " +
      "  \n      " +
      "  showDynamic = false;\n      " +
      "  staticAvailable = false;\n      " +
      "  dynamicAvailable = false;\n      " +
      "\n      " +
      "  ngOnInit() {\n      " +
      "    // Static ViewChild is available in ngOnInit\n      " +
      "    this.staticAvailable = !!this.staticElement;\n      " +
      "    console.log('Static element in ngOnInit:', this.staticElement);\n      " +
      "  }\n      " +
      "\n      " +
      "  ngAfterViewInit() {\n      " +
      "    // Both static and dynamic ViewChild are available in ngAfterViewInit\n      " +
      "    this.staticAvailable = !!this.staticElement;\n      " +
      "    this.dynamicAvailable = !!this.dynamicElement;\n      " +
      "    console.log('All elements in ngAfterViewInit:', {\n      " +
      "      staticElement: this.staticElement,\n      " +
      "      dynamicElement: this.dynamicElement\n      " +
      "    });\n      " +
      "  }\n      " +
      "\n      " +
      "  toggleDynamic() {\n      " +
      "    this.showDynamic = !this.showDynamic;\n      " +
      "  }\n      " +
      "\n      " +
      "  accessElements() {\n      " +
      "    if (this.staticElement) {\n      " +
      "      this.staticElement.nativeElement.style.backgroundColor = 'lightgreen';\n      " +
      "    }\n      " +
      "    \n      " +
      "    if (this.dynamicElement) {\n      " +
      "      this.dynamicElement.nativeElement.style.backgroundColor = 'lightcoral';\n      " +
      "    }\n      " +
      "  }\n      " +
      "}\n      " +
      "```\n\n" +
      "**Key Points about ViewChild:**\n" +
      "- Used to access child components, directives, or DOM elements\n" +
      "- Available in ngAfterViewInit lifecycle hook\n" +
      "- Can use template reference variables, component selectors, CSS selectors\n" +
      "- Static option makes it available in ngOnInit\n" +
      "- Returns ElementRef for DOM elements, component instance for components\n" +
      "- Useful for direct manipulation and method calls\n" +
      "- Should be used sparingly - prefer @Input/@Output for communication\n" +
      "- Provides type safety when properly typed\n" +
      "- Can access both static and dynamic elements\n" +
      "- Works with custom directives and components",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "ViewChild", "ElementRef", "lifecycle", "DOM"],
  },
  {
    id: 189,
    question: "How to access the child component from parent component with ViewChild?",
    answer:
      "ViewChild provides a way to access child components from parent components, allowing direct method calls, property access, and component manipulation. This is useful when you need to interact with child components programmatically.\n\n" +
      "**Basic Child Component Access:**\n" +
      "```typescript\n" +
      "// child.component.ts\n" +
      "import { Component, Input, Output, EventEmitter } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-child',\n" +
      "  template: `\n" +
      '    <div class="child-component">\n' +
      "      <h4>Child Component</h4>\n" +
      "      <p>Child Data: {{ childData }}</p>\n" +
      "      <p>Counter: {{ counter }}</p>\n" +
      "      <p>Status: {{ status }}</p>\n" +
      "      \n" +
      '      <div class="child-actions">\n' +
      '        <button (click)="incrementCounter()">Increment</button>\n' +
      '        <button (click)="decrementCounter()">Decrement</button>\n' +
      '        <button (click)="resetCounter()">Reset</button>\n' +
      '        <button (click)="updateStatus()">Update Status</button>\n' +
      "      </div>\n" +
      "      \n" +
      '      <div class="child-input">\n' +
      '        <input [(ngModel)]="inputValue" placeholder="Enter value">\n' +
      '        <button (click)="processInput()">Process Input</button>\n' +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ChildComponent {\n" +
      "  @Input() childData = 'Initial Child Data';\n" +
      "  @Output() dataChanged = new EventEmitter<string>();\n" +
      "  \n" +
      "  counter = 0;\n" +
      "  status = 'Ready';\n" +
      "  inputValue = '';\n" +
      "  \n      " +
      "  // Public methods that can be called from parent\n      " +
      "  incrementCounter() {\n      " +
      "    this.counter++;\n      " +
      "    this.status = `Incremented to ${this.counter}`;\n      " +
      "  }\n      " +
      "  \n      " +
      "  decrementCounter() {\n      " +
      "    this.counter--;\n      " +
      "    this.status = `Decremented to ${this.counter}`;\n      " +
      "  }\n      " +
      "  \n      " +
      "  resetCounter() {\n      " +
      "    this.counter = 0;\n      " +
      "    this.status = 'Reset';\n      " +
      "  }\n      " +
      "  \n      " +
      "  updateStatus() {\n      " +
      "    this.status = `Updated at ${new Date().toLocaleTimeString()}`;\n      " +
      "  }\n      " +
      "  \n      " +
      "  processInput() {\n      " +
      "    if (this.inputValue) {\n      " +
      "      this.childData = this.inputValue;\n      " +
      "      this.dataChanged.emit(this.inputValue);\n      " +
      "      this.status = `Processed: ${this.inputValue}`;\n      " +
      "    }\n      " +
      "  }\n      " +
      "  \n      " +
      "  // Public getter methods\n      " +
      "  getCounter() {\n      " +
      "    return this.counter;\n      " +
      "  }\n      " +
      "  \n      " +
      "  getStatus() {\n      " +
      "    return this.status;\n      " +
      "  }\n      " +
      "  \n      " +
      "  getData() {\n      " +
      "    return this.childData;\n      " +
      "  }\n      " +
      "  \n      " +
      "  // Public setter methods\n      " +
      "  setCounter(value: number) {\n      " +
      "    this.counter = value;\n      " +
      "    this.status = `Set to ${value}`;\n      " +
      "  }\n      " +
      "  \n      " +
      "  setData(data: string) {\n      " +
      "    this.childData = data;\n      " +
      "    this.status = 'Data updated';\n      " +
      "  }\n      " +
      "  \n      " +
      "  setStatus(status: string) {\n      " +
      "    this.status = status;\n      " +
      "  }\n      " +
      "}\n      " +
      "\n      " +
      "// parent.component.ts\n      " +
      "import { Component, ViewChild, AfterViewInit } from '@angular/core';\n      " +
      "import { ChildComponent } from './child.component';\n      " +
      "\n      " +
      "@Component({\n      " +
      "  selector: 'app-parent',\n      " +
      "  template: `\n      " +
      '    <div class="parent-component">\n      ' +
      "      <h3>Parent Component</h3>\n      " +
      "      \n      " +
      "      <!-- Child component with template reference -->\n      " +
      '      <app-child #childRef [childData]="parentData"></app-child>\n      ' +
      "      \n      " +
      '      <div class="parent-actions">\n      ' +
      "        <h4>Parent Actions (Accessing Child):</h4>\n      " +
      '        <button (click)="incrementChildCounter()">Increment Child Counter</button>\n      ' +
      '        <button (click)="decrementChildCounter()">Decrement Child Counter</button>\n      ' +
      '        <button (click)="resetChildCounter()">Reset Child Counter</button>\n      ' +
      '        <button (click)="updateChildStatus()">Update Child Status</button>\n      ' +
      '        <button (click)="setChildData()">Set Child Data</button>\n      ' +
      '        <button (click)="getChildInfo()">Get Child Info</button>\n      ' +
      "      </div>\n      " +
      "      \n      " +
      '      <div class="parent-info">\n      ' +
      "        <h4>Parent Info:</h4>\n      " +
      "        <p>Parent Data: {{ parentData }}</p>\n      " +
      "        <p>Child Counter: {{ childCounter }}</p>\n      " +
      "        <p>Child Status: {{ childStatus }}</p>\n      " +
      "        <p>Child Data: {{ childData }}</p>\n      " +
      "        <p>Last Action: {{ lastAction }}</p>\n      " +
      "      </div>\n      " +
      "    </div>\n      " +
      "  `\n      " +
      "})\n      " +
      "export class ParentComponent implements AfterViewInit {\n      " +
      "  // ViewChild to access child component\n      " +
      "  @ViewChild('childRef') childComponent!: ChildComponent;\n      " +
      "  \n      " +
      "  parentData = 'Parent Data';\n      " +
      "  childCounter = 0;\n      " +
      "  childStatus = '';\n      " +
      "  childData = '';\n      " +
      "  lastAction = '';\n      " +
      "\n      " +
      "  ngAfterViewInit() {\n      " +
      "    console.log('Child component available:', this.childComponent);\n      " +
      "    // Initial access to child component\n      " +
      "    this.getChildInfo();\n      " +
      "  }\n      " +
      "\n      " +
      "  incrementChildCounter() {\n      " +
      "    if (this.childComponent) {\n      " +
      "      this.childComponent.incrementCounter();\n      " +
      "      this.lastAction = 'Incremented child counter';\n      " +
      "      this.updateParentInfo();\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  decrementChildCounter() {\n      " +
      "    if (this.childComponent) {\n      " +
      "      this.childComponent.decrementCounter();\n      " +
      "      this.lastAction = 'Decremented child counter';\n      " +
      "      this.updateParentInfo();\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  resetChildCounter() {\n      " +
      "    if (this.childComponent) {\n      " +
      "      this.childComponent.resetCounter();\n      " +
      "      this.lastAction = 'Reset child counter';\n      " +
      "      this.updateParentInfo();\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  updateChildStatus() {\n      " +
      "    if (this.childComponent) {\n      " +
      "      this.childComponent.setStatus(`Updated by parent at ${new Date().toLocaleTimeString()}`);\n      " +
      "      this.lastAction = 'Updated child status';\n      " +
      "      this.updateParentInfo();\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  setChildData() {\n      " +
      "    if (this.childComponent) {\n      " +
      "      const newData = `Parent set data at ${new Date().toLocaleTimeString()}`;\n      " +
      "      this.childComponent.setData(newData);\n      " +
      "      this.lastAction = 'Set child data';\n      " +
      "      this.updateParentInfo();\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  getChildInfo() {\n      " +
      "    if (this.childComponent) {\n      " +
      "      this.childCounter = this.childComponent.getCounter();\n      " +
      "      this.childStatus = this.childComponent.getStatus();\n      " +
      "      this.childData = this.childComponent.getData();\n      " +
      "      this.lastAction = 'Retrieved child info';\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  private updateParentInfo() {\n      " +
      "    // Update parent's view of child state\n      " +
      "    this.getChildInfo();\n      " +
      "  }\n      " +
      "}\n      " +
      "```\n\n" +
      "**Advanced Child Component Access:**\n" +
      "```typescript\n      " +
      "// advanced-child.component.ts\n      " +
      "import { Component, Input, Output, EventEmitter, OnInit, OnDestroy } from '@angular/core';\n      " +
      "import { Subject, Subscription } from 'rxjs';\n      " +
      "\n      " +
      "@Component({\n      " +
      "  selector: 'app-advanced-child',\n      " +
      "  template: `\n      " +
      '    <div class="advanced-child">\n      ' +
      "      <h4>Advanced Child Component</h4>\n      " +
      "      <p>Data: {{ data }}</p>\n      " +
      "      <p>Count: {{ count }}</p>\n      " +
      "      <p>Is Active: {{ isActive }}</p>\n      " +
      "      <p>Last Update: {{ lastUpdate }}</p>\n      " +
      "      \n      " +
      '      <div class="child-controls">\n      ' +
      '        <button (click)="startProcess()">Start Process</button>\n      ' +
      '        <button (click)="stopProcess()">Stop Process</button>\n      ' +
      '        <button (click)="toggleActive()">Toggle Active</button>\n      ' +
      "      </div>\n      " +
      "    </div>\n      " +
      "  `\n      " +
      "})\n      " +
      "export class AdvancedChildComponent implements OnInit, OnDestroy {\n      " +
      "  @Input() data = 'Initial Data';\n      " +
      "  @Output() processStarted = new EventEmitter<void>();\n      " +
      "  @Output() processStopped = new EventEmitter<void>();\n      " +
      "  \n      " +
      "  count = 0;\n      " +
      "  isActive = false;\n      " +
      "  lastUpdate = '';\n      " +
      "  \n      " +
      "  private processSubject = new Subject<boolean>();\n      " +
      "  private subscription: Subscription = new Subscription();\n      " +
      "  \n      " +
      "  ngOnInit() {\n      " +
      "    // Subscribe to process changes\n      " +
      "    const processSub = this.processSubject.subscribe(isRunning => {\n      " +
      "      this.isActive = isRunning;\n      " +
      "      this.lastUpdate = new Date().toLocaleTimeString();\n      " +
      "    });\n      " +
      "    this.subscription.add(processSub);\n      " +
      "  }\n      " +
      "  \n      " +
      "  ngOnDestroy() {\n      " +
      "    this.subscription.unsubscribe();\n      " +
      "  }\n      " +
      "  \n      " +
      "  // Public methods for parent access\n      " +
      "  startProcess() {\n      " +
      "    this.processSubject.next(true);\n      " +
      "    this.processStarted.emit();\n      " +
      "  }\n      " +
      "  \n      " +
      "  stopProcess() {\n      " +
      "    this.processSubject.next(false);\n      " +
      "    this.processStopped.emit();\n      " +
      "  }\n      " +
      "  \n      " +
      "  toggleActive() {\n      " +
      "    this.isActive = !this.isActive;\n      " +
      "    this.lastUpdate = new Date().toLocaleTimeString();\n      " +
      "  }\n      " +
      "  \n      " +
      "  incrementCount() {\n      " +
      "    this.count++;\n      " +
      "    this.lastUpdate = new Date().toLocaleTimeString();\n      " +
      "  }\n      " +
      "  \n      " +
      "  setCount(value: number) {\n      " +
      "    this.count = value;\n      " +
      "    this.lastUpdate = new Date().toLocaleTimeString();\n      " +
      "  }\n      " +
      "  \n      " +
      "  setData(data: string) {\n      " +
      "    this.data = data;\n      " +
      "    this.lastUpdate = new Date().toLocaleTimeString();\n      " +
      "  }\n      " +
      "  \n      " +
      "  getState() {\n      " +
      "    return {\n      " +
      "      data: this.data,\n      " +
      "      count: this.count,\n      " +
      "      isActive: this.isActive,\n      " +
      "      lastUpdate: this.lastUpdate\n      " +
      "    };\n      " +
      "  }\n      " +
      "  \n      " +
      "  reset() {\n      " +
      "    this.data = 'Initial Data';\n      " +
      "    this.count = 0;\n      " +
      "    this.isActive = false;\n      " +
      "    this.lastUpdate = new Date().toLocaleTimeString();\n      " +
      "  }\n      " +
      "}\n      " +
      "\n      " +
      "// advanced-parent.component.ts\n      " +
      "import { Component, ViewChild, AfterViewInit } from '@angular/core';\n      " +
      "import { AdvancedChildComponent } from './advanced-child.component';\n      " +
      "\n      " +
      "@Component({\n      " +
      "  selector: 'app-advanced-parent',\n      " +
      "  template: `\n      " +
      '    <div class="advanced-parent">\n      ' +
      "      <h3>Advanced Parent Component</h3>\n      " +
      "      \n      " +
      "      <app-advanced-child #advancedChildRef></app-advanced-child>\n      " +
      "      \n      " +
      '      <div class="parent-controls">\n      ' +
      "        <h4>Parent Controls:</h4>\n      " +
      '        <button (click)="startChildProcess()">Start Child Process</button>\n      ' +
      '        <button (click)="stopChildProcess()">Stop Child Process</button>\n      ' +
      '        <button (click)="toggleChildActive()">Toggle Child Active</button>\n      ' +
      '        <button (click)="incrementChildCount()">Increment Child Count</button>\n      ' +
      '        <button (click)="setChildCount()">Set Child Count</button>\n      ' +
      '        <button (click)="setChildData()">Set Child Data</button>\n      ' +
      '        <button (click)="getChildState()">Get Child State</button>\n      ' +
      '        <button (click)="resetChild()">Reset Child</button>\n      ' +
      "      </div>\n      " +
      "      \n      " +
      '      <div class="parent-info">\n      ' +
      "        <h4>Parent Info:</h4>\n      " +
      "        <p>Child State: {{ childState | json }}</p>\n      " +
      "        <p>Last Action: {{ lastAction }}</p>\n      " +
      "      </div>\n      " +
      "    </div>\n      " +
      "  `\n      " +
      "})\n      " +
      "export class AdvancedParentComponent implements AfterViewInit {\n      " +
      "  @ViewChild('advancedChildRef') advancedChild!: AdvancedChildComponent;\n      " +
      "  \n      " +
      "  childState: any = {};\n      " +
      "  lastAction = '';\n      " +
      "\n      " +
      "  ngAfterViewInit() {\n      " +
      "    console.log('Advanced child component available:', this.advancedChild);\n      " +
      "    this.getChildState();\n      " +
      "  }\n      " +
      "\n      " +
      "  startChildProcess() {\n      " +
      "    if (this.advancedChild) {\n      " +
      "      this.advancedChild.startProcess();\n      " +
      "      this.lastAction = 'Started child process';\n      " +
      "      this.getChildState();\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  stopChildProcess() {\n      " +
      "    if (this.advancedChild) {\n      " +
      "      this.advancedChild.stopProcess();\n      " +
      "      this.lastAction = 'Stopped child process';\n      " +
      "      this.getChildState();\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  toggleChildActive() {\n      " +
      "    if (this.advancedChild) {\n      " +
      "      this.advancedChild.toggleActive();\n      " +
      "      this.lastAction = 'Toggled child active state';\n      " +
      "      this.getChildState();\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  incrementChildCount() {\n      " +
      "    if (this.advancedChild) {\n      " +
      "      this.advancedChild.incrementCount();\n      " +
      "      this.lastAction = 'Incremented child count';\n      " +
      "      this.getChildState();\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  setChildCount() {\n      " +
      "    if (this.advancedChild) {\n      " +
      "      const newCount = Math.floor(Math.random() * 100);\n      " +
      "      this.advancedChild.setCount(newCount);\n      " +
      "      this.lastAction = `Set child count to ${newCount}`;\n      " +
      "      this.getChildState();\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  setChildData() {\n      " +
      "    if (this.advancedChild) {\n      " +
      "      const newData = `Parent data at ${new Date().toLocaleTimeString()}`;\n      " +
      "      this.advancedChild.setData(newData);\n      " +
      "      this.lastAction = 'Set child data';\n      " +
      "      this.getChildState();\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  getChildState() {\n      " +
      "    if (this.advancedChild) {\n      " +
      "      this.childState = this.advancedChild.getState();\n      " +
      "      this.lastAction = 'Retrieved child state';\n      " +
      "    }\n      " +
      "  }\n      " +
      "\n      " +
      "  resetChild() {\n      " +
      "    if (this.advancedChild) {\n      " +
      "      this.advancedChild.reset();\n      " +
      "      this.lastAction = 'Reset child component';\n      " +
      "      this.getChildState();\n      " +
      "    }\n      " +
      "  }\n      " +
      "}\n      " +
      "```\n\n" +
      "**Key Points about ViewChild Child Access:**\n" +
      "- Use @ViewChild decorator to get child component reference\n" +
      "- Child component must have public methods/properties to access\n" +
      "- Available in ngAfterViewInit lifecycle hook\n" +
      "- Can call child methods, access properties, and manipulate state\n" +
      "- Useful for complex parent-child interactions\n" +
      "- Should be used sparingly - prefer @Input/@Output for simple communication\n" +
      "- Provides direct access to child component functionality\n" +
      "- Works with both template reference variables and component selectors\n" +
      "- Can access child component's public API\n" +
      "- Useful for imperative operations and complex state management",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "ViewChild", "parent-child", "communication", "access"],
  },
  {
    id: 190,
    question: "Difference between ViewChild and ViewChildren? What is QueryList?",
    answer:
      "ViewChild and ViewChildren are both decorators in Angular for accessing child elements, but they serve different purposes. ViewChild accesses a single element, while ViewChildren accesses multiple elements and returns a QueryList.\n\n" +
      "**ViewChild vs ViewChildren:**\n" +
      "```typescript\n" +
      "// viewchild-vs-viewchildren.component.ts\n" +
      "import { Component, ViewChild, ViewChildren, QueryList, AfterViewInit, ElementRef } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-viewchild-vs-viewchildren',\n" +
      "  template: `\n" +
      '    <div class="comparison-demo">\n' +
      "      <h3>ViewChild vs ViewChildren Comparison</h3>\n" +
      "      \n" +
      "      <!-- Single element for ViewChild -->\n" +
      '      <div #singleElement class="single-element">\n' +
      "        <p>Single Element (ViewChild)</p>\n" +
      "      </div>\n" +
      "      \n" +
      "      <!-- Multiple elements for ViewChildren -->\n" +
      '      <div #multipleElement class="multiple-element">\n' +
      "        <p>Multiple Element 1</p>\n" +
      "      </div>\n" +
      '      <div #multipleElement class="multiple-element">\n' +
      "        <p>Multiple Element 2</p>\n" +
      "      </div>\n" +
      '      <div #multipleElement class="multiple-element">\n' +
      "        <p>Multiple Element 3</p>\n" +
      "      </div>\n" +
      "      \n" +
      "      <!-- Dynamic elements -->\n" +
      '      <div *ngFor="let item of dynamicItems; let i = index" #dynamicElement class="dynamic-element">\n' +
      "        <p>Dynamic Element {{ i + 1 }}: {{ item }}</p>\n" +
      "      </div>\n" +
      "      \n" +
      '      <button (click)="addDynamicItem()">Add Dynamic Item</button>\n' +
      '      <button (click)="removeDynamicItem()">Remove Dynamic Item</button>\n' +
      "      \n" +
      '      <div class="info">\n' +
      "        <h4>Info:</h4>\n" +
      "        <p>Single Element Available: {{ singleElementAvailable }}</p>\n" +
      "        <p>Multiple Elements Count: {{ multipleElementsCount }}</p>\n" +
      "        <p>Dynamic Elements Count: {{ dynamicElementsCount }}</p>\n" +
      "        <p>Last Action: {{ lastAction }}</p>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ViewchildVsViewchildrenComponent implements AfterViewInit {\n" +
      "  // ViewChild - single element\n" +
      "  @ViewChild('singleElement') singleElement!: ElementRef;\n" +
      "  \n" +
      "  // ViewChildren - multiple elements\n" +
      "  @ViewChildren('multipleElement') multipleElements!: QueryList<ElementRef>;\n" +
      "  \n" +
      "  // ViewChildren - dynamic elements\n" +
      "  @ViewChildren('dynamicElement') dynamicElements!: QueryList<ElementRef>;\n" +
      "  \n" +
      "  dynamicItems = ['Item 1', 'Item 2', 'Item 3'];\n" +
      "  singleElementAvailable = false;\n" +
      "  multipleElementsCount = 0;\n" +
      "  dynamicElementsCount = 0;\n" +
      "  lastAction = '';\n" +
      "\n" +
      "  ngAfterViewInit() {\n" +
      "    console.log('ViewChild single element:', this.singleElement);\n" +
      "    console.log('ViewChildren multiple elements:', this.multipleElements);\n" +
      "    console.log('ViewChildren dynamic elements:', this.dynamicElements);\n" +
      "    \n" +
      "    this.updateInfo();\n" +
      "    \n" +
      "    // Subscribe to changes in ViewChildren\n" +
      "    this.multipleElements.changes.subscribe(() => {\n" +
      "      console.log('Multiple elements changed:', this.multipleElements.length);\n" +
      "      this.updateInfo();\n" +
      "    });\n" +
      "    \n" +
      "    this.dynamicElements.changes.subscribe(() => {\n" +
      "      console.log('Dynamic elements changed:', this.dynamicElements.length);\n" +
      "      this.updateInfo();\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  addDynamicItem() {\n" +
      "    this.dynamicItems.push(`Item ${this.dynamicItems.length + 1}`);\n" +
      "    this.lastAction = 'Added dynamic item';\n" +
      "  }\n" +
      "\n" +
      "  removeDynamicItem() {\n" +
      "    if (this.dynamicItems.length > 0) {\n" +
      "      this.dynamicItems.pop();\n" +
      "      this.lastAction = 'Removed dynamic item';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  updateInfo() {\n" +
      "    this.singleElementAvailable = !!this.singleElement;\n" +
      "    this.multipleElementsCount = this.multipleElements.length;\n" +
      "    this.dynamicElementsCount = this.dynamicElements.length;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**QueryList Features and Methods:**\n" +
      "```typescript\n" +
      "// querylist-demo.component.ts\n" +
      "import { Component, ViewChildren, QueryList, AfterViewInit, ElementRef } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-querylist-demo',\n" +
      "  template: `\n" +
      '    <div class="querylist-demo">\n' +
      "      <h3>QueryList Demo</h3>\n" +
      "      \n" +
      "      <!-- Elements with same template reference -->\n" +
      '      <div #itemRef class="item" *ngFor="let item of items; let i = index">\n' +
      "        <span>{{ item.name }}</span>\n" +
      "        <span>{{ item.value }}</span>\n" +
      '        <button (click)="selectItem(i)">Select</button>\n' +
      "      </div>\n" +
      "      \n" +
      '      <div class="controls">\n' +
      '        <button (click)="addItem()">Add Item</button>\n' +
      '        <button (click)="removeItem()">Remove Item</button>\n' +
      '        <button (click)="highlightAll()">Highlight All</button>\n' +
      '        <button (click)="clearAll()">Clear All</button>\n' +
      '        <button (click)="getFirstItem()">Get First Item</button>\n' +
      '        <button (click)="getLastItem()">Get Last Item</button>\n' +
      '        <button (click)="forEachItem()">For Each Item</button>\n' +
      "      </div>\n" +
      "      \n" +
      '      <div class="info">\n' +
      "        <h4>QueryList Info:</h4>\n" +
      "        <p>Total Items: {{ totalItems }}</p>\n" +
      "        <p>First Item: {{ firstItem }}</p>\n" +
      "        <p>Last Item: {{ lastItem }}</p>\n" +
      "        <p>Selected Item: {{ selectedItem }}</p>\n" +
      "        <p>Last Action: {{ lastAction }}</p>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class QuerylistDemoComponent implements AfterViewInit {\n" +
      "  @ViewChildren('itemRef') itemElements!: QueryList<ElementRef>;\n" +
      "  \n" +
      "  items = [\n" +
      "    { name: 'Item 1', value: 100 },\n" +
      "    { name: 'Item 2', value: 200 },\n" +
      "    { name: 'Item 3', value: 300 }\n" +
      "  ];\n" +
      "  \n" +
      "  totalItems = 0;\n" +
      "  firstItem = '';\n" +
      "  lastItem = '';\n" +
      "  selectedItem = '';\n" +
      "  lastAction = '';\n" +
      "\n" +
      "  ngAfterViewInit() {\n" +
      "    console.log('QueryList initialized:', this.itemElements);\n" +
      "    this.updateInfo();\n" +
      "    \n" +
      "    // Subscribe to changes\n" +
      "    this.itemElements.changes.subscribe(() => {\n" +
      "      console.log('QueryList changed:', this.itemElements.length);\n" +
      "      this.updateInfo();\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  addItem() {\n" +
      "    const newItem = {\n" +
      "      name: `Item ${this.items.length + 1}`,\n" +
      "      value: Math.floor(Math.random() * 1000)\n" +
      "    };\n" +
      "    this.items.push(newItem);\n" +
      "    this.lastAction = 'Added item';\n" +
      "  }\n" +
      "\n" +
      "  removeItem() {\n" +
      "    if (this.items.length > 0) {\n" +
      "      this.items.pop();\n" +
      "      this.lastAction = 'Removed item';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  selectItem(index: number) {\n" +
      "    this.selectedItem = this.items[index].name;\n" +
      "    this.lastAction = `Selected ${this.selectedItem}`;\n" +
      "  }\n" +
      "\n" +
      "  highlightAll() {\n" +
      "    this.itemElements.forEach((element, index) => {\n" +
      "      element.nativeElement.style.backgroundColor = 'yellow';\n" +
      "      console.log(`Highlighted element ${index}:`, element.nativeElement);\n" +
      "    });\n" +
      "    this.lastAction = 'Highlighted all items';\n" +
      "  }\n" +
      "\n" +
      "  clearAll() {\n" +
      "    this.itemElements.forEach(element => {\n" +
      "      element.nativeElement.style.backgroundColor = '';\n" +
      "    });\n" +
      "    this.lastAction = 'Cleared all highlights';\n" +
      "  }\n" +
      "\n" +
      "  getFirstItem() {\n" +
      "    if (this.itemElements.length > 0) {\n" +
      "      const firstElement = this.itemElements.first;\n" +
      "      this.firstItem = firstElement.nativeElement.textContent.trim();\n" +
      "      this.lastAction = 'Retrieved first item';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  getLastItem() {\n" +
      "    if (this.itemElements.length > 0) {\n" +
      "      const lastElement = this.itemElements.last;\n" +
      "      this.lastItem = lastElement.nativeElement.textContent.trim();\n" +
      "      this.lastAction = 'Retrieved last item';\n" +
      "    }\n" +
      "  }\n      " +
      "\n      " +
      "  forEachItem() {\n      " +
      "    this.itemElements.forEach((element, index) => {\n      " +
      "      console.log(`Element ${index}:`, element.nativeElement);\n      " +
      "      element.nativeElement.style.border = '2px solid blue';\n      " +
      "    });\n      " +
      "    this.lastAction = 'Processed all items';\n      " +
      "  }\n      " +
      "\n      " +
      "  private updateInfo() {\n      " +
      "    this.totalItems = this.itemElements.length;\n      " +
      "  }\n      " +
      "}\n      " +
      "```\n\n" +
      "**QueryList Methods and Properties:**\n      " +
      "```typescript\n      " +
      "// querylist-methods.component.ts\n      " +
      "import { Component, ViewChildren, QueryList, AfterViewInit, ElementRef } from '@angular/core';\n      " +
      "\n      " +
      "@Component({\n      " +
      "  selector: 'app-querylist-methods',\n      " +
      "  template: `\n      " +
      '    <div class="querylist-methods">\n      ' +
      "      <h3>QueryList Methods and Properties</h3>\n      " +
      "      \n      " +
      '      <div #methodRef class="method-item" *ngFor="let method of methods">\n      ' +
      "        <span>{{ method.name }}</span>\n      " +
      "        <span>{{ method.description }}</span>\n      " +
      "      </div>\n      " +
      "      \n      " +
      '      <div class="controls">\n      ' +
      '        <button (click)="demonstrateMethods()">Demonstrate Methods</button>\n      ' +
      '        <button (click)="demonstrateProperties()">Demonstrate Properties</button>\n      ' +
      '        <button (click)="demonstrateChanges()">Demonstrate Changes</button>\n      ' +
      "      </div>\n      " +
      "      \n      " +
      '      <div class="output">\n      ' +
      "        <h4>Output:</h4>\n      " +
      "        <pre>{{ output }}</pre>\n      " +
      "      </div>\n      " +
      "    </div>\n      " +
      "  `\n      " +
      "})\n      " +
      "export class QuerylistMethodsComponent implements AfterViewInit {\n      " +
      "  @ViewChildren('methodRef') methodElements!: QueryList<ElementRef>;\n      " +
      "  \n      " +
      "  methods = [\n      " +
      "    { name: 'length', description: 'Number of elements' },\n      " +
      "    { name: 'first', description: 'First element' },\n      " +
      "    { name: 'last', description: 'Last element' },\n      " +
      "    { name: 'changes', description: 'Observable of changes' }\n      " +
      "  ];\n      " +
      "  \n      " +
      "  output = '';\n      " +
      "\n      " +
      "  ngAfterViewInit() {\n      " +
      "    console.log('QueryList methods component initialized');\n      " +
      "  }\n      " +
      "\n      " +
      "  demonstrateMethods() {\n      " +
      "    let result = 'QueryList Methods:\\n';\n      " +
      "    \n      " +
      "    // length property\n      " +
      "    result += `length: ${this.methodElements.length}\\n`;\n      " +
      "    \n      " +
      "    // first property\n      " +
      "    if (this.methodElements.length > 0) {\n      " +
      "      result += `first: ${this.methodElements.first.nativeElement.textContent}\\n`;\n      " +
      "    }\n      " +
      "    \n      " +
      "    // last property\n      " +
      "    if (this.methodElements.length > 0) {\n      " +
      "      result += `last: ${this.methodElements.last.nativeElement.textContent}\\n`;\n      " +
      "    }\n      " +
      "    \n      " +
      "    // forEach method\n      " +
      "    result += 'forEach:\\n';\n      " +
      "    this.methodElements.forEach((element, index) => {\n      " +
      "      result += `  ${index}: ${element.nativeElement.textContent}\\n`;\n      " +
      "    });\n      " +
      "    \n      " +
      "    // toArray method\n      " +
      "    const array = this.methodElements.toArray();\n      " +
      "    result += `toArray length: ${array.length}\\n`;\n      " +
      "    \n      " +
      "    // some method\n      " +
      "    const hasFirst = this.methodElements.some(element => \n      " +
      "      element.nativeElement.textContent.includes('first')\n      " +
      "    );\n      " +
      "    result += `some (has 'first'): ${hasFirst}\\n`;\n      " +
      "    \n      " +
      "    // every method\n      " +
      "    const allHaveText = this.methodElements.every(element => \n      " +
      "      element.nativeElement.textContent.trim().length > 0\n      " +
      "    );\n      " +
      "    result += `every (has text): ${allHaveText}\\n`;\n      " +
      "    \n      " +
      "    // find method\n      " +
      "    const found = this.methodElements.find(element => \n      " +
      "      element.nativeElement.textContent.includes('last')\n      " +
      "    );\n      " +
      "    result += `find ('last'): ${found ? found.nativeElement.textContent : 'Not found'}\\n`;\n      " +
      "    \n      " +
      "    // filter method\n      " +
      "    const filtered = this.methodElements.filter(element => \n      " +
      "      element.nativeElement.textContent.includes('element')\n      " +
      "    );\n      " +
      "    result += `filter ('element'): ${filtered.length} items\\n`;\n      " +
      "    \n      " +
      "    // map method\n      " +
      "    const mapped = this.methodElements.map(element => \n      " +
      "      element.nativeElement.textContent.trim()\n      " +
      "    );\n      " +
      "    result += `map (text content): ${mapped.join(', ')}\\n`;\n      " +
      "    \n      " +
      "    // reduce method\n      " +
      "    const reduced = this.methodElements.reduce((acc, element) => {\n      " +
      "      return acc + element.nativeElement.textContent.length;\n      " +
      "    }, 0);\n      " +
      "    result += `reduce (total text length): ${reduced}\\n`;\n      " +
      "    \n      " +
      "    this.output = result;\n      " +
      "  }\n      " +
      "\n      " +
      "  demonstrateProperties() {\n      " +
      "    let result = 'QueryList Properties:\\n';\n      " +
      "    \n      " +
      "    result += `length: ${this.methodElements.length}\\n`;\n      " +
      "    result += `first: ${this.methodElements.first ? 'Available' : 'Not available'}\\n`;\n      " +
      "    result += `last: ${this.methodElements.last ? 'Available' : 'Not available'}\\n`;\n      " +
      "    result += `changes: ${this.methodElements.changes ? 'Available' : 'Not available'}\\n`;\n      " +
      "    \n      " +
      "    this.output = result;\n      " +
      "  }\n      " +
      "\n      " +
      "  demonstrateChanges() {\n      " +
      "    let result = 'QueryList Changes:\\n';\n      " +
      "    \n      " +
      "    // Subscribe to changes\n      " +
      "    const subscription = this.methodElements.changes.subscribe(() => {\n      " +
      "      result += `Elements changed, new count: ${this.methodElements.length}\\n`;\n      " +
      "    });\n      " +
      "    \n      " +
      "    result += 'Subscribed to changes. Try adding/removing elements.\\n';\n      " +
      "    \n      " +
      "    this.output = result;\n      " +
      "  }\n      " +
      "}\n      " +
      "```\n\n" +
      "**Key Differences:**\n\n" +
      "| Feature | ViewChild | ViewChildren |\n" +
      "|---------|-----------|--------------|\n" +
      "| **Purpose** | Single element access | Multiple elements access |\n" +
      "| **Return Type** | ElementRef or Component | QueryList<ElementRef> |\n" +
      "| **Element Count** | One | Multiple |\n" +
      "| **Changes** | Static | Observable (changes) |\n" +
      "| **Methods** | Direct access | QueryList methods |\n" +
      "| **Use Case** | Single reference | Dynamic list |\n\n" +
      "**QueryList Key Features:**\n" +
      "- `length`: Number of elements\n" +
      "- `first`: First element\n" +
      "- `last`: Last element\n" +
      "- `changes`: Observable of changes\n" +
      "- `forEach()`: Iterate through elements\n" +
      "- `toArray()`: Convert to array\n" +
      "- `some()`: Check if any element matches\n" +
      "- `every()`: Check if all elements match\n" +
      "- `find()`: Find first matching element\n" +
      "- `filter()`: Filter elements\n" +
      "- `map()`: Transform elements\n" +
      "- `reduce()`: Reduce elements to single value",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "ViewChild", "ViewChildren", "QueryList", "comparison"],
  },
  {
    id: 191,
    question: "What is ContentChild?",
    answer:
      "ContentChild is a decorator in Angular that allows you to access projected content (content that is passed between the opening and closing tags of a component). It's used to access elements that are projected into a component via ng-content.\n\n" +
      "**Basic ContentChild Usage:**\n" +
      "```typescript\n" +
      "// content-child-demo.component.ts\n" +
      "import { Component, ContentChild, AfterContentInit, ElementRef } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-content-child-demo',\n" +
      "  template: `\n" +
      '    <div class="content-child-demo">\n' +
      "      <h3>ContentChild Demo</h3>\n" +
      "      \n      " +
      "      <!-- Projected content -->\n      " +
      "      <ng-content></ng-content>\n      " +
      "      \n      " +
      '      <div class="info">\n      ' +
      "        <h4>ContentChild Info:</h4>\n      " +
      "        <p>Projected Element Available: {{ projectedElementAvailable }}</p>\n      " +
      "        <p>Projected Element Text: {{ projectedElementText }}</p>\n      " +
      "        <p>Last Action: {{ lastAction }}</p>\n      " +
      "      </div>\n      " +
      "      \n      " +
      '      <div class="controls">\n      ' +
      '        <button (click)="accessProjectedContent()">Access Projected Content</button>\n      ' +
      '        <button (click)="manipulateProjectedContent()">Manipulate Projected Content</button>\n      ' +
      "      </div>\n      " +
      "    </div>\n      " +
      "  `\n      " +
      "})\n      " +
      "export class ContentChildDemoComponent implements AfterContentInit {\n      " +
      "  @ContentChild('projectedElement') projectedElement!: ElementRef;\n" +
      "  \n" +
      "  projectedElementAvailable = false;\n" +
      "  projectedElementText = '';\n" +
      "  lastAction = '';\n" +
      "\n" +
      "  ngAfterContentInit() {\n" +
      "    console.log('ContentChild projected element:', this.projectedElement);\n" +
      "    this.updateInfo();\n" +
      "  }\n" +
      "\n" +
      "  accessProjectedContent() {\n" +
      "    if (this.projectedElement) {\n" +
      "      this.projectedElementText = this.projectedElement.nativeElement.textContent;\n" +
      "      this.lastAction = 'Accessed projected content';\n" +
      "      console.log('Projected element:', this.projectedElement.nativeElement);\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  manipulateProjectedContent() {\n" +
      "    if (this.projectedElement) {\n" +
      "      this.projectedElement.nativeElement.style.backgroundColor = 'lightblue';\n" +
      "      this.projectedElement.nativeElement.style.padding = '10px';\n" +
      "      this.projectedElement.nativeElement.style.border = '2px solid blue';\n" +
      "      this.lastAction = 'Manipulated projected content';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  private updateInfo() {\n" +
      "    this.projectedElementAvailable = !!this.projectedElement;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Using ContentChild in Parent Component:**\n" +
      "```typescript\n" +
      "// parent-with-content.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-parent-with-content',\n" +
      "  template: `\n" +
      '    <div class="parent-with-content">\n' +
      "      <h3>Parent with Content</h3>\n" +
      "      \n" +
      "      <app-content-child-demo>\n" +
      "        <!-- Projected content -->\n" +
      '        <div #projectedElement class="projected-content">\n' +
      "          <h4>This is projected content!</h4>\n" +
      "          <p>This content is passed to the child component.</p>\n" +
      "          <p>It can be accessed using ContentChild decorator.</p>\n" +
      "        </div>\n" +
      "      </app-content-child-demo>\n" +
      "      \n" +
      "      <app-content-child-demo>\n" +
      "        <!-- Another projected content -->\n" +
      '        <div #projectedElement class="projected-content">\n' +
      "          <h4>Another projected content!</h4>\n" +
      "          <p>This is a different projected content.</p>\n" +
      "        </div>\n" +
      "      </app-content-child-demo>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ParentWithContentComponent {\n" +
      "}\n" +
      "```\n\n" +
      "**Advanced ContentChild with Multiple Elements:**\n" +
      "```typescript\n" +
      "// advanced-content-child.component.ts\n" +
      "import { Component, ContentChild, ContentChildren, QueryList, AfterContentInit, ElementRef } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-advanced-content-child',\n" +
      "  template: `\n" +
      '    <div class="advanced-content-child">\n' +
      "      <h3>Advanced ContentChild</h3>\n" +
      "      \n" +
      "      <!-- Projected content -->\n" +
      "      <ng-content></ng-content>\n" +
      "      \n" +
      '      <div class="info">\n' +
      "        <h4>ContentChild Info:</h4>\n" +
      "        <p>First Element Available: {{ firstElementAvailable }}</p>\n" +
      "        <p>All Elements Count: {{ allElementsCount }}</p>\n" +
      "        <p>Last Action: {{ lastAction }}</p>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="controls">\n' +
      '        <button (click)="accessFirstElement()">Access First Element</button>\n' +
      '        <button (click)="accessAllElements()">Access All Elements</button>\n' +
      '        <button (click)="manipulateAllElements()">Manipulate All Elements</button>\n' +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class AdvancedContentChildComponent implements AfterContentInit {\n" +
      "  @ContentChild('firstElement') firstElement!: ElementRef;\n" +
      "  @ContentChildren('allElements') allElements!: QueryList<ElementRef>;\n" +
      "  \n" +
      "  firstElementAvailable = false;\n" +
      "  allElementsCount = 0;\n" +
      "  lastAction = '';\n" +
      "\n" +
      "  ngAfterContentInit() {\n" +
      "    console.log('ContentChild first element:', this.firstElement);\n" +
      "    console.log('ContentChildren all elements:', this.allElements);\n" +
      "    \n" +
      "    this.updateInfo();\n" +
      "    \n" +
      "    // Subscribe to changes in ContentChildren\n" +
      "    this.allElements.changes.subscribe(() => {\n" +
      "      console.log('ContentChildren changed:', this.allElements.length);\n" +
      "      this.updateInfo();\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  accessFirstElement() {\n" +
      "    if (this.firstElement) {\n" +
      "      console.log('First element:', this.firstElement.nativeElement);\n" +
      "      this.lastAction = 'Accessed first element';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  accessAllElements() {\n" +
      "    this.allElements.forEach((element, index) => {\n" +
      "      console.log(`Element ${index}:`, element.nativeElement);\n" +
      "    });\n" +
      "    this.lastAction = 'Accessed all elements';\n" +
      "  }\n" +
      "\n" +
      "  manipulateAllElements() {\n" +
      "    this.allElements.forEach((element, index) => {\n" +
      "      element.nativeElement.style.backgroundColor = index % 2 === 0 ? 'lightgreen' : 'lightcoral';\n" +
      "      element.nativeElement.style.padding = '5px';\n" +
      "      element.nativeElement.style.margin = '2px';\n" +
      "    });\n" +
      "    this.lastAction = 'Manipulated all elements';\n" +
      "  }\n" +
      "\n" +
      "  private updateInfo() {\n" +
      "    this.firstElementAvailable = !!this.firstElement;\n" +
      "    this.allElementsCount = this.allElements.length;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**ContentChild with Component References:**\n" +
      "```typescript\n" +
      "// content-child-component.component.ts\n" +
      "import { Component, ContentChild, AfterContentInit, ElementRef } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-content-child-component',\n" +
      "  template: `\n" +
      '    <div class="content-child-component">\n' +
      "      <h3>ContentChild with Component</h3>\n" +
      "      \n" +
      "      <!-- Projected content -->\n" +
      "      <ng-content></ng-content>\n" +
      "      \n" +
      '      <div class="info">\n' +
      "        <h4>Component Info:</h4>\n" +
      "        <p>Projected Component Available: {{ projectedComponentAvailable }}</p>\n" +
      "        <p>Component Data: {{ componentData }}</p>\n" +
      "        <p>Last Action: {{ lastAction }}</p>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="controls">\n' +
      '        <button (click)="accessComponent()">Access Component</button>\n' +
      '        <button (click)="callComponentMethod()">Call Component Method</button>\n' +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ContentChildComponentComponent implements AfterContentInit {\n" +
      "  @ContentChild('projectedComponent') projectedComponent!: any;\n" +
      "  \n" +
      "  projectedComponentAvailable = false;\n" +
      "  componentData = '';\n" +
      "  lastAction = '';\n" +
      "\n" +
      "  ngAfterContentInit() {\n" +
      "    console.log('ContentChild projected component:', this.projectedComponent);\n" +
      "    this.updateInfo();\n" +
      "  }\n" +
      "\n" +
      "  accessComponent() {\n" +
      "    if (this.projectedComponent) {\n" +
      "      console.log('Projected component:', this.projectedComponent);\n" +
      "      this.componentData = JSON.stringify(this.projectedComponent);\n" +
      "      this.lastAction = 'Accessed projected component';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  callComponentMethod() {\n" +
      "    if (this.projectedComponent && this.projectedComponent.someMethod) {\n" +
      "      this.projectedComponent.someMethod();\n" +
      "      this.lastAction = 'Called component method';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  private updateInfo() {\n" +
      "    this.projectedComponentAvailable = !!this.projectedComponent;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Points about ContentChild:**\n" +
      "- Used to access projected content (ng-content)\n" +
      "- Available in ngAfterContentInit lifecycle hook\n" +
      "- Can access both ElementRef and Component references\n" +
      "- Works with template reference variables\n" +
      "- Useful for component composition and content projection\n" +
      "- Can manipulate projected content programmatically\n" +
      "- Supports both single (@ContentChild) and multiple (@ContentChildren) access\n" +
      "- Changes are observable with ContentChildren\n" +
      "- Essential for building reusable components with flexible content",
    category: "Components",
    difficulty: "intermediate",
    tags: ["components", "ContentChild", "content-projection", "ng-content"],
  },
  {
    id: 192,
    question: "Compare ng-Content, ViewChild, ViewChildren, ContentChild & ContentChildren?",
    answer:
      "These Angular decorators and directives serve different purposes in component communication and content management. Understanding their differences is crucial for effective Angular development.\n\n" +
      "**Comprehensive Comparison:**\n\n" +
      "| Feature | ng-content | ViewChild | ViewChildren | ContentChild | ContentChildren |\n" +
      "|---------|------------|-----------|--------------|--------------|----------------|\n" +
      "| **Purpose** | Content projection | Single view element access | Multiple view elements access | Single projected content access | Multiple projected content access |\n" +
      "| **Type** | Directive | Decorator | Decorator | Decorator | Decorator |\n" +
      "| **Content Source** | Parent component | Child component template | Child component template | Projected content | Projected content |\n" +
      "| **Return Type** | N/A | ElementRef/Component | QueryList<ElementRef> | ElementRef/Component | QueryList<ElementRef> |\n" +
      "| **Lifecycle Hook** | N/A | ngAfterViewInit | ngAfterViewInit | ngAfterContentInit | ngAfterContentInit |\n" +
      "| **Changes Observable** | N/A | No | Yes | No | Yes |\n" +
      "| **Use Case** | Content projection | Single element access | Dynamic list access | Single projected element | Multiple projected elements |\n\n" +
      "**Practical Example with All Decorators:**\n" +
      "```typescript\n" +
      "// comprehensive-demo.component.ts\n" +
      "import { Component, ViewChild, ViewChildren, ContentChild, ContentChildren, QueryList, AfterViewInit, AfterContentInit, ElementRef } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-comprehensive-demo',\n" +
      "  template: `\n" +
      '    <div class="comprehensive-demo">\n' +
      "      <h3>Comprehensive Demo</h3>\n" +
      "      \n" +
      "      <!-- ViewChild/ViewChildren elements -->\n" +
      '      <div #singleViewElement class="view-element">\n' +
      "        <p>Single View Element</p>\n" +
      "      </div>\n" +
      "      \n      " +
      '      <div #multipleViewElement class="view-element">\n      ' +
      "        <p>Multiple View Element 1</p>\n      " +
      "      </div>\n      " +
      '      <div #multipleViewElement class="view-element">\n      ' +
      "        <p>Multiple View Element 2</p>\n      " +
      "      </div>\n      " +
      "      \n      " +
      "      <!-- Projected content (ng-content) -->\n      " +
      "      <ng-content></ng-content>\n      " +
      "      \n      " +
      '      <div class="info">\n      ' +
      "        <h4>All Decorators Info:</h4>\n      " +
      "        <p>ViewChild Available: {{ viewChildAvailable }}</p>\n      " +
      "        <p>ViewChildren Count: {{ viewChildrenCount }}</p>\n      " +
      "        <p>ContentChild Available: {{ contentChildAvailable }}</p>\n      " +
      "        <p>ContentChildren Count: {{ contentChildrenCount }}</p>\n      " +
      "        <p>Last Action: {{ lastAction }}</p>\n      " +
      "      </div>\n      " +
      "      \n      " +
      '      <div class="controls">\n      ' +
      '        <button (click)="demonstrateViewChild()">Demonstrate ViewChild</button>\n      ' +
      '        <button (click)="demonstrateViewChildren()">Demonstrate ViewChildren</button>\n      ' +
      '        <button (click)="demonstrateContentChild()">Demonstrate ContentChild</button>\n      ' +
      '        <button (click)="demonstrateContentChildren()">Demonstrate ContentChildren</button>\n      ' +
      '        <button (click)="demonstrateAll()">Demonstrate All</button>\n      ' +
      "      </div>\n      " +
      "    </div>\n      " +
      "  `\n      " +
      "})\n      " +
      "export class ComprehensiveDemoComponent implements AfterViewInit, AfterContentInit {\n      " +
      "  // ViewChild - single view element\n" +
      "  @ViewChild('singleViewElement') singleViewElement!: ElementRef;\n" +
      "  \n" +
      "  // ViewChildren - multiple view elements\n" +
      "  @ViewChildren('multipleViewElement') multipleViewElements!: QueryList<ElementRef>;\n" +
      "  \n" +
      "  // ContentChild - single projected content\n" +
      "  @ContentChild('projectedElement') projectedElement!: ElementRef;\n" +
      "  \n" +
      "  // ContentChildren - multiple projected content\n" +
      "  @ContentChildren('projectedElement') projectedElements!: QueryList<ElementRef>;\n" +
      "  \n" +
      "  viewChildAvailable = false;\n" +
      "  viewChildrenCount = 0;\n" +
      "  contentChildAvailable = false;\n" +
      "  contentChildrenCount = 0;\n" +
      "  lastAction = '';\n" +
      "\n" +
      "  ngAfterViewInit() {\n" +
      "    console.log('ViewChild single element:', this.singleViewElement);\n" +
      "    console.log('ViewChildren multiple elements:', this.multipleViewElements);\n" +
      "    \n" +
      "    this.updateViewInfo();\n" +
      "    \n" +
      "    // Subscribe to ViewChildren changes\n" +
      "    this.multipleViewElements.changes.subscribe(() => {\n" +
      "      console.log('ViewChildren changed:', this.multipleViewElements.length);\n" +
      "      this.updateViewInfo();\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  ngAfterContentInit() {\n" +
      "    console.log('ContentChild projected element:', this.projectedElement);\n" +
      "    console.log('ContentChildren projected elements:', this.projectedElements);\n" +
      "    \n" +
      "    this.updateContentInfo();\n" +
      "    \n" +
      "    // Subscribe to ContentChildren changes\n" +
      "    this.projectedElements.changes.subscribe(() => {\n" +
      "      console.log('ContentChildren changed:', this.projectedElements.length);\n" +
      "      this.updateContentInfo();\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  demonstrateViewChild() {\n" +
      "    if (this.singleViewElement) {\n" +
      "      this.singleViewElement.nativeElement.style.backgroundColor = 'lightblue';\n" +
      "      this.lastAction = 'ViewChild: Styled single view element';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  demonstrateViewChildren() {\n" +
      "    this.multipleViewElements.forEach((element, index) => {\n" +
      "      element.nativeElement.style.backgroundColor = index % 2 === 0 ? 'lightgreen' : 'lightcoral';\n" +
      "    });\n" +
      "    this.lastAction = 'ViewChildren: Styled multiple view elements';\n" +
      "  }\n" +
      "\n" +
      "  demonstrateContentChild() {\n" +
      "    if (this.projectedElement) {\n" +
      "      this.projectedElement.nativeElement.style.backgroundColor = 'lightyellow';\n" +
      "      this.lastAction = 'ContentChild: Styled single projected element';\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  demonstrateContentChildren() {\n" +
      "    this.projectedElements.forEach((element, index) => {\n" +
      "      element.nativeElement.style.backgroundColor = index % 2 === 0 ? 'lightpink' : 'lightgray';\n" +
      "    });\n" +
      "    this.lastAction = 'ContentChildren: Styled multiple projected elements';\n" +
      "  }\n" +
      "\n" +
      "  demonstrateAll() {\n" +
      "    // Demonstrate all decorators\n" +
      "    this.demonstrateViewChild();\n" +
      "    this.demonstrateViewChildren();\n" +
      "    this.demonstrateContentChild();\n" +
      "    this.demonstrateContentChildren();\n" +
      "    this.lastAction = 'All: Demonstrated all decorators';\n" +
      "  }\n" +
      "\n" +
      "  private updateViewInfo() {\n" +
      "    this.viewChildAvailable = !!this.singleViewElement;\n" +
      "    this.viewChildrenCount = this.multipleViewElements.length;\n" +
      "  }\n" +
      "\n" +
      "  private updateContentInfo() {\n" +
      "    this.contentChildAvailable = !!this.projectedElement;\n" +
      "    this.contentChildrenCount = this.projectedElements.length;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Using the Comprehensive Demo:**\n" +
      "```typescript\n" +
      "// parent-comprehensive.component.ts\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-parent-comprehensive',\n" +
      "  template: `\n" +
      '    <div class="parent-comprehensive">\n' +
      "      <h3>Parent Comprehensive</h3>\n" +
      "      \n" +
      "      <app-comprehensive-demo>\n" +
      "        <!-- Projected content -->\n" +
      '        <div #projectedElement class="projected-content">\n' +
      "          <h4>Projected Content 1</h4>\n" +
      "          <p>This is projected content.</p>\n" +
      "        </div>\n" +
      '        <div #projectedElement class="projected-content">\n' +
      "          <h4>Projected Content 2</h4>\n" +
      "          <p>This is another projected content.</p>\n" +
      "        </div>\n" +
      "      </app-comprehensive-demo>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ParentComprehensiveComponent {\n" +
      "}\n" +
      "```\n\n" +
      "**When to Use Each:**\n\n" +
      "**ng-content:**\n" +
      "- Use when you want to project content from parent to child\n" +
      "- Essential for component composition\n" +
      "- Provides flexibility in component design\n" +
      "- Example: Modal, Card, Layout components\n\n" +
      "**ViewChild:**\n" +
      "- Use when you need to access a single child element\n" +
      "- Perfect for form controls, single DOM elements\n" +
      "- Example: Accessing input fields, single buttons\n\n" +
      "**ViewChildren:**\n" +
      "- Use when you need to access multiple child elements\n" +
      "- Perfect for dynamic lists, multiple form controls\n" +
      "- Example: Accessing all input fields, multiple buttons\n\n" +
      "**ContentChild:**\n" +
      "- Use when you need to access a single projected element\n" +
      "- Perfect for accessing specific projected content\n" +
      "- Example: Accessing a specific projected component\n\n" +
      "**ContentChildren:**\n" +
      "- Use when you need to access multiple projected elements\n" +
      "- Perfect for accessing all projected content\n" +
      "- Example: Accessing all projected components\n\n" +
      "**Key Differences Summary:**\n" +
      "- **ng-content**: Projects content, doesn't access it\n" +
      "- **ViewChild/ViewChildren**: Access child template elements\n" +
      "- **ContentChild/ContentChildren**: Access projected content\n" +
      "- **ViewChild/ContentChild**: Single element access\n" +
      "- **ViewChildren/ContentChildren**: Multiple elements access\n" +
      "- **ViewChild/ViewChildren**: Available in ngAfterViewInit\n" +
      "- **ContentChild/ContentChildren**: Available in ngAfterContentInit\n" +
      "- **ViewChildren/ContentChildren**: Provide observable changes\n" +
      "- **ViewChild/ContentChild**: Direct element access\n" +
      "- **ViewChildren/ContentChildren**: QueryList with methods",
    category: "Components",
    difficulty: "advanced",
    tags: [
      "components",
      "ng-content",
      "ViewChild",
      "ViewChildren",
      "ContentChild",
      "ContentChildren",
      "comparison",
    ],
  },
  {
    id: 194,
    question: "What is Authentication & Authorization in Angular?",
    answer:
      "Authentication and Authorization are fundamental security concepts in Angular applications. Authentication verifies who a user is, while Authorization determines what they can access.\n\n" +
      "**Authentication vs Authorization:**\n\n" +
      "| Concept | Purpose | Example |\n" +
      "|---------|---------|---------|\n" +
      "| **Authentication** | Verify user identity | Login with username/password |\n" +
      "| **Authorization** | Control access to resources | Check if user can view admin panel |\n\n" +
      "**Authentication Implementation:**\n" +
      "```typescript\n" +
      "// auth.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpClient } from '@angular/common/http';\n" +
      "import { BehaviorSubject, Observable } from 'rxjs';\n" +
      "import { tap } from 'rxjs/operators';\n" +
      "\n" +
      "export interface User {\n" +
      "  id: number;\n" +
      "  username: string;\n" +
      "  email: string;\n" +
      "  role: string;\n" +
      "  permissions: string[];\n" +
      "}\n" +
      "\n" +
      "export interface LoginRequest {\n" +
      "  username: string;\n" +
      "  password: string;\n" +
      "}\n" +
      "\n" +
      "export interface LoginResponse {\n" +
      "  token: string;\n" +
      "  user: User;\n" +
      "  expiresIn: number;\n" +
      "}\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class AuthService {\n" +
      "  private readonly API_URL = 'http://localhost:3000/api';\n" +
      "  private readonly TOKEN_KEY = 'auth_token';\n" +
      "  private readonly USER_KEY = 'user_data';\n" +
      "\n" +
      "  private currentUserSubject = new BehaviorSubject<User | null>(null);\n" +
      "  public currentUser$ = this.currentUserSubject.asObservable();\n" +
      "\n" +
      "  constructor(private http: HttpClient) {\n" +
      "    this.loadUserFromStorage();\n" +
      "  }\n" +
      "\n" +
      "  // Authentication Methods\n" +
      "  login(credentials: LoginRequest): Observable<LoginResponse> {\n" +
      "    return this.http.post<LoginResponse>(`${this.API_URL}/auth/login`, credentials)\n" +
      "      .pipe(\n" +
      "        tap(response => {\n" +
      "          this.setToken(response.token);\n" +
      "          this.setUser(response.user);\n" +
      "        })\n" +
      "      );\n" +
      "  }\n" +
      "\n" +
      "  logout(): void {\n" +
      "    this.removeToken();\n" +
      "    this.removeUser();\n" +
      "    this.currentUserSubject.next(null);\n" +
      "  }\n" +
      "\n" +
      "  register(userData: any): Observable<LoginResponse> {\n" +
      "    return this.http.post<LoginResponse>(`${this.API_URL}/auth/register`, userData)\n" +
      "      .pipe(\n" +
      "        tap(response => {\n" +
      "          this.setToken(response.token);\n" +
      "          this.setUser(response.user);\n" +
      "        })\n" +
      "      );\n" +
      "  }\n" +
      "\n" +
      "  // Authorization Methods\n" +
      "  isAuthenticated(): boolean {\n" +
      "    const token = this.getToken();\n" +
      "    if (!token) return false;\n" +
      "    \n" +
      "    // Check if token is expired\n" +
      "    try {\n" +
      "      const payload = JSON.parse(atob(token.split('.')[1]));\n" +
      "      const currentTime = Math.floor(Date.now() / 1000);\n" +
      "      return payload.exp > currentTime;\n" +
      "    } catch {\n" +
      "      return false;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  hasRole(role: string): boolean {\n" +
      "    const user = this.getCurrentUser();\n" +
      "    return user?.role === role;\n" +
      "  }\n" +
      "\n" +
      "  hasPermission(permission: string): boolean {\n" +
      "    const user = this.getCurrentUser();\n" +
      "    return user?.permissions?.includes(permission) || false;\n" +
      "  }\n" +
      "\n" +
      "  hasAnyRole(roles: string[]): boolean {\n" +
      "    const user = this.getCurrentUser();\n" +
      "    return roles.includes(user?.role || '');\n" +
      "  }\n" +
      "\n" +
      "  hasAllPermissions(permissions: string[]): boolean {\n" +
      "    const user = this.getCurrentUser();\n" +
      "    return permissions.every(permission => \n" +
      "      user?.permissions?.includes(permission)\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  // Token Management\n" +
      "  private setToken(token: string): void {\n" +
      "    localStorage.setItem(this.TOKEN_KEY, token);\n" +
      "  }\n" +
      "\n" +
      "  private getToken(): string | null {\n" +
      "    return localStorage.getItem(this.TOKEN_KEY);\n" +
      "  }\n" +
      "\n" +
      "  private removeToken(): void {\n" +
      "    localStorage.removeItem(this.TOKEN_KEY);\n" +
      "  }\n" +
      "\n" +
      "  // User Management\n" +
      "  private setUser(user: User): void {\n" +
      "    localStorage.setItem(this.USER_KEY, JSON.stringify(user));\n" +
      "    this.currentUserSubject.next(user);\n" +
      "  }\n" +
      "\n" +
      "  private getCurrentUser(): User | null {\n" +
      "    return this.currentUserSubject.value;\n" +
      "  }\n" +
      "\n" +
      "  private removeUser(): void {\n" +
      "    localStorage.removeItem(this.USER_KEY);\n" +
      "  }\n" +
      "\n" +
      "  private loadUserFromStorage(): void {\n" +
      "    const userData = localStorage.getItem(this.USER_KEY);\n" +
      "    if (userData && this.isAuthenticated()) {\n" +
      "      try {\n" +
      "        const user = JSON.parse(userData);\n" +
      "        this.currentUserSubject.next(user);\n" +
      "      } catch {\n" +
      "        this.logout();\n" +
      "      }\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Token Refresh\n" +
      "  refreshToken(): Observable<LoginResponse> {\n" +
      "    return this.http.post<LoginResponse>(`${this.API_URL}/auth/refresh`, {\n" +
      "      token: this.getToken()\n" +
      "    }).pipe(\n" +
      "      tap(response => {\n" +
      "        this.setToken(response.token);\n" +
      "        this.setUser(response.user);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Authorization Guard Implementation:**\n" +
      "```typescript\n" +
      "// auth.guard.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class AuthGuard implements CanActivate {\n" +
      "  constructor(\n" +
      "    private authService: AuthService,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "\n" +
      "  canActivate(\n" +
      "    route: ActivatedRouteSnapshot,\n" +
      "    state: RouterStateSnapshot\n" +
      "  ): boolean {\n" +
      "    if (this.authService.isAuthenticated()) {\n" +
      "      return true;\n" +
      "    }\n" +
      "\n" +
      "    // Store attempted URL for redirect after login\n" +
      "    this.router.navigate(['/login'], {\n" +
      "      queryParams: { returnUrl: state.url }\n" +
      "    });\n" +
      "    return false;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Role-Based Authorization Guard:**\n" +
      "```typescript\n" +
      "// role.guard.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { CanActivate, Router, ActivatedRouteSnapshot } from '@angular/router';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class RoleGuard implements CanActivate {\n" +
      "  constructor(\n" +
      "    private authService: AuthService,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "\n" +
      "  canActivate(route: ActivatedRouteSnapshot): boolean {\n" +
      "    const expectedRoles = route.data['roles'] as string[];\n" +
      "    \n" +
      "    if (!this.authService.isAuthenticated()) {\n" +
      "      this.router.navigate(['/login']);\n" +
      "      return false;\n" +
      "    }\n" +
      "\n" +
      "    if (expectedRoles && !this.authService.hasAnyRole(expectedRoles)) {\n" +
      "      this.router.navigate(['/unauthorized']);\n" +
      "      return false;\n" +
      "    }\n" +
      "\n" +
      "    return true;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Permission-Based Authorization Guard:**\n" +
      "```typescript\n" +
      "// permission.guard.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { CanActivate, Router, ActivatedRouteSnapshot } from '@angular/router';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class PermissionGuard implements CanActivate {\n" +
      "  constructor(\n" +
      "    private authService: AuthService,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "\n" +
      "  canActivate(route: ActivatedRouteSnapshot): boolean {\n" +
      "    const requiredPermissions = route.data['permissions'] as string[];\n" +
      "    \n" +
      "    if (!this.authService.isAuthenticated()) {\n" +
      "      this.router.navigate(['/login']);\n" +
      "      return false;\n" +
      "    }\n" +
      "\n" +
      "    if (requiredPermissions && !this.authService.hasAllPermissions(requiredPermissions)) {\n" +
      "      this.router.navigate(['/forbidden']);\n" +
      "      return false;\n" +
      "    }\n" +
      "\n" +
      "    return true;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Route Configuration with Guards:**\n" +
      "```typescript\n" +
      "// app-routing.module.ts\n" +
      "import { NgModule } from '@angular/core';\n" +
      "import { RouterModule, Routes } from '@angular/router';\n" +
      "import { AuthGuard } from './guards/auth.guard';\n" +
      "import { RoleGuard } from './guards/role.guard';\n" +
      "import { PermissionGuard } from './guards/permission.guard';\n" +
      "\n" +
      "const routes: Routes = [\n" +
      "  { path: 'login', component: LoginComponent },\n" +
      "  { \n" +
      "    path: 'dashboard', \n" +
      "    component: DashboardComponent,\n" +
      "    canActivate: [AuthGuard]\n" +
      "  },\n" +
      "  {\n" +
      "    path: 'admin',\n" +
      "    component: AdminComponent,\n" +
      "    canActivate: [AuthGuard, RoleGuard],\n" +
      "    data: { roles: ['admin', 'super-admin'] }\n" +
      "  },\n" +
      "  {\n" +
      "    path: 'reports',\n" +
      "    component: ReportsComponent,\n" +
      "    canActivate: [AuthGuard, PermissionGuard],\n" +
      "    data: { permissions: ['read:reports', 'write:reports'] }\n" +
      "  },\n" +
      "  { path: 'unauthorized', component: UnauthorizedComponent },\n" +
      "  { path: 'forbidden', component: ForbiddenComponent },\n" +
      "  { path: '', redirectTo: '/dashboard', pathMatch: 'full' }\n" +
      "];\n" +
      "\n" +
      "@NgModule({\n" +
      "  imports: [RouterModule.forRoot(routes)],\n" +
      "  exports: [RouterModule]\n" +
      "})\n" +
      "export class AppRoutingModule { }\n" +
      "```\n\n" +
      "**Key Points:**\n" +
      "- **Authentication**: Verifies user identity (login/logout)\n" +
      "- **Authorization**: Controls access to resources (roles/permissions)\n" +
      "- **Guards**: Protect routes based on authentication/authorization\n" +
      "- **Token Management**: Secure storage and validation\n" +
      "- **Role-Based Access**: Control access by user roles\n" +
      "- **Permission-Based Access**: Fine-grained access control\n" +
      "- **Route Protection**: Prevent unauthorized access to routes\n" +
      "- **Token Refresh**: Maintain session without re-login\n" +
      "- **Storage Security**: Use localStorage/sessionStorage appropriately",
    category: "Security",
    difficulty: "intermediate",
    tags: ["authentication", "authorization", "security", "guards", "roles", "permissions"],
  },
  {
    id: 195,
    question: "What is JWT Token Authentication in Angular?",
    answer:
      "JWT (JSON Web Token) is a compact, URL-safe token format used for securely transmitting information between parties. In Angular, JWT tokens are commonly used for authentication and authorization.\n\n" +
      "**JWT Token Structure:**\n" +
      "JWT consists of three parts separated by dots (`.`):\n" +
      "```\n" +
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n" +
      "```\n\n" +
      "**JWT Implementation in Angular:**\n" +
      "```typescript\n" +
      "// jwt.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpClient, HttpHeaders } from '@angular/common/http';\n" +
      "import { Observable, BehaviorSubject } from 'rxjs';\n" +
      "import { tap, catchError } from 'rxjs/operators';\n" +
      "\n" +
      "export interface JWTPayload {\n" +
      "  sub: string;        // Subject (user ID)\n" +
      "  iat: number;       // Issued at\n" +
      "  exp: number;       // Expiration time\n" +
      "  username: string;   // Username\n" +
      "  role: string;       // User role\n" +
      "  permissions: string[]; // User permissions\n" +
      "}\n" +
      "\n" +
      "export interface LoginCredentials {\n" +
      "  username: string;\n" +
      "  password: string;\n" +
      "}\n" +
      "\n" +
      "export interface AuthResponse {\n" +
      "  access_token: string;\n" +
      "  refresh_token: string;\n" +
      "  token_type: string;\n" +
      "  expires_in: number;\n" +
      "  user: {\n" +
      "    id: string;\n" +
      "    username: string;\n" +
      "    email: string;\n" +
      "    role: string;\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class JWTService {\n" +
      "  private readonly TOKEN_KEY = 'jwt_token';\n" +
      "  private readonly REFRESH_TOKEN_KEY = 'refresh_token';\n" +
      "  private readonly USER_KEY = 'user_data';\n" +
      "  \n" +
      "  private isAuthenticatedSubject = new BehaviorSubject<boolean>(false);\n" +
      "  public isAuthenticated$ = this.isAuthenticatedSubject.asObservable();\n" +
      "  \n" +
      "  private currentUserSubject = new BehaviorSubject<any>(null);\n" +
      "  public currentUser$ = this.currentUserSubject.asObservable();\n" +
      "\n" +
      "  constructor(private http: HttpClient) {\n" +
      "    this.initializeAuth();\n" +
      "  }\n" +
      "\n" +
      "  // JWT Token Management\n" +
      "  login(credentials: LoginCredentials): Observable<AuthResponse> {\n" +
      "    return this.http.post<AuthResponse>('/api/auth/login', credentials)\n" +
      "      .pipe(\n" +
      "        tap(response => {\n" +
      "          this.setTokens(response);\n" +
      "          this.setUser(response.user);\n" +
      "          this.isAuthenticatedSubject.next(true);\n" +
      "        }),\n" +
      "        catchError(error => {\n" +
      "          console.error('Login failed:', error);\n" +
      "          throw error;\n" +
      "        })\n" +
      "      );\n" +
      "  }\n" +
      "\n" +
      "  logout(): void {\n" +
      "    this.removeTokens();\n" +
      "    this.removeUser();\n" +
      "    this.isAuthenticatedSubject.next(false);\n" +
      "    this.currentUserSubject.next(null);\n" +
      "  }\n" +
      "\n" +
      "  refreshToken(): Observable<AuthResponse> {\n" +
      "    const refreshToken = this.getRefreshToken();\n" +
      "    if (!refreshToken) {\n" +
      "      throw new Error('No refresh token available');\n" +
      "    }\n" +
      "\n" +
      "    return this.http.post<AuthResponse>('/api/auth/refresh', {\n" +
      "      refresh_token: refreshToken\n" +
      "    }).pipe(\n" +
      "      tap(response => {\n" +
      "        this.setTokens(response);\n" +
      "      }),\n" +
      "      catchError(error => {\n" +
      "        this.logout();\n" +
      "        throw error;\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  // Token Validation\n" +
      "  isTokenValid(): boolean {\n" +
      "    const token = this.getToken();\n" +
      "    if (!token) return false;\n" +
      "\n" +
      "    try {\n" +
      "      const payload = this.decodeToken(token);\n" +
      "      const currentTime = Math.floor(Date.now() / 1000);\n" +
      "      return payload.exp > currentTime;\n" +
      "    } catch {\n" +
      "      return false;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  isTokenExpired(): boolean {\n" +
      "    const token = this.getToken();\n" +
      "    if (!token) return true;\n" +
      "\n" +
      "    try {\n" +
      "      const payload = this.decodeToken(token);\n" +
      "      const currentTime = Math.floor(Date.now() / 1000);\n" +
      "      return payload.exp <= currentTime;\n" +
      "    } catch {\n" +
      "      return true;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Token Decoding\n" +
      "  decodeToken(token: string): JWTPayload {\n" +
      "    try {\n" +
      "      const base64Url = token.split('.')[1];\n" +
      "      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n" +
      "      const jsonPayload = decodeURIComponent(\n" +
      "        atob(base64)\n" +
      "          .split('')\n" +
      "          .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n" +
      "          .join('')\n" +
      "      );\n" +
      "      return JSON.parse(jsonPayload);\n" +
      "    } catch (error) {\n" +
      "      throw new Error('Invalid token format');\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // User Information from Token\n" +
      "  getUserId(): string | null {\n" +
      "    const token = this.getToken();\n" +
      "    if (!token) return null;\n" +
      "\n" +
      "    try {\n" +
      "      const payload = this.decodeToken(token);\n" +
      "      return payload.sub;\n" +
      "    } catch {\n" +
      "      return null;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  getUserRole(): string | null {\n" +
      "    const token = this.getToken();\n" +
      "    if (!token) return null;\n" +
      "\n" +
      "    try {\n" +
      "      const payload = this.decodeToken(token);\n" +
      "      return payload.role;\n" +
      "    } catch {\n" +
      "      return null;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  getUserPermissions(): string[] {\n" +
      "    const token = this.getToken();\n" +
      "    if (!token) return [];\n" +
      "\n" +
      "    try {\n" +
      "      const payload = this.decodeToken(token);\n" +
      "      return payload.permissions || [];\n" +
      "    } catch {\n" +
      "      return [];\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // Token Storage\n" +
      "  private setTokens(response: AuthResponse): void {\n" +
      "    localStorage.setItem(this.TOKEN_KEY, response.access_token);\n" +
      "    localStorage.setItem(this.REFRESH_TOKEN_KEY, response.refresh_token);\n" +
      "  }\n" +
      "\n" +
      "  private getToken(): string | null {\n" +
      "    return localStorage.getItem(this.TOKEN_KEY);\n" +
      "  }\n" +
      "\n" +
      "  private getRefreshToken(): string | null {\n" +
      "    return localStorage.getItem(this.REFRESH_TOKEN_KEY);\n" +
      "  }\n" +
      "\n" +
      "  private removeTokens(): void {\n" +
      "    localStorage.removeItem(this.TOKEN_KEY);\n" +
      "    localStorage.removeItem(this.REFRESH_TOKEN_KEY);\n" +
      "  }\n" +
      "\n" +
      "  // User Storage\n" +
      "  private setUser(user: any): void {\n" +
      "    localStorage.setItem(this.USER_KEY, JSON.stringify(user));\n" +
      "    this.currentUserSubject.next(user);\n" +
      "  }\n" +
      "\n" +
      "  private removeUser(): void {\n" +
      "    localStorage.removeItem(this.USER_KEY);\n" +
      "  }\n" +
      "\n" +
      "  // Initialization\n" +
      "  private initializeAuth(): void {\n" +
      "    const token = this.getToken();\n" +
      "    const userData = localStorage.getItem(this.USER_KEY);\n" +
      "    \n" +
      "    if (token && this.isTokenValid() && userData) {\n" +
      "      try {\n" +
      "        const user = JSON.parse(userData);\n" +
      "        this.currentUserSubject.next(user);\n" +
      "        this.isAuthenticatedSubject.next(true);\n" +
      "      } catch {\n" +
      "        this.logout();\n" +
      "      }\n" +
      "    } else {\n" +
      "      this.logout();\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  // HTTP Headers\n" +
      "  getAuthHeaders(): HttpHeaders {\n" +
      "    const token = this.getToken();\n" +
      "    return new HttpHeaders({\n" +
      "      'Authorization': `Bearer ${token}`,\n" +
      "      'Content-Type': 'application/json'\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**JWT Interceptor for Automatic Token Attachment:**\n" +
      "```typescript\n" +
      "// jwt.interceptor.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';\n" +
      "import { Observable, throwError, BehaviorSubject } from 'rxjs';\n" +
      "import { catchError, filter, take, switchMap } from 'rxjs/operators';\n" +
      "import { JWTService } from './jwt.service';\n" +
      "\n" +
      "@Injectable()\n" +
      "export class JWTInterceptor implements HttpInterceptor {\n" +
      "  private isRefreshing = false;\n" +
      "  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);\n" +
      "\n" +
      "  constructor(private jwtService: JWTService) {}\n" +
      "\n" +
      "  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n" +
      "    // Add token to request if available\n" +
      "    if (this.jwtService.isTokenValid()) {\n" +
      "      request = this.addTokenToRequest(request);\n" +
      "    }\n" +
      "\n" +
      "    return next.handle(request).pipe(\n" +
      "      catchError(error => {\n" +
      "        if (error instanceof HttpErrorResponse && error.status === 401) {\n" +
      "          return this.handle401Error(request, next);\n" +
      "        }\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  private addTokenToRequest(request: HttpRequest<any>): HttpRequest<any> {\n" +
      "    const token = this.jwtService.getToken();\n" +
      "    if (token) {\n" +
      "      return request.clone({\n" +
      "        setHeaders: {\n" +
      "          Authorization: `Bearer ${token}`\n" +
      "        }\n" +
      "      });\n" +
      "    }\n" +
      "    return request;\n" +
      "  }\n" +
      "\n" +
      "  private handle401Error(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n" +
      "    if (!this.isRefreshing) {\n" +
      "      this.isRefreshing = true;\n" +
      "      this.refreshTokenSubject.next(null);\n" +
      "\n" +
      "      return this.jwtService.refreshToken().pipe(\n" +
      "        switchMap((response: any) => {\n" +
      "          this.isRefreshing = false;\n" +
      "          this.refreshTokenSubject.next(response.access_token);\n" +
      "          return next.handle(this.addTokenToRequest(request));\n" +
      "        }),\n" +
      "        catchError((error) => {\n" +
      "          this.isRefreshing = false;\n" +
      "          this.jwtService.logout();\n" +
      "          return throwError(error);\n" +
      "        })\n" +
      "      );\n" +
      "    }\n" +
      "\n" +
      "    return this.refreshTokenSubject.pipe(\n" +
      "      filter(token => token !== null),\n" +
      "      take(1),\n" +
      "      switchMap(() => next.handle(this.addTokenToRequest(request)))\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**JWT Guard Implementation:**\n" +
      "```typescript\n" +
      "// jwt.guard.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\n" +
      "import { JWTService } from './jwt.service';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class JWTGuard implements CanActivate {\n" +
      "  constructor(\n" +
      "    private jwtService: JWTService,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "\n" +
      "  canActivate(\n" +
      "    route: ActivatedRouteSnapshot,\n" +
      "    state: RouterStateSnapshot\n" +
      "  ): boolean {\n" +
      "    if (this.jwtService.isTokenValid()) {\n" +
      "      return true;\n" +
      "    }\n" +
      "\n" +
      "    // Token is invalid or expired\n" +
      "    this.jwtService.logout();\n" +
      "    this.router.navigate(['/login'], {\n" +
      "      queryParams: { returnUrl: state.url }\n" +
      "    });\n" +
      "    return false;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**JWT Token Benefits:**\n" +
      "- **Stateless**: No server-side session storage\n" +
      "- **Self-contained**: Contains user information\n" +
      "- **Secure**: Cryptographically signed\n" +
      "- **Cross-domain**: Can be used across different domains\n" +
      "- **Scalable**: No server-side session management\n" +
      "- **Mobile-friendly**: Works well with mobile apps\n" +
      "- **Microservices**: Perfect for distributed systems\n\n" +
      "**Security Considerations:**\n" +
      "- Store tokens securely (httpOnly cookies preferred)\n" +
      "- Use HTTPS in production\n" +
      "- Implement token refresh mechanism\n" +
      "- Set appropriate expiration times\n" +
      "- Validate tokens on server-side\n" +
      "- Handle token expiration gracefully\n" +
      "- Use secure token storage (avoid localStorage for sensitive apps)",
    category: "Security",
    difficulty: "intermediate",
    tags: ["JWT", "authentication", "tokens", "security", "interceptor", "guard"],
  },
  {
    id: 196,
    question: "How to Mock or Fake an API for JWT Authentication?",
    answer:
      "Mocking APIs for JWT authentication is essential for development, testing, and demos. There are several approaches to create fake APIs that simulate real authentication behavior.\n\n" +
      "**1. JSON Server with Custom Routes:**\n" +
      "```json\n" +
      "// db.json\n" +
      "{\n" +
      '  "users": [\n' +
      "    {\n" +
      '      "id": 1,\n' +
      '      "username": "admin",\n' +
      '      "password": "admin123",\n' +
      '      "email": "admin@example.com",\n' +
      '      "role": "admin",\n' +
      '      "permissions": ["read:users", "write:users", "delete:users"]\n' +
      "    },\n" +
      "    {\n" +
      '      "id": 2,\n' +
      '      "username": "user",\n' +
      '      "password": "user123",\n' +
      '      "email": "user@example.com",\n' +
      '      "role": "user",\n' +
      '      "permissions": ["read:profile"]\n' +
      "    }\n" +
      "  ],\n" +
      '  "tokens": []\n' +
      "}\n" +
      "```\n\n" +
      "```javascript\n" +
      "// server.js (JSON Server with custom routes)\n" +
      "const jsonServer = require('json-server');\n" +
      "const jwt = require('jsonwebtoken');\n" +
      "const server = jsonServer.create();\n" +
      "const router = jsonServer.router('db.json');\n" +
      "const middlewares = jsonServer.defaults();\n" +
      "\n" +
      "const SECRET_KEY = 'your-secret-key';\n" +
      "\n" +
      "server.use(middlewares);\n" +
      "server.use(jsonServer.bodyParser);\n" +
      "\n" +
      "// Mock JWT Authentication Routes\n" +
      "server.post('/api/auth/login', (req, res) => {\n" +
      "  const { username, password } = req.body;\n" +
      "  const db = router.db;\n" +
      "  const user = db.get('users').find({ username, password }).value();\n" +
      "\n" +
      "  if (user) {\n" +
      "    const payload = {\n" +
      "      sub: user.id.toString(),\n" +
      "      username: user.username,\n" +
      "      role: user.role,\n" +
      "      permissions: user.permissions,\n" +
      "      iat: Math.floor(Date.now() / 1000),\n" +
      "      exp: Math.floor(Date.now() / 1000) + (60 * 60) // 1 hour\n" +
      "    };\n" +
      "\n" +
      "    const accessToken = jwt.sign(payload, SECRET_KEY);\n" +
      "    const refreshToken = jwt.sign({ sub: user.id }, SECRET_KEY, { expiresIn: '7d' });\n" +
      "\n" +
      "    res.json({\n" +
      "      access_token: accessToken,\n" +
      "      refresh_token: refreshToken,\n" +
      "      token_type: 'Bearer',\n" +
      "      expires_in: 3600,\n" +
      "      user: {\n" +
      "        id: user.id,\n" +
      "        username: user.username,\n" +
      "        email: user.email,\n" +
      "        role: user.role\n" +
      "      }\n" +
      "    });\n" +
      "  } else {\n" +
      "    res.status(401).json({ error: 'Invalid credentials' });\n" +
      "  }\n" +
      "});\n" +
      "\n" +
      "server.post('/api/auth/refresh', (req, res) => {\n" +
      "  const { refresh_token } = req.body;\n" +
      "  \n" +
      "  try {\n" +
      "    const decoded = jwt.verify(refresh_token, SECRET_KEY);\n" +
      "    const db = router.db;\n" +
      "    const user = db.get('users').find({ id: parseInt(decoded.sub) }).value();\n" +
      "\n" +
      "    if (user) {\n" +
      "      const payload = {\n" +
      "        sub: user.id.toString(),\n" +
      "        username: user.username,\n" +
      "        role: user.role,\n" +
      "        permissions: user.permissions,\n" +
      "        iat: Math.floor(Date.now() / 1000),\n" +
      "        exp: Math.floor(Date.now() / 1000) + (60 * 60)\n" +
      "      };\n" +
      "\n" +
      "      const accessToken = jwt.sign(payload, SECRET_KEY);\n" +
      "\n" +
      "      res.json({\n" +
      "        access_token: accessToken,\n" +
      "        token_type: 'Bearer',\n" +
      "        expires_in: 3600\n" +
      "      });\n" +
      "    } else {\n" +
      "      res.status(401).json({ error: 'Invalid refresh token' });\n" +
      "    }\n" +
      "  } catch (error) {\n" +
      "    res.status(401).json({ error: 'Invalid refresh token' });\n" +
      "  }\n" +
      "});\n" +
      "\n" +
      "server.post('/api/auth/register', (req, res) => {\n" +
      "  const { username, email, password } = req.body;\n" +
      "  const db = router.db;\n" +
      "  \n" +
      "  // Check if user already exists\n" +
      "  const existingUser = db.get('users').find({ username }).value();\n" +
      "  if (existingUser) {\n" +
      "    return res.status(400).json({ error: 'Username already exists' });\n" +
      "  }\n" +
      "\n" +
      "  const newUser = {\n" +
      "    id: Date.now(),\n" +
      "    username,\n" +
      "    email,\n" +
      "    password,\n" +
      "    role: 'user',\n" +
      "    permissions: ['read:profile']\n" +
      "  };\n" +
      "\n" +
      "  db.get('users').push(newUser).write();\n" +
      "\n" +
      "  // Generate tokens\n" +
      "  const payload = {\n" +
      "    sub: newUser.id.toString(),\n" +
      "    username: newUser.username,\n" +
      "    role: newUser.role,\n" +
      "    permissions: newUser.permissions,\n" +
      "    iat: Math.floor(Date.now() / 1000),\n" +
      "    exp: Math.floor(Date.now() / 1000) + (60 * 60)\n" +
      "  };\n" +
      "\n" +
      "  const accessToken = jwt.sign(payload, SECRET_KEY);\n" +
      "  const refreshToken = jwt.sign({ sub: newUser.id }, SECRET_KEY, { expiresIn: '7d' });\n" +
      "\n" +
      "  res.json({\n" +
      "    access_token: accessToken,\n" +
      "    refresh_token: refreshToken,\n" +
      "    token_type: 'Bearer',\n" +
      "    expires_in: 3600,\n" +
      "    user: {\n" +
      "      id: newUser.id,\n" +
      "      username: newUser.username,\n" +
      "      email: newUser.email,\n" +
      "      role: newUser.role\n" +
      "    }\n" +
      "  });\n" +
      "});\n" +
      "\n" +
      "// Protected route middleware\n" +
      "server.use('/api/protected', (req, res, next) => {\n" +
      "  const authHeader = req.headers.authorization;\n" +
      "  \n" +
      "  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n" +
      "    return res.status(401).json({ error: 'No token provided' });\n" +
      "  }\n" +
      "\n" +
      "  const token = authHeader.substring(7);\n" +
      "  \n" +
      "  try {\n" +
      "    const decoded = jwt.verify(token, SECRET_KEY);\n" +
      "    req.user = decoded;\n" +
      "    next();\n" +
      "  } catch (error) {\n" +
      "    res.status(401).json({ error: 'Invalid token' });\n" +
      "  }\n" +
      "});\n" +
      "\n" +
      "server.use('/api', router);\n" +
      "server.listen(3000, () => {\n" +
      "  console.log('Mock API Server running on http://localhost:3000');\n" +
      "});\n" +
      "```\n\n" +
      "**2. Angular HTTP Interceptor for Mocking:**\n" +
      "```typescript\n" +
      "// mock-api.interceptor.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';\n" +
      "import { Observable, of } from 'rxjs';\n" +
      "import { delay } from 'rxjs/operators';\n" +
      "\n" +
      "@Injectable()\n" +
      "export class MockApiInterceptor implements HttpInterceptor {\n" +
      "  private users = [\n" +
      "    { id: 1, username: 'admin', password: 'admin123', email: 'admin@example.com', role: 'admin' },\n" +
      "    { id: 2, username: 'user', password: 'user123', email: 'user@example.com', role: 'user' }\n" +
      "  ];\n" +
      "\n" +
      "  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n" +
      "    // Mock login endpoint\n" +
      "    if (req.url.includes('/api/auth/login') && req.method === 'POST') {\n" +
      "      const { username, password } = req.body;\n" +
      "      const user = this.users.find(u => u.username === username && u.password === password);\n" +
      "      \n" +
      "      if (user) {\n" +
      "        const mockToken = this.generateMockToken(user);\n" +
      "        return of({\n" +
      "          body: {\n" +
      "            access_token: mockToken,\n" +
      "            refresh_token: 'mock-refresh-token',\n" +
      "            token_type: 'Bearer',\n" +
      "            expires_in: 3600,\n" +
      "            user: {\n" +
      "              id: user.id,\n" +
      "              username: user.username,\n" +
      "              email: user.email,\n" +
      "              role: user.role\n" +
      "            }\n" +
      "          },\n" +
      "          status: 200,\n" +
      "          statusText: 'OK'\n" +
      "        } as any).pipe(delay(500));\n" +
      "      } else {\n" +
      "        return of({\n" +
      "          body: { error: 'Invalid credentials' },\n" +
      "          status: 401,\n" +
      "          statusText: 'Unauthorized'\n" +
      "        } as any).pipe(delay(500));\n" +
      "      }\n" +
      "    }\n" +
      "\n" +
      "    // Mock protected endpoints\n" +
      "    if (req.url.includes('/api/protected') && req.headers.get('Authorization')) {\n" +
      "      return of({\n" +
      "        body: { message: 'Protected data', timestamp: new Date().toISOString() },\n" +
      "        status: 200,\n" +
      "        statusText: 'OK'\n" +
      "      } as any).pipe(delay(300));\n" +
      "    }\n" +
      "\n" +
      "    return next.handle(req);\n" +
      "  }\n" +
      "\n" +
      "  private generateMockToken(user: any): string {\n" +
      "    const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));\n" +
      "    const payload = btoa(JSON.stringify({\n" +
      "      sub: user.id.toString(),\n" +
      "      username: user.username,\n" +
      "      role: user.role,\n" +
      "      iat: Math.floor(Date.now() / 1000),\n" +
      "      exp: Math.floor(Date.now() / 1000) + 3600\n" +
      "    }));\n" +
      "    const signature = btoa('mock-signature');\n" +
      "    \n" +
      "    return `${header}.${payload}.${signature}`;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. MSW (Mock Service Worker):**\n" +
      "```typescript\n" +
      "// mocks/handlers.ts\n" +
      "import { rest } from 'msw';\n" +
      "\n" +
      "const users = [\n" +
      "  { id: 1, username: 'admin', password: 'admin123', email: 'admin@example.com', role: 'admin' },\n" +
      "  { id: 2, username: 'user', password: 'user123', email: 'user@example.com', role: 'user' }\n" +
      "];\n" +
      "\n" +
      "export const handlers = [\n" +
      "  // Login endpoint\n" +
      "  rest.post('/api/auth/login', (req, res, ctx) => {\n" +
      "    const { username, password } = req.body as any;\n" +
      "    const user = users.find(u => u.username === username && u.password === password);\n" +
      "    \n" +
      "    if (user) {\n" +
      "      const token = generateMockJWT(user);\n" +
      "      return res(\n" +
      "        ctx.json({\n" +
      "          access_token: token,\n" +
      "          refresh_token: 'mock-refresh-token',\n" +
      "          token_type: 'Bearer',\n" +
      "          expires_in: 3600,\n" +
      "          user: {\n" +
      "            id: user.id,\n" +
      "            username: user.username,\n" +
      "            email: user.email,\n" +
      "            role: user.role\n" +
      "          }\n" +
      "        })\n" +
      "      );\n" +
      "    }\n" +
      "    \n" +
      "    return res(\n" +
      "      ctx.status(401),\n" +
      "      ctx.json({ error: 'Invalid credentials' })\n" +
      "    );\n" +
      "  }),\n" +
      "\n" +
      "  // Protected endpoint\n" +
      "  rest.get('/api/protected/data', (req, res, ctx) => {\n" +
      "    const authHeader = req.headers.get('Authorization');\n" +
      "    \n" +
      "    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n" +
      "      return res(\n" +
      "        ctx.status(401),\n" +
      "        ctx.json({ error: 'No token provided' })\n" +
      "      );\n" +
      "    }\n" +
      "    \n" +
      "    return res(\n" +
      "      ctx.json({\n" +
      "        message: 'Protected data',\n" +
      "        timestamp: new Date().toISOString(),\n" +
      "        data: ['item1', 'item2', 'item3']\n" +
      "      })\n" +
      "    );\n" +
      "  }),\n" +
      "\n" +
      "  // Refresh token endpoint\n" +
      "  rest.post('/api/auth/refresh', (req, res, ctx) => {\n" +
      "    const { refresh_token } = req.body as any;\n" +
      "    \n" +
      "    if (refresh_token === 'mock-refresh-token') {\n" +
      "      const newToken = generateMockJWT({ id: 1, username: 'admin', role: 'admin' });\n" +
      "      return res(\n" +
      "        ctx.json({\n" +
      "          access_token: newToken,\n" +
      "          token_type: 'Bearer',\n" +
      "          expires_in: 3600\n" +
      "        })\n" +
      "      );\n" +
      "    }\n" +
      "    \n" +
      "    return res(\n" +
      "      ctx.status(401),\n" +
      "      ctx.json({ error: 'Invalid refresh token' })\n" +
      "    );\n" +
      "  })\n" +
      "];\n" +
      "\n" +
      "function generateMockJWT(user: any): string {\n" +
      "  const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));\n" +
      "  const payload = btoa(JSON.stringify({\n" +
      "    sub: user.id.toString(),\n" +
      "    username: user.username,\n" +
      "    role: user.role,\n" +
      "    iat: Math.floor(Date.now() / 1000),\n" +
      "    exp: Math.floor(Date.now() / 1000) + 3600\n" +
      "  }));\n" +
      "  const signature = btoa('mock-signature');\n" +
      "  \n" +
      "  return `${header}.${payload}.${signature}`;\n" +
      "}\n" +
      "```\n\n" +
      "**4. Angular Service with Mock Data:**\n" +
      "```typescript\n" +
      "// mock-auth.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { Observable, of, throwError } from 'rxjs';\n" +
      "import { delay } from 'rxjs/operators';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class MockAuthService {\n" +
      "  private users = [\n" +
      "    { id: 1, username: 'admin', password: 'admin123', email: 'admin@example.com', role: 'admin' },\n" +
      "    { id: 2, username: 'user', password: 'user123', email: 'user@example.com', role: 'user' }\n" +
      "  ];\n" +
      "\n" +
      "  login(credentials: { username: string; password: string }): Observable<any> {\n" +
      "    const user = this.users.find(u => \n" +
      "      u.username === credentials.username && \n" +
      "      u.password === credentials.password\n" +
      "    );\n" +
      "\n" +
      "    if (user) {\n" +
      "      const token = this.generateMockToken(user);\n" +
      "      return of({\n" +
      "        access_token: token,\n" +
      "        refresh_token: 'mock-refresh-token',\n" +
      "        token_type: 'Bearer',\n" +
      "        expires_in: 3600,\n" +
      "        user: {\n" +
      "          id: user.id,\n" +
      "          username: user.username,\n" +
      "          email: user.email,\n" +
      "          role: user.role\n" +
      "        }\n" +
      "      }).pipe(delay(1000)); // Simulate network delay\n" +
      "    }\n" +
      "\n" +
      "    return throwError({ error: 'Invalid credentials' });\n" +
      "  }\n" +
      "\n" +
      "  refreshToken(refreshToken: string): Observable<any> {\n" +
      "    if (refreshToken === 'mock-refresh-token') {\n" +
      "      const user = this.users[0]; // Mock user\n" +
      "      const token = this.generateMockToken(user);\n" +
      "      return of({\n" +
      "        access_token: token,\n" +
      "        token_type: 'Bearer',\n" +
      "        expires_in: 3600\n" +
      "      }).pipe(delay(500));\n" +
      "    }\n" +
      "\n" +
      "    return throwError({ error: 'Invalid refresh token' });\n" +
      "  }\n" +
      "\n" +
      "  private generateMockToken(user: any): string {\n" +
      "    const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));\n" +
      "    const payload = btoa(JSON.stringify({\n" +
      "      sub: user.id.toString(),\n" +
      "      username: user.username,\n" +
      "      role: user.role,\n" +
      "      iat: Math.floor(Date.now() / 1000),\n" +
      "      exp: Math.floor(Date.now() / 1000) + 3600\n" +
      "    }));\n" +
      "    const signature = btoa('mock-signature');\n" +
      "    \n" +
      "    return `${header}.${payload}.${signature}`;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**5. Environment-based Mocking:**\n" +
      "```typescript\n" +
      "// environment.ts\n" +
      "export const environment = {\n" +
      "  production: false,\n" +
      "  apiUrl: 'http://localhost:3000/api',\n" +
      "  useMockApi: true\n" +
      "};\n" +
      "\n" +
      "// auth.service.ts\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class AuthService {\n" +
      "  constructor(\n" +
      "    private http: HttpClient,\n" +
      "    private mockAuthService: MockAuthService\n" +
      "  ) {}\n" +
      "\n" +
      "  login(credentials: LoginCredentials): Observable<AuthResponse> {\n" +
      "    if (environment.useMockApi) {\n" +
      "      return this.mockAuthService.login(credentials);\n" +
      "    }\n" +
      "    \n" +
      "    return this.http.post<AuthResponse>(`${environment.apiUrl}/auth/login`, credentials);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Benefits of Mocking:**\n" +
      "- **Development**: Work without backend dependencies\n" +
      "- **Testing**: Consistent test data and scenarios\n" +
      "- **Demo**: Show functionality without real API\n" +
      "- **Offline**: Continue development without network\n" +
      "- **Performance**: Faster response times\n" +
      "- **Reliability**: No external API failures\n" +
      "- **Flexibility**: Easy to modify responses\n" +
      "- **Security**: No real credentials needed\n\n" +
      "**Best Practices:**\n" +
      "- Use realistic data structures\n" +
      "- Simulate network delays\n" +
      "- Handle error scenarios\n" +
      "- Make tokens expire realistically\n" +
      "- Support different user roles\n" +
      "- Include refresh token logic\n" +
      "- Validate token format\n" +
      "- Test edge cases",
    category: "Development",
    difficulty: "intermediate",
    tags: ["mocking", "API", "JWT", "testing", "development", "JSON-server", "MSW"],
  },
  {
    id: 197,
    question: "How to implement the Authentication with JWT in Angular?",
    answer:
      "Implementing JWT authentication in Angular involves creating a comprehensive authentication system with services, guards, interceptors, and proper token management. Here's a complete implementation:\n\n" +
      "**1. Authentication Service:**\n" +
      "```typescript\n" +
      "// auth.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpClient, HttpHeaders } from '@angular/common/http';\n" +
      "import { BehaviorSubject, Observable, throwError } from 'rxjs';\n" +
      "import { tap, catchError, map } from 'rxjs/operators';\n" +
      "import { Router } from '@angular/router';\n" +
      "\n" +
      "export interface User {\n" +
      "  id: string;\n" +
      "  username: string;\n" +
      "  email: string;\n" +
      "  role: string;\n" +
      "  permissions: string[];\n" +
      "}\n" +
      "\n" +
      "export interface LoginCredentials {\n" +
      "  username: string;\n" +
      "  password: string;\n" +
      "}\n" +
      "\n" +
      "export interface AuthResponse {\n" +
      "  access_token: string;\n" +
      "  refresh_token: string;\n" +
      "  token_type: string;\n" +
      "  expires_in: number;\n" +
      "  user: User;\n" +
      "}\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class AuthService {\n" +
      "  private readonly API_URL = 'http://localhost:3000/api';\n" +
      "  private readonly TOKEN_KEY = 'access_token';\n" +
      "  private readonly REFRESH_TOKEN_KEY = 'refresh_token';\n" +
      "  private readonly USER_KEY = 'user_data';\n" +
      "\n" +
      "  private currentUserSubject = new BehaviorSubject<User | null>(null);\n" +
      "  public currentUser$ = this.currentUserSubject.asObservable();\n" +
      "\n" +
      "  private isAuthenticatedSubject = new BehaviorSubject<boolean>(false);\n" +
      "  public isAuthenticated$ = this.isAuthenticatedSubject.asObservable();\n" +
      "\n" +
      "  constructor(\n" +
      "    private http: HttpClient,\n" +
      "    private router: Router\n" +
      "  ) {\n" +
      "    this.initializeAuth();\n" +
      "  }\n" +
      "\n" +
      "  // Login\n" +
      "  login(credentials: LoginCredentials): Observable<AuthResponse> {\n" +
      "    return this.http.post<AuthResponse>(`${this.API_URL}/auth/login`, credentials)\n" +
      "      .pipe(\n" +
      "        tap(response => {\n" +
      "          this.setTokens(response);\n" +
      "          this.setUser(response.user);\n" +
      "          this.isAuthenticatedSubject.next(true);\n" +
      "        }),\n" +
      "        catchError(error => {\n" +
      "          console.error('Login failed:', error);\n" +
      "          return throwError(error);\n" +
      "        })\n" +
      "      );\n" +
      "  }\n" +
      "\n" +
      "  // Register\n" +
      "  register(userData: { username: string; email: string; password: string }): Observable<AuthResponse> {\n" +
      "    return this.http.post<AuthResponse>(`${this.API_URL}/auth/register`, userData)\n" +
      "      .pipe(\n" +
      "        tap(response => {\n" +
      "          this.setTokens(response);\n" +
      "          this.setUser(response.user);\n" +
      "          this.isAuthenticatedSubject.next(true);\n" +
      "        }),\n" +
      "        catchError(error => {\n" +
      "          console.error('Registration failed:', error);\n" +
      "          return throwError(error);\n" +
      "        })\n" +
      "      );\n" +
      "  }\n" +
      "\n" +
      "  // Logout\n" +
      "  logout(): void {\n" +
      "    this.removeTokens();\n" +
      "    this.removeUser();\n" +
      "    this.isAuthenticatedSubject.next(false);\n" +
      "    this.currentUserSubject.next(null);\n" +
      "    this.router.navigate(['/login']);\n" +
      "  }\n" +
      "\n" +
      "  // Refresh Token\n" +
      "  refreshToken(): Observable<AuthResponse> {\n" +
      "    const refreshToken = this.getRefreshToken();\n" +
      "    if (!refreshToken) {\n" +
      "      this.logout();\n" +
      "      return throwError('No refresh token available');\n" +
      "    }\n" +
      "\n" +
      "    return this.http.post<AuthResponse>(`${this.API_URL}/auth/refresh`, {\n" +
      "      refresh_token: refreshToken\n" +
      "    }).pipe(\n" +
      "      tap(response => {\n" +
      "        this.setTokens(response);\n" +
      "      }),\n" +
      "      catchError(error => {\n" +
      "        this.logout();\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  // Token Management\n" +
      "  getToken(): string | null {\n" +
      "    return localStorage.getItem(this.TOKEN_KEY);\n" +
      "  }\n" +
      "\n" +
      "  getRefreshToken(): string | null {\n" +
      "    return localStorage.getItem(this.REFRESH_TOKEN_KEY);\n" +
      "  }\n" +
      "\n" +
      "  isTokenValid(): boolean {\n" +
      "    const token = this.getToken();\n" +
      "    if (!token) return false;\n" +
      "\n" +
      "    try {\n" +
      "      const payload = this.decodeToken(token);\n" +
      "      const currentTime = Math.floor(Date.now() / 1000);\n" +
      "      return payload.exp > currentTime;\n" +
      "    } catch {\n" +
      "      return false;\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  isTokenExpired(): boolean {\n" +
      "    return !this.isTokenValid();\n" +
      "  }\n" +
      "\n" +
      "  // User Management\n" +
      "  getCurrentUser(): User | null {\n" +
      "    return this.currentUserSubject.value;\n" +
      "  }\n" +
      "\n" +
      "  hasRole(role: string): boolean {\n" +
      "    const user = this.getCurrentUser();\n" +
      "    return user ? user.role === role : false;\n" +
      "  }\n" +
      "\n" +
      "  hasPermission(permission: string): boolean {\n" +
      "    const user = this.getCurrentUser();\n" +
      "    return user ? user.permissions.includes(permission) : false;\n" +
      "  }\n" +
      "\n" +
      "  // Private Methods\n" +
      "  private setTokens(response: AuthResponse): void {\n" +
      "    localStorage.setItem(this.TOKEN_KEY, response.access_token);\n" +
      "    localStorage.setItem(this.REFRESH_TOKEN_KEY, response.refresh_token);\n" +
      "  }\n" +
      "\n" +
      "  private setUser(user: User): void {\n" +
      "    localStorage.setItem(this.USER_KEY, JSON.stringify(user));\n" +
      "    this.currentUserSubject.next(user);\n" +
      "  }\n" +
      "\n" +
      "  private removeTokens(): void {\n" +
      "    localStorage.removeItem(this.TOKEN_KEY);\n" +
      "    localStorage.removeItem(this.REFRESH_TOKEN_KEY);\n" +
      "  }\n" +
      "\n" +
      "  private removeUser(): void {\n" +
      "    localStorage.removeItem(this.USER_KEY);\n" +
      "  }\n" +
      "\n" +
      "  private initializeAuth(): void {\n" +
      "    const token = this.getToken();\n" +
      "    const userData = localStorage.getItem(this.USER_KEY);\n" +
      "    \n" +
      "    if (token && this.isTokenValid() && userData) {\n" +
      "      try {\n" +
      "        const user = JSON.parse(userData);\n" +
      "        this.currentUserSubject.next(user);\n" +
      "        this.isAuthenticatedSubject.next(true);\n" +
      "      } catch {\n" +
      "        this.logout();\n" +
      "      }\n" +
      "    } else {\n" +
      "      this.logout();\n" +
      "    }\n" +
      "  }\n" +
      "\n" +
      "  private decodeToken(token: string): any {\n" +
      "    try {\n" +
      "      const base64Url = token.split('.')[1];\n" +
      "      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n" +
      "      const jsonPayload = decodeURIComponent(\n" +
      "        atob(base64)\n" +
      "          .split('')\n" +
      "          .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n" +
      "          .join('')\n" +
      "      );\n" +
      "      return JSON.parse(jsonPayload);\n" +
      "    } catch (error) {\n" +
      "      throw new Error('Invalid token format');\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**2. HTTP Interceptor:**\n" +
      "```typescript\n" +
      "// auth.interceptor.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';\n" +
      "import { Observable, throwError, BehaviorSubject } from 'rxjs';\n" +
      "import { catchError, filter, take, switchMap } from 'rxjs/operators';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "@Injectable()\n" +
      "export class AuthInterceptor implements HttpInterceptor {\n" +
      "  private isRefreshing = false;\n" +
      "  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);\n" +
      "\n" +
      "  constructor(private authService: AuthService) {}\n" +
      "\n" +
      "  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n" +
      "    // Add token to request if available\n" +
      "    if (this.authService.isTokenValid()) {\n" +
      "      request = this.addTokenToRequest(request);\n" +
      "    }\n" +
      "\n" +
      "    return next.handle(request).pipe(\n" +
      "      catchError(error => {\n" +
      "        if (error instanceof HttpErrorResponse && error.status === 401) {\n" +
      "          return this.handle401Error(request, next);\n" +
      "        }\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  private addTokenToRequest(request: HttpRequest<any>): HttpRequest<any> {\n" +
      "    const token = this.authService.getToken();\n" +
      "    if (token) {\n" +
      "      return request.clone({\n" +
      "        setHeaders: {\n" +
      "          Authorization: `Bearer ${token}`\n" +
      "        }\n" +
      "      });\n" +
      "    }\n" +
      "    return request;\n" +
      "  }\n" +
      "\n" +
      "  private handle401Error(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n" +
      "    if (!this.isRefreshing) {\n" +
      "      this.isRefreshing = true;\n" +
      "      this.refreshTokenSubject.next(null);\n" +
      "\n" +
      "      return this.authService.refreshToken().pipe(\n" +
      "        switchMap((response: any) => {\n" +
      "          this.isRefreshing = false;\n" +
      "          this.refreshTokenSubject.next(response.access_token);\n" +
      "          return next.handle(this.addTokenToRequest(request));\n" +
      "        }),\n" +
      "        catchError((error) => {\n" +
      "          this.isRefreshing = false;\n" +
      "          this.authService.logout();\n" +
      "          return throwError(error);\n" +
      "        })\n" +
      "      );\n" +
      "    }\n" +
      "\n" +
      "    return this.refreshTokenSubject.pipe(\n" +
      "      filter(token => token !== null),\n" +
      "      take(1),\n" +
      "      switchMap(() => next.handle(this.addTokenToRequest(request)))\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. Auth Guard:**\n" +
      "```typescript\n" +
      "// auth.guard.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\n" +
      "import { Observable } from 'rxjs';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class AuthGuard implements CanActivate {\n" +
      "  constructor(\n" +
      "    private authService: AuthService,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "\n" +
      "  canActivate(\n" +
      "    route: ActivatedRouteSnapshot,\n" +
      "    state: RouterStateSnapshot\n" +
      "  ): boolean {\n" +
      "    if (this.authService.isTokenValid()) {\n" +
      "      return true;\n" +
      "    }\n" +
      "\n" +
      "    // Token is invalid or expired\n" +
      "    this.authService.logout();\n" +
      "    this.router.navigate(['/login'], {\n" +
      "      queryParams: { returnUrl: state.url }\n" +
      "    });\n" +
      "    return false;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**4. Role Guard:**\n" +
      "```typescript\n" +
      "// role.guard.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class RoleGuard implements CanActivate {\n" +
      "  constructor(\n" +
      "    private authService: AuthService,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "\n" +
      "  canActivate(\n" +
      "    route: ActivatedRouteSnapshot,\n" +
      "    state: RouterStateSnapshot\n" +
      "  ): boolean {\n" +
      "    const expectedRole = route.data['expectedRole'];\n" +
      "    const user = this.authService.getCurrentUser();\n" +
      "\n" +
      "    if (!user || !this.authService.hasRole(expectedRole)) {\n" +
      "      this.router.navigate(['/unauthorized']);\n" +
      "      return false;\n" +
      "    }\n" +
      "\n" +
      "    return true;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**5. Login Component:**\n" +
      "```typescript\n" +
      "// login.component.ts\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { FormBuilder, FormGroup, Validators } from '@angular/forms';\n" +
      "import { Router, ActivatedRoute } from '@angular/router';\n" +
      "import { AuthService, LoginCredentials } from './auth.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-login',\n" +
      "  template: `\n" +
      '    <div class="login-container">\n' +
      '      <form [formGroup]="loginForm" (ngSubmit)="onSubmit()">\n' +
      "        <h2>Login</h2>\n" +
      "        \n" +
      '        <div class="form-group">\n' +
      '          <label for="username">Username</label>\n' +
      "          <input \n" +
      '            id="username" \n' +
      '            type="text" \n' +
      '            formControlName="username"\n' +
      "            [class.error]=\"loginForm.get('username')?.invalid && loginForm.get('username')?.touched\"\n" +
      "          >\n" +
      "          <div *ngIf=\"loginForm.get('username')?.invalid && loginForm.get('username')?.touched\" class=\"error-message\">\n" +
      "            Username is required\n" +
      "          </div>\n" +
      "        </div>\n" +
      "\n" +
      '        <div class="form-group">\n' +
      '          <label for="password">Password</label>\n' +
      "          <input \n" +
      '            id="password" \n' +
      '            type="password" \n' +
      '            formControlName="password"\n' +
      "            [class.error]=\"loginForm.get('password')?.invalid && loginForm.get('password')?.touched\"\n" +
      "          >\n" +
      "          <div *ngIf=\"loginForm.get('password')?.invalid && loginForm.get('password')?.touched\" class=\"error-message\">\n" +
      "            Password is required\n" +
      "          </div>\n" +
      "        </div>\n" +
      "\n" +
      '        <button type="submit" [disabled]="loginForm.invalid || isLoading">\n' +
      "          {{ isLoading ? 'Logging in...' : 'Login' }}\n" +
      "        </button>\n" +
      "\n" +
      '        <div *ngIf="errorMessage" class="error-message">\n' +
      "          {{ errorMessage }}\n" +
      "        </div>\n" +
      "      </form>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styleUrls: ['./login.component.css']\n" +
      "})\n" +
      "export class LoginComponent implements OnInit {\n" +
      "  loginForm: FormGroup;\n" +
      "  isLoading = false;\n" +
      "  errorMessage = '';\n" +
      "  returnUrl = '/dashboard';\n" +
      "\n" +
      "  constructor(\n" +
      "    private formBuilder: FormBuilder,\n" +
      "    private authService: AuthService,\n" +
      "    private router: Router,\n" +
      "    private route: ActivatedRoute\n" +
      "  ) {\n" +
      "    this.loginForm = this.formBuilder.group({\n" +
      "      username: ['', Validators.required],\n" +
      "      password: ['', Validators.required]\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  ngOnInit(): void {\n" +
      "    // Get return URL from route parameters or default to '/dashboard'\n" +
      "    this.returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/dashboard';\n" +
      "  }\n" +
      "\n" +
      "  onSubmit(): void {\n" +
      "    if (this.loginForm.valid) {\n" +
      "      this.isLoading = true;\n" +
      "      this.errorMessage = '';\n" +
      "\n" +
      "      const credentials: LoginCredentials = this.loginForm.value;\n" +
      "\n" +
      "      this.authService.login(credentials).subscribe({\n" +
      "        next: (response) => {\n" +
      "          this.isLoading = false;\n" +
      "          this.router.navigate([this.returnUrl]);\n" +
      "        },\n" +
      "        error: (error) => {\n" +
      "          this.isLoading = false;\n" +
      "          this.errorMessage = error.error?.message || 'Login failed';\n" +
      "        }\n" +
      "      });\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**6. App Module Configuration:**\n" +
      "```typescript\n" +
      "// app.module.ts\n" +
      "import { NgModule } from '@angular/core';\n" +
      "import { BrowserModule } from '@angular/platform-browser';\n" +
      "import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';\n" +
      "import { ReactiveFormsModule } from '@angular/forms';\n" +
      "import { RouterModule, Routes } from '@angular/router';\n" +
      "\n" +
      "import { AppComponent } from './app.component';\n" +
      "import { LoginComponent } from './login/login.component';\n" +
      "import { DashboardComponent } from './dashboard/dashboard.component';\n" +
      "import { AuthService } from './auth.service';\n" +
      "import { AuthInterceptor } from './auth.interceptor';\n" +
      "import { AuthGuard } from './auth.guard';\n" +
      "import { RoleGuard } from './role.guard';\n" +
      "\n" +
      "const routes: Routes = [\n" +
      "  { path: 'login', component: LoginComponent },\n" +
      "  { \n" +
      "    path: 'dashboard', \n" +
      "    component: DashboardComponent, \n" +
      "    canActivate: [AuthGuard] \n" +
      "  },\n" +
      "  { \n" +
      "    path: 'admin', \n" +
      "    component: AdminComponent, \n" +
      "    canActivate: [AuthGuard, RoleGuard],\n" +
      "    data: { expectedRole: 'admin' }\n" +
      "  },\n" +
      "  { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n" +
      "  { path: '**', redirectTo: '/dashboard' }\n" +
      "];\n" +
      "\n" +
      "@NgModule({\n" +
      "  declarations: [\n" +
      "    AppComponent,\n" +
      "    LoginComponent,\n" +
      "    DashboardComponent\n" +
      "  ],\n" +
      "  imports: [\n" +
      "    BrowserModule,\n" +
      "    HttpClientModule,\n" +
      "    ReactiveFormsModule,\n" +
      "    RouterModule.forRoot(routes)\n" +
      "  ],\n" +
      "  providers: [\n" +
      "    AuthService,\n" +
      "    {\n" +
      "      provide: HTTP_INTERCEPTORS,\n" +
      "      useClass: AuthInterceptor,\n" +
      "      multi: true\n" +
      "    }\n" +
      "  ],\n" +
      "  bootstrap: [AppComponent]\n" +
      "})\n" +
      "export class AppModule { }\n" +
      "```\n\n" +
      "**7. Usage in Components:**\n" +
      "```typescript\n" +
      "// dashboard.component.ts\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { AuthService, User } from '../auth.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-dashboard',\n" +
      "  template: `\n" +
      '    <div class="dashboard">\n' +
      "      <header>\n" +
      "        <h1>Welcome, {{ currentUser?.username }}!</h1>\n" +
      '        <button (click)="logout()">Logout</button>\n' +
      "      </header>\n" +
      "      \n" +
      "      <nav>\n" +
      '        <a routerLink="/profile">Profile</a>\n' +
      '        <a *ngIf="hasAdminRole" routerLink="/admin">Admin Panel</a>\n' +
      "      </nav>\n" +
      "      \n" +
      "      <main>\n" +
      "        <p>Your role: {{ currentUser?.role }}</p>\n" +
      "        <p>Permissions: {{ currentUser?.permissions?.join(', ') }}</p>\n" +
      "      </main>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class DashboardComponent implements OnInit {\n" +
      "  currentUser: User | null = null;\n" +
      "  hasAdminRole = false;\n" +
      "\n" +
      "  constructor(private authService: AuthService) {}\n" +
      "\n" +
      "  ngOnInit(): void {\n" +
      "    this.currentUser = this.authService.getCurrentUser();\n" +
      "    this.hasAdminRole = this.authService.hasRole('admin');\n" +
      "  }\n" +
      "\n" +
      "  logout(): void {\n" +
      "    this.authService.logout();\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Features:**\n" +
      "- **Automatic Token Management**: Tokens are automatically added to requests\n" +
      "- **Token Refresh**: Automatic token refresh on 401 errors\n" +
      "- **Route Protection**: Guards protect routes based on authentication\n" +
      "- **Role-Based Access**: Role guards for admin-only routes\n" +
      "- **Persistent Login**: User stays logged in across browser sessions\n" +
      "- **Error Handling**: Comprehensive error handling for auth failures\n" +
      "- **Security**: Secure token storage and validation\n" +
      "- **User Management**: Current user state management\n" +
      "- **Permission System**: Fine-grained permission checking\n" +
      "- **Logout Handling**: Clean logout with token removal",
    category: "Security",
    difficulty: "intermediate",
    tags: ["JWT", "authentication", "implementation", "service", "interceptor", "guard", "routing"],
  },
  {
    id: 198,
    question: "What is Auth Guard?",
    answer:
      "Auth Guard is a service in Angular that implements the `CanActivate` interface to control access to routes based on authentication status. It acts as a security layer that prevents unauthorized users from accessing protected routes.\n\n" +
      "**Auth Guard Implementation:**\n" +
      "```typescript\n" +
      "// auth.guard.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree } from '@angular/router';\n" +
      "import { Observable } from 'rxjs';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class AuthGuard implements CanActivate {\n" +
      "  constructor(\n" +
      "    private authService: AuthService,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "\n" +
      "  canActivate(\n" +
      "    route: ActivatedRouteSnapshot,\n" +
      "    state: RouterStateSnapshot\n" +
      "  ): boolean | UrlTree | Observable<boolean | UrlTree> | Promise<boolean | UrlTree> {\n" +
      "    \n" +
      "    // Check if user is authenticated\n" +
      "    if (this.authService.isAuthenticated()) {\n" +
      "      return true;\n" +
      "    }\n" +
      "\n" +
      "    // User is not authenticated, redirect to login\n" +
      "    this.router.navigate(['/login'], {\n" +
      "      queryParams: { returnUrl: state.url }\n" +
      "    });\n" +
      "    return false;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Advanced Auth Guard with Role-Based Access:**\n" +
      "```typescript\n" +
      "// role-auth.guard.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class RoleAuthGuard implements CanActivate {\n" +
      "  constructor(\n" +
      "    private authService: AuthService,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "\n" +
      "  canActivate(\n" +
      "    route: ActivatedRouteSnapshot,\n" +
      "    state: RouterStateSnapshot\n" +
      "  ): boolean {\n" +
      "    \n" +
      "    // First check if user is authenticated\n" +
      "    if (!this.authService.isAuthenticated()) {\n" +
      "      this.router.navigate(['/login'], {\n" +
      "        queryParams: { returnUrl: state.url }\n" +
      "      });\n" +
      "      return false;\n" +
      "    }\n" +
      "\n" +
      "    // Get required roles from route data\n" +
      "    const requiredRoles = route.data['roles'] as string[];\n" +
      "    const requiredPermissions = route.data['permissions'] as string[];\n" +
      "    \n" +
      "    if (requiredRoles && requiredRoles.length > 0) {\n" +
      "      const hasRequiredRole = requiredRoles.some(role => \n" +
      "        this.authService.hasRole(role)\n" +
      "      );\n" +
      "      \n" +
      "      if (!hasRequiredRole) {\n" +
      "        this.router.navigate(['/unauthorized']);\n" +
      "        return false;\n" +
      "      }\n" +
      "    }\n" +
      "\n" +
      "    if (requiredPermissions && requiredPermissions.length > 0) {\n" +
      "      const hasRequiredPermission = requiredPermissions.some(permission => \n" +
      "        this.authService.hasPermission(permission)\n" +
      "      );\n" +
      "      \n" +
      "      if (!hasRequiredPermission) {\n" +
      "        this.router.navigate(['/unauthorized']);\n" +
      "        return false;\n" +
      "      }\n" +
      "    }\n" +
      "\n" +
      "    return true;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Async Auth Guard for Token Validation:**\n" +
      "```typescript\n" +
      "// async-auth.guard.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { CanActivate, Router, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\n" +
      "import { Observable, of } from 'rxjs';\n" +
      "import { map, catchError } from 'rxjs/operators';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class AsyncAuthGuard implements CanActivate {\n" +
      "  constructor(\n" +
      "    private authService: AuthService,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "\n" +
      "  canActivate(\n" +
      "    route: ActivatedRouteSnapshot,\n" +
      "    state: RouterStateSnapshot\n" +
      "  ): Observable<boolean> {\n" +
      "    \n" +
      "    // If token is valid, allow access\n" +
      "    if (this.authService.isTokenValid()) {\n" +
      "      return of(true);\n" +
      "    }\n" +
      "\n" +
      "    // If token is expired, try to refresh\n" +
      "    if (this.authService.getRefreshToken()) {\n" +
      "      return this.authService.refreshToken().pipe(\n" +
      "        map(() => true),\n" +
      "        catchError(() => {\n" +
      "          this.router.navigate(['/login'], {\n" +
      "            queryParams: { returnUrl: state.url }\n" +
      "          });\n" +
      "          return of(false);\n" +
      "        })\n" +
      "      );\n" +
      "    }\n" +
      "\n" +
      "    // No valid token or refresh token, redirect to login\n" +
      "    this.router.navigate(['/login'], {\n" +
      "      queryParams: { returnUrl: state.url }\n" +
      "    });\n" +
      "    return of(false);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Route Configuration with Guards:**\n" +
      "```typescript\n" +
      "// app-routing.module.ts\n" +
      "import { NgModule } from '@angular/core';\n" +
      "import { RouterModule, Routes } from '@angular/router';\n" +
      "import { AuthGuard } from './guards/auth.guard';\n" +
      "import { RoleAuthGuard } from './guards/role-auth.guard';\n" +
      "import { AsyncAuthGuard } from './guards/async-auth.guard';\n" +
      "\n" +
      "const routes: Routes = [\n" +
      "  // Public routes\n" +
      "  { path: 'login', component: LoginComponent },\n" +
      "  { path: 'register', component: RegisterComponent },\n" +
      "  { path: 'forgot-password', component: ForgotPasswordComponent },\n" +
      "  \n" +
      "  // Protected routes\n" +
      "  { \n" +
      "    path: 'dashboard', \n" +
      "    component: DashboardComponent, \n" +
      "    canActivate: [AuthGuard] \n" +
      "  },\n" +
      "  \n" +
      "  // Admin routes\n" +
      "  { \n" +
      "    path: 'admin', \n" +
      "    component: AdminComponent, \n" +
      "    canActivate: [RoleAuthGuard],\n" +
      "    data: { roles: ['admin'] }\n" +
      "  },\n" +
      "  \n" +
      "  // User management routes\n" +
      "  { \n" +
      "    path: 'users', \n" +
      "    component: UserManagementComponent, \n" +
      "    canActivate: [RoleAuthGuard],\n" +
      "    data: { \n" +
      "      roles: ['admin', 'moderator'],\n" +
      "      permissions: ['read:users', 'write:users']\n" +
      "    }\n" +
      "  },\n" +
      "  \n" +
      "  // Profile routes\n" +
      "  { \n" +
      "    path: 'profile', \n" +
      "    component: ProfileComponent, \n" +
      "    canActivate: [AsyncAuthGuard]\n" +
      "  },\n" +
      "  \n" +
      "  // Default routes\n" +
      "  { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n" +
      "  { path: '**', redirectTo: '/dashboard' }\n" +
      "];\n" +
      "\n" +
      "@NgModule({\n" +
      "  imports: [RouterModule.forRoot(routes)],\n" +
      "  exports: [RouterModule]\n" +
      "})\n" +
      "export class AppRoutingModule { }\n" +
      "```\n\n" +
      "**Child Route Guards:**\n" +
      "```typescript\n" +
      "// child-routes.guard.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { CanActivateChild, Router, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class ChildRoutesGuard implements CanActivateChild {\n" +
      "  constructor(\n" +
      "    private authService: AuthService,\n" +
      "    private router: Router\n" +
      "  ) {}\n" +
      "\n" +
      "  canActivateChild(\n" +
      "    childRoute: ActivatedRouteSnapshot,\n" +
      "    state: RouterStateSnapshot\n" +
      "  ): boolean {\n" +
      "    \n" +
      "    // Check if user can access child routes\n" +
      "    if (!this.authService.isAuthenticated()) {\n" +
      "      this.router.navigate(['/login']);\n" +
      "      return false;\n" +
      "    }\n" +
      "\n" +
      "    // Additional child-specific checks\n" +
      "    const childRoles = childRoute.data['childRoles'] as string[];\n" +
      "    if (childRoles && childRoles.length > 0) {\n" +
      "      const hasChildRole = childRoles.some(role => \n" +
      "        this.authService.hasRole(role)\n" +
      "      );\n" +
      "      \n" +
      "      if (!hasChildRole) {\n" +
      "        this.router.navigate(['/unauthorized']);\n" +
      "        return false;\n" +
      "      }\n" +
      "    }\n" +
      "\n" +
      "    return true;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Guard Testing:**\n" +
      "```typescript\n" +
      "// auth.guard.spec.ts\n" +
      "import { TestBed } from '@angular/core/testing';\n" +
      "import { Router } from '@angular/router';\n" +
      "import { AuthGuard } from './auth.guard';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "describe('AuthGuard', () => {\n" +
      "  let guard: AuthGuard;\n" +
      "  let authService: jasmine.SpyObj<AuthService>;\n" +
      "  let router: jasmine.SpyObj<Router>;\n" +
      "\n" +
      "  beforeEach(() => {\n" +
      "    const authServiceSpy = jasmine.createSpyObj('AuthService', ['isAuthenticated']);\n" +
      "    const routerSpy = jasmine.createSpyObj('Router', ['navigate']);\n" +
      "\n" +
      "    TestBed.configureTestingModule({\n" +
      "      providers: [\n" +
      "        AuthGuard,\n" +
      "        { provide: AuthService, useValue: authServiceSpy },\n" +
      "        { provide: Router, useValue: routerSpy }\n" +
      "      ]\n" +
      "    });\n" +
      "\n" +
      "    guard = TestBed.inject(AuthGuard);\n" +
      "    authService = TestBed.inject(AuthService) as jasmine.SpyObj<AuthService>;\n" +
      "    router = TestBed.inject(Router) as jasmine.SpyObj<Router>;\n" +
      "  });\n" +
      "\n" +
      "  it('should allow access when user is authenticated', () => {\n" +
      "    authService.isAuthenticated.and.returnValue(true);\n" +
      "    \n" +
      "    const result = guard.canActivate(\n" +
      "      {} as ActivatedRouteSnapshot,\n" +
      "      {} as RouterStateSnapshot\n" +
      "    );\n" +
      "    \n" +
      "    expect(result).toBe(true);\n" +
      "  });\n" +
      "\n" +
      "  it('should redirect to login when user is not authenticated', () => {\n" +
      "    authService.isAuthenticated.and.returnValue(false);\n" +
      "    \n" +
      "    const result = guard.canActivate(\n" +
      "      {} as ActivatedRouteSnapshot,\n" +
      "      { url: '/protected' } as RouterStateSnapshot\n" +
      "    );\n" +
      "    \n" +
      "    expect(result).toBe(false);\n" +
      "    expect(router.navigate).toHaveBeenCalledWith(['/login'], {\n" +
      "      queryParams: { returnUrl: '/protected' }\n" +
      "    });\n" +
      "  });\n" +
      "});\n" +
      "```\n\n" +
      "**Key Features of Auth Guards:**\n" +
      "- **Route Protection**: Prevent unauthorized access to routes\n" +
      "- **Authentication Check**: Verify user authentication status\n" +
      "- **Role-Based Access**: Control access based on user roles\n" +
      "- **Permission-Based Access**: Fine-grained permission checking\n" +
      "- **Automatic Redirects**: Redirect unauthorized users to login\n" +
      "- **Return URL**: Remember where user was trying to go\n" +
      "- **Async Support**: Handle asynchronous authentication checks\n" +
      "- **Child Route Protection**: Protect nested routes\n" +
      "- **Testing Support**: Easy to unit test guards\n" +
      "- **Flexible Configuration**: Configurable through route data\n\n" +
      "**Best Practices:**\n" +
      "- Use guards for all protected routes\n" +
      "- Implement role-based guards for admin areas\n" +
      "- Test guards thoroughly\n" +
      "- Handle edge cases (expired tokens, network errors)\n" +
      "- Provide clear error messages\n" +
      "- Use return URLs for better UX\n" +
      "- Combine multiple guards when needed\n" +
      "- Keep guards simple and focused",
    category: "Security",
    difficulty: "intermediate",
    tags: ["auth-guard", "routing", "security", "canActivate", "authentication", "authorization"],
  },
  {
    id: 199,
    question: "What is HTTP Interceptor?",
    answer:
      "HTTP Interceptor is a service in Angular that implements the `HttpInterceptor` interface to intercept and modify HTTP requests and responses. It provides a centralized way to handle common concerns like authentication, error handling, logging, and request/response transformation.\n\n" +
      "**Basic HTTP Interceptor:**\n" +
      "```typescript\n" +
      "// http.interceptor.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';\n" +
      "import { Observable } from 'rxjs';\n" +
      "\n" +
      "@Injectable()\n" +
      "export class HttpInterceptor implements HttpInterceptor {\n" +
      "  constructor() {}\n" +
      "\n" +
      "  intercept(\n" +
      "    request: HttpRequest<any>,\n" +
      "    next: HttpHandler\n" +
      "  ): Observable<HttpEvent<any>> {\n" +
      "    \n" +
      "    // Modify request before sending\n" +
      "    const modifiedRequest = request.clone({\n" +
      "      setHeaders: {\n" +
      "        'Content-Type': 'application/json',\n" +
      "        'Accept': 'application/json'\n" +
      "      }\n" +
      "    });\n" +
      "\n" +
      "    // Continue with the modified request\n" +
      "    return next.handle(modifiedRequest);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Authentication Interceptor:**\n" +
      "```typescript\n" +
      "// auth.interceptor.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';\n" +
      "import { Observable, throwError, BehaviorSubject } from 'rxjs';\n" +
      "import { catchError, filter, take, switchMap } from 'rxjs/operators';\n" +
      "import { AuthService } from './auth.service';\n" +
      "\n" +
      "@Injectable()\n" +
      "export class AuthInterceptor implements HttpInterceptor {\n" +
      "  private isRefreshing = false;\n" +
      "  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);\n" +
      "\n" +
      "  constructor(private authService: AuthService) {}\n" +
      "\n" +
      "  intercept(\n" +
      "    request: HttpRequest<any>,\n" +
      "    next: HttpHandler\n" +
      "  ): Observable<HttpEvent<any>> {\n" +
      "    \n" +
      "    // Add authentication token to request\n" +
      "    if (this.authService.isTokenValid()) {\n" +
      "      request = this.addTokenToRequest(request);\n" +
      "    }\n" +
      "\n" +
      "    return next.handle(request).pipe(\n" +
      "      catchError(error => {\n" +
      "        if (error instanceof HttpErrorResponse && error.status === 401) {\n" +
      "          return this.handle401Error(request, next);\n" +
      "        }\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  private addTokenToRequest(request: HttpRequest<any>): HttpRequest<any> {\n" +
      "    const token = this.authService.getToken();\n" +
      "    if (token) {\n" +
      "      return request.clone({\n" +
      "        setHeaders: {\n" +
      "          Authorization: `Bearer ${token}`\n" +
      "        }\n" +
      "      });\n" +
      "    }\n" +
      "    return request;\n" +
      "  }\n" +
      "\n" +
      "  private handle401Error(\n" +
      "    request: HttpRequest<any>,\n" +
      "    next: HttpHandler\n" +
      "  ): Observable<HttpEvent<any>> {\n" +
      "    \n" +
      "    if (!this.isRefreshing) {\n" +
      "      this.isRefreshing = true;\n" +
      "      this.refreshTokenSubject.next(null);\n" +
      "\n" +
      "      return this.authService.refreshToken().pipe(\n" +
      "        switchMap((response: any) => {\n" +
      "          this.isRefreshing = false;\n" +
      "          this.refreshTokenSubject.next(response.access_token);\n" +
      "          return next.handle(this.addTokenToRequest(request));\n" +
      "        }),\n" +
      "        catchError((error) => {\n" +
      "          this.isRefreshing = false;\n" +
      "          this.authService.logout();\n" +
      "          return throwError(error);\n" +
      "        })\n" +
      "      );\n" +
      "    }\n" +
      "\n" +
      "    return this.refreshTokenSubject.pipe(\n" +
      "      filter(token => token !== null),\n" +
      "      take(1),\n" +
      "      switchMap(() => next.handle(this.addTokenToRequest(request)))\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Error Handling Interceptor:**\n" +
      "```typescript\n" +
      "// error.interceptor.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';\n" +
      "import { Observable, throwError } from 'rxjs';\n" +
      "import { catchError } from 'rxjs/operators';\n" +
      "import { ToastrService } from 'ngx-toastr';\n" +
      "\n" +
      "@Injectable()\n" +
      "export class ErrorInterceptor implements HttpInterceptor {\n" +
      "  constructor(private toastr: ToastrService) {}\n" +
      "\n" +
      "  intercept(\n" +
      "    request: HttpRequest<any>,\n" +
      "    next: HttpHandler\n" +
      "  ): Observable<HttpEvent<any>> {\n" +
      "    \n" +
      "    return next.handle(request).pipe(\n" +
      "      catchError((error: HttpErrorResponse) => {\n" +
      "        let errorMessage = 'An error occurred';\n" +
      "\n" +
      "        if (error.error instanceof ErrorEvent) {\n" +
      "          // Client-side error\n" +
      "          errorMessage = `Error: ${error.error.message}`;\n" +
      "        } else {\n" +
      "          // Server-side error\n" +
      "          switch (error.status) {\n" +
      "            case 400:\n" +
      "              errorMessage = 'Bad Request';\n" +
      "              break;\n" +
      "            case 401:\n" +
      "              errorMessage = 'Unauthorized';\n" +
      "              break;\n" +
      "            case 403:\n" +
      "              errorMessage = 'Forbidden';\n" +
      "              break;\n" +
      "            case 404:\n" +
      "              errorMessage = 'Not Found';\n" +
      "              break;\n" +
      "            case 500:\n" +
      "              errorMessage = 'Internal Server Error';\n" +
      "              break;\n" +
      "            default:\n" +
      "              errorMessage = `Error Code: ${error.status}`;\n" +
      "          }\n" +
      "        }\n" +
      "\n" +
      "        // Show error message\n" +
      "        this.toastr.error(errorMessage, 'Error');\n" +
      "\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Logging Interceptor:**\n" +
      "```typescript\n" +
      "// logging.interceptor.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse } from '@angular/common/http';\n" +
      "import { Observable } from 'rxjs';\n" +
      "import { tap } from 'rxjs/operators';\n" +
      "\n" +
      "@Injectable()\n" +
      "export class LoggingInterceptor implements HttpInterceptor {\n" +
      "  constructor() {}\n" +
      "\n" +
      "  intercept(\n" +
      "    request: HttpRequest<any>,\n" +
      "    next: HttpHandler\n" +
      "  ): Observable<HttpEvent<any>> {\n" +
      "    \n" +
      "    const startTime = Date.now();\n" +
      "    \n" +
      "    console.log(`Request: ${request.method} ${request.url}`);\n" +
      "    \n" +
      "    return next.handle(request).pipe(\n" +
      "      tap(\n" +
      "        (event: HttpEvent<any>) => {\n" +
      "          if (event instanceof HttpResponse) {\n" +
      "            const endTime = Date.now();\n" +
      "            const duration = endTime - startTime;\n" +
      "            console.log(`Response: ${request.method} ${request.url} - ${event.status} (${duration}ms)`);\n" +
      "          }\n" +
      "        },\n" +
      "        (error) => {\n" +
      "          const endTime = Date.now();\n" +
      "          const duration = endTime - startTime;\n" +
      "          console.error(`Error: ${request.method} ${request.url} - ${error.status} (${duration}ms)`);\n" +
      "        }\n" +
      "      )\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Retry Interceptor:**\n" +
      "```typescript\n" +
      "// retry.interceptor.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';\n" +
      "import { Observable, throwError } from 'rxjs';\n" +
      "import { retry, catchError } from 'rxjs/operators';\n" +
      "\n" +
      "@Injectable()\n" +
      "export class RetryInterceptor implements HttpInterceptor {\n" +
      "  constructor() {}\n" +
      "\n" +
      "  intercept(\n" +
      "    request: HttpRequest<any>,\n" +
      "    next: HttpHandler\n" +
      "  ): Observable<HttpEvent<any>> {\n" +
      "    \n" +
      "    return next.handle(request).pipe(\n" +
      "      retry({\n" +
      "        count: 3,\n" +
      "        delay: (error: HttpErrorResponse, retryCount: number) => {\n" +
      "          // Only retry on network errors or 5xx errors\n" +
      "          if (error.status >= 500 || error.status === 0) {\n" +
      "            return timer(retryCount * 1000);\n" +
      "          }\n" +
      "          return throwError(error);\n" +
      "        }\n" +
      "      }),\n" +
      "      catchError((error: HttpErrorResponse) => {\n" +
      "        console.error('Request failed after retries:', error);\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Loading Interceptor:**\n" +
      "```typescript\n" +
      "// loading.interceptor.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';\n" +
      "import { Observable } from 'rxjs';\n" +
      "import { finalize } from 'rxjs/operators';\n" +
      "import { LoadingService } from './loading.service';\n" +
      "\n" +
      "@Injectable()\n" +
      "export class LoadingInterceptor implements HttpInterceptor {\n" +
      "  constructor(private loadingService: LoadingService) {}\n" +
      "\n" +
      "  intercept(\n" +
      "    request: HttpRequest<any>,\n" +
      "    next: HttpHandler\n" +
      "  ): Observable<HttpEvent<any>> {\n" +
      "    \n" +
      "    // Show loading indicator\n" +
      "    this.loadingService.show();\n" +
      "\n" +
      "    return next.handle(request).pipe(\n" +
      "      finalize(() => {\n" +
      "        // Hide loading indicator\n" +
      "        this.loadingService.hide();\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Multiple Interceptors Configuration:**\n" +
      "```typescript\n" +
      "// app.module.ts\n" +
      "import { NgModule } from '@angular/core';\n" +
      "import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';\n" +
      "import { AuthInterceptor } from './interceptors/auth.interceptor';\n" +
      "import { ErrorInterceptor } from './interceptors/error.interceptor';\n" +
      "import { LoggingInterceptor } from './interceptors/logging.interceptor';\n" +
      "import { RetryInterceptor } from './interceptors/retry.interceptor';\n" +
      "import { LoadingInterceptor } from './interceptors/loading.interceptor';\n" +
      "\n" +
      "@NgModule({\n" +
      "  imports: [HttpClientModule],\n" +
      "  providers: [\n" +
      "    // Order matters - interceptors are executed in the order they are provided\n" +
      "    {\n" +
      "      provide: HTTP_INTERCEPTORS,\n" +
      "      useClass: LoggingInterceptor,\n" +
      "      multi: true\n" +
      "    },\n" +
      "    {\n" +
      "      provide: HTTP_INTERCEPTORS,\n" +
      "      useClass: AuthInterceptor,\n" +
      "      multi: true\n" +
      "    },\n" +
      "    {\n" +
      "      provide: HTTP_INTERCEPTORS,\n" +
      "      useClass: RetryInterceptor,\n" +
      "      multi: true\n" +
      "    },\n" +
      "    {\n" +
      "      provide: HTTP_INTERCEPTORS,\n" +
      "      useClass: ErrorInterceptor,\n" +
      "      multi: true\n" +
      "    },\n" +
      "    {\n" +
      "      provide: HTTP_INTERCEPTORS,\n" +
      "      useClass: LoadingInterceptor,\n" +
      "      multi: true\n" +
      "    }\n" +
      "  ]\n" +
      "})\n" +
      "export class AppModule { }\n" +
      "```\n\n" +
      "**Conditional Interceptor:**\n" +
      "```typescript\n" +
      "// conditional.interceptor.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';\n" +
      "import { Observable } from 'rxjs';\n" +
      "\n" +
      "@Injectable()\n" +
      "export class ConditionalInterceptor implements HttpInterceptor {\n" +
      "  constructor() {}\n" +
      "\n" +
      "  intercept(\n" +
      "    request: HttpRequest<any>,\n" +
      "    next: HttpHandler\n" +
      "  ): Observable<HttpEvent<any>> {\n" +
      "    \n" +
      "    // Only apply interceptor to specific URLs\n" +
      "    if (request.url.includes('/api/')) {\n" +
      "      const modifiedRequest = request.clone({\n" +
      "        setHeaders: {\n" +
      "          'X-API-Version': '1.0'\n" +
      "        }\n" +
      "      });\n" +
      "      return next.handle(modifiedRequest);\n" +
      "    }\n" +
      "\n" +
      "    // Skip interceptor for other requests\n" +
      "    return next.handle(request);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Features of HTTP Interceptors:**\n" +
      "- **Request Modification**: Add headers, transform request data\n" +
      "- **Response Handling**: Transform response data, handle errors\n" +
      "- **Authentication**: Automatically add auth tokens\n" +
      "- **Error Handling**: Centralized error processing\n" +
      "- **Logging**: Track HTTP requests and responses\n" +
      "- **Retry Logic**: Automatically retry failed requests\n" +
      "- **Loading States**: Show/hide loading indicators\n" +
      "- **Caching**: Implement request/response caching\n" +
      "- **Conditional Logic**: Apply interceptors based on conditions\n" +
      "- **Multiple Interceptors**: Chain multiple interceptors together\n\n" +
      "**Best Practices:**\n" +
      "- Keep interceptors focused on single responsibility\n" +
      "- Order interceptors carefully (execution order matters)\n" +
      "- Handle errors gracefully\n" +
      "- Use conditional logic when needed\n" +
      "- Test interceptors thoroughly\n" +
      "- Avoid side effects in interceptors\n" +
      "- Use proper error handling\n" +
      "- Consider performance implications",
    category: "HTTP",
    difficulty: "intermediate",
    tags: ["HTTP", "interceptor", "authentication", "error-handling", "logging", "retry"],
  },
  {
    id: 200,
    question: "How to Retry automatically if there is an error response from API?",
    answer:
      "Automatic retry for API errors can be implemented using RxJS operators, HTTP interceptors, or custom retry logic. This is essential for handling network issues, temporary server problems, and improving application reliability.\n\n" +
      "**1. Using RxJS retry Operator:**\n" +
      "```typescript\n" +
      "// Basic retry with fixed count\n" +
      "import { HttpClient } from '@angular/common/http';\n" +
      "import { retry, catchError } from 'rxjs/operators';\n" +
      "import { throwError } from 'rxjs';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class DataService {\n" +
      "  constructor(private http: HttpClient) {}\n" +
      "\n" +
      "  getData(): Observable<any> {\n" +
      "    return this.http.get('/api/data').pipe(\n" +
      "      retry(3), // Retry 3 times\n" +
      "      catchError(error => {\n" +
      "        console.error('Failed after retries:', error);\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**2. Advanced Retry with Delay:**\n" +
      "```typescript\n" +
      "// Retry with exponential backoff\n" +
      "import { retry, catchError, delay, take } from 'rxjs/operators';\n" +
      "import { timer, throwError } from 'rxjs';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class RetryService {\n" +
      "  constructor(private http: HttpClient) {}\n" +
      "\n" +
      "  getDataWithRetry(): Observable<any> {\n" +
      "    return this.http.get('/api/data').pipe(\n" +
      "      retry({\n" +
      "        count: 3,\n" +
      "        delay: (error: HttpErrorResponse, retryCount: number) => {\n" +
      "          // Exponential backoff: 1s, 2s, 4s\n" +
      "          const delayTime = Math.pow(2, retryCount) * 1000;\n" +
      "          console.log(`Retrying in ${delayTime}ms (attempt ${retryCount + 1})`);\n" +
      "          return timer(delayTime);\n" +
      "        }\n" +
      "      }),\n" +
      "      catchError(error => {\n" +
      "        console.error('Failed after all retries:', error);\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. Conditional Retry Logic:**\n" +
      "```typescript\n" +
      "// Retry only for specific error types\n" +
      "import { retry, catchError } from 'rxjs/operators';\n" +
      "import { throwError } from 'rxjs';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class ConditionalRetryService {\n" +
      "  constructor(private http: HttpClient) {}\n" +
      "\n" +
      "  getDataWithConditionalRetry(): Observable<any> {\n" +
      "    return this.http.get('/api/data').pipe(\n" +
      "      retry({\n" +
      "        count: 3,\n" +
      "        delay: (error: HttpErrorResponse, retryCount: number) => {\n" +
      "          // Only retry for network errors or 5xx errors\n" +
      "          if (error.status >= 500 || error.status === 0) {\n" +
      "            const delayTime = retryCount * 1000; // Linear backoff\n" +
      "            console.log(`Retrying ${error.status} error in ${delayTime}ms`);\n" +
      "            return timer(delayTime);\n" +
      "          }\n" +
      "          // Don't retry for 4xx errors (client errors)\n" +
      "          return throwError(error);\n" +
      "        }\n" +
      "      }),\n" +
      "      catchError(error => {\n" +
      "        console.error('Request failed:', error);\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**4. HTTP Interceptor for Global Retry:**\n" +
      "```typescript\n" +
      "// retry.interceptor.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';\n" +
      "import { Observable, throwError } from 'rxjs';\n" +
      "import { retry, catchError } from 'rxjs/operators';\n" +
      "import { timer } from 'rxjs';\n" +
      "\n" +
      "@Injectable()\n" +
      "export class RetryInterceptor implements HttpInterceptor {\n" +
      "  private readonly MAX_RETRIES = 3;\n" +
      "  private readonly RETRY_DELAY = 1000; // 1 second\n" +
      "\n" +
      "  constructor() {}\n" +
      "\n" +
      "  intercept(\n" +
      "    request: HttpRequest<any>,\n" +
      "    next: HttpHandler\n" +
      "  ): Observable<HttpEvent<any>> {\n" +
      "    \n" +
      "    return next.handle(request).pipe(\n" +
      "      retry({\n" +
      "        count: this.MAX_RETRIES,\n" +
      "        delay: (error: HttpErrorResponse, retryCount: number) => {\n" +
      "          // Only retry for specific error conditions\n" +
      "          if (this.shouldRetry(error)) {\n" +
      "            const delayTime = this.calculateDelay(retryCount);\n" +
      "            console.log(`Retrying ${request.method} ${request.url} in ${delayTime}ms`);\n" +
      "            return timer(delayTime);\n" +
      "          }\n" +
      "          return throwError(error);\n" +
      "        }\n" +
      "      }),\n" +
      "      catchError((error: HttpErrorResponse) => {\n" +
      "        console.error(`Request failed after ${this.MAX_RETRIES} retries:`, error);\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  private shouldRetry(error: HttpErrorResponse): boolean {\n" +
      "    // Retry for network errors (status 0) or server errors (5xx)\n" +
      "    return error.status === 0 || error.status >= 500;\n" +
      "  }\n" +
      "\n" +
      "  private calculateDelay(retryCount: number): number {\n" +
      "    // Exponential backoff with jitter\n" +
      "    const baseDelay = Math.pow(2, retryCount) * this.RETRY_DELAY;\n" +
      "    const jitter = Math.random() * 1000; // Add randomness\n" +
      "    return baseDelay + jitter;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**5. Custom Retry Service:**\n" +
      "```typescript\n" +
      "// custom-retry.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { Observable, throwError, timer } from 'rxjs';\n" +
      "import { switchMap, catchError } from 'rxjs/operators';\n" +
      "import { HttpClient, HttpErrorResponse } from '@angular/common/http';\n" +
      "\n" +
      "export interface RetryConfig {\n" +
      "  maxRetries: number;\n" +
      "  baseDelay: number;\n" +
      "  maxDelay: number;\n" +
      "  retryCondition: (error: HttpErrorResponse) => boolean;\n" +
      "}\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class CustomRetryService {\n" +
      "  private defaultConfig: RetryConfig = {\n" +
      "    maxRetries: 3,\n" +
      "    baseDelay: 1000,\n" +
      "    maxDelay: 10000,\n" +
      "    retryCondition: (error: HttpErrorResponse) => {\n" +
      "      return error.status === 0 || error.status >= 500;\n" +
      "    }\n" +
      "  };\n" +
      "\n" +
      "  constructor(private http: HttpClient) {}\n" +
      "\n" +
      "  getWithRetry<T>(url: string, config?: Partial<RetryConfig>): Observable<T> {\n" +
      "    const retryConfig = { ...this.defaultConfig, ...config };\n" +
      "    \n" +
      "    return this.http.get<T>(url).pipe(\n" +
      "      catchError((error: HttpErrorResponse) => {\n" +
      "        return this.handleRetry(error, retryConfig, 0);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  private handleRetry<T>(\n" +
      "    error: HttpErrorResponse,\n" +
      "    config: RetryConfig,\n" +
      "    retryCount: number\n" +
      "  ): Observable<T> {\n" +
      "    \n" +
      "    if (retryCount >= config.maxRetries || !config.retryCondition(error)) {\n" +
      "      return throwError(error);\n" +
      "    }\n" +
      "\n" +
      "    const delay = Math.min(\n" +
      "      config.baseDelay * Math.pow(2, retryCount),\n" +
      "      config.maxDelay\n" +
      "    );\n" +
      "\n" +
      "    console.log(`Retrying in ${delay}ms (attempt ${retryCount + 1}/${config.maxRetries})`);\n" +
      "\n" +
      "    return timer(delay).pipe(\n" +
      "      switchMap(() => {\n" +
      "        // Retry the original request\n" +
      "        return this.http.get<T>(error.url || '').pipe(\n" +
      "          catchError((retryError: HttpErrorResponse) => {\n" +
      "            return this.handleRetry(retryError, config, retryCount + 1);\n" +
      "          })\n" +
      "        );\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**6. Retry with Different Strategies:**\n" +
      "```typescript\n" +
      "// retry-strategies.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { Observable, throwError, timer } from 'rxjs';\n" +
      "import { retry, catchError } from 'rxjs/operators';\n" +
      "import { HttpClient, HttpErrorResponse } from '@angular/common/http';\n" +
      "\n" +
      "export enum RetryStrategy {\n" +
      "  FIXED = 'fixed',\n" +
      "  EXPONENTIAL = 'exponential',\n" +
      "  LINEAR = 'linear',\n" +
      "  CUSTOM = 'custom'\n" +
      "}\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class RetryStrategiesService {\n" +
      "  constructor(private http: HttpClient) {}\n" +
      "\n" +
      "  getDataWithStrategy(\n" +
      "    url: string,\n" +
      "    strategy: RetryStrategy = RetryStrategy.EXPONENTIAL\n" +
      "  ): Observable<any> {\n" +
      "    return this.http.get(url).pipe(\n" +
      "      retry({\n" +
      "        count: 3,\n" +
      "        delay: (error: HttpErrorResponse, retryCount: number) => {\n" +
      "          const delay = this.calculateDelay(strategy, retryCount);\n" +
      "          console.log(`${strategy} retry in ${delay}ms`);\n" +
      "          return timer(delay);\n" +
      "        }\n" +
      "      }),\n" +
      "      catchError(error => {\n" +
      "        console.error('Retry failed:', error);\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  private calculateDelay(strategy: RetryStrategy, retryCount: number): number {\n" +
      "    const baseDelay = 1000;\n" +
      "    \n" +
      "    switch (strategy) {\n" +
      "      case RetryStrategy.FIXED:\n" +
      "        return baseDelay;\n" +
      "      \n" +
      "      case RetryStrategy.LINEAR:\n" +
      "        return baseDelay * (retryCount + 1);\n" +
      "      \n" +
      "      case RetryStrategy.EXPONENTIAL:\n" +
      "        return baseDelay * Math.pow(2, retryCount);\n" +
      "      \n" +
      "      case RetryStrategy.CUSTOM:\n" +
      "        // Custom logic based on error type\n" +
      "        return baseDelay * Math.pow(1.5, retryCount);\n" +
      "      \n" +
      "      default:\n" +
      "        return baseDelay;\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**7. Retry with Circuit Breaker Pattern:**\n" +
      "```typescript\n" +
      "// circuit-breaker.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { Observable, throwError, timer } from 'rxjs';\n" +
      "import { switchMap, catchError } from 'rxjs/operators';\n" +
      "import { HttpClient, HttpErrorResponse } from '@angular/common/http';\n" +
      "\n" +
      "export enum CircuitState {\n" +
      "  CLOSED = 'closed',\n" +
      "  OPEN = 'open',\n" +
      "  HALF_OPEN = 'half-open'\n" +
      "}\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class CircuitBreakerService {\n" +
      "  private state: CircuitState = CircuitState.CLOSED;\n" +
      "  private failureCount = 0;\n" +
      "  private lastFailureTime = 0;\n" +
      "  private readonly failureThreshold = 5;\n" +
      "  private readonly timeout = 60000; // 1 minute\n" +
      "\n" +
      "  constructor(private http: HttpClient) {}\n" +
      "\n" +
      "  getWithCircuitBreaker<T>(url: string): Observable<T> {\n" +
      "    if (this.state === CircuitState.OPEN) {\n" +
      "      if (Date.now() - this.lastFailureTime > this.timeout) {\n" +
      "        this.state = CircuitState.HALF_OPEN;\n" +
      "      } else {\n" +
      "        return throwError(new Error('Circuit breaker is OPEN'));\n" +
      "      }\n" +
      "    }\n" +
      "\n" +
      "    return this.http.get<T>(url).pipe(\n" +
      "      switchMap(response => {\n" +
      "        this.onSuccess();\n" +
      "        return [response];\n" +
      "      }),\n" +
      "      catchError((error: HttpErrorResponse) => {\n" +
      "        this.onFailure();\n" +
      "        return throwError(error);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "\n" +
      "  private onSuccess(): void {\n" +
      "    this.failureCount = 0;\n" +
      "    this.state = CircuitState.CLOSED;\n" +
      "  }\n" +
      "\n" +
      "  private onFailure(): void {\n" +
      "    this.failureCount++;\n" +
      "    this.lastFailureTime = Date.now();\n" +
      "    \n" +
      "    if (this.failureCount >= this.failureThreshold) {\n" +
      "      this.state = CircuitState.OPEN;\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**8. Usage Examples:**\n" +
      "```typescript\n" +
      "// component.ts\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { RetryService } from './retry.service';\n" +
      "import { RetryStrategiesService, RetryStrategy } from './retry-strategies.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-data',\n" +
      "  template: `\n" +
      "    <div>\n" +
      '      <button (click)="loadData()">Load Data</button>\n' +
      '      <div *ngIf="loading">Loading...</div>\n' +
      '      <div *ngIf="error">{{ error }}</div>\n' +
      '      <div *ngIf="data">{{ data | json }}</div>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class DataComponent implements OnInit {\n" +
      "  data: any;\n" +
      "  loading = false;\n" +
      "  error: string | null = null;\n" +
      "\n" +
      "  constructor(\n" +
      "    private retryService: RetryService,\n" +
      "    private retryStrategiesService: RetryStrategiesService\n" +
      "  ) {}\n" +
      "\n" +
      "  loadData(): void {\n" +
      "    this.loading = true;\n" +
      "    this.error = null;\n" +
      "\n" +
      "    this.retryService.getDataWithRetry().subscribe({\n" +
      "      next: (response) => {\n" +
      "        this.data = response;\n" +
      "        this.loading = false;\n" +
      "      },\n" +
      "      error: (error) => {\n" +
      "        this.error = 'Failed to load data after retries';\n" +
      "        this.loading = false;\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  loadDataWithStrategy(): void {\n" +
      "    this.retryStrategiesService.getDataWithStrategy(\n" +
      "      '/api/data',\n" +
      "      RetryStrategy.EXPONENTIAL\n" +
      "    ).subscribe({\n" +
      "      next: (response) => {\n" +
      "        this.data = response;\n" +
      "      },\n" +
      "      error: (error) => {\n" +
      "        this.error = 'Failed to load data';\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Benefits of Automatic Retry:**\n" +
      "- **Improved Reliability**: Handle temporary network issues\n" +
      "- **Better User Experience**: Reduce failed requests\n" +
      "- **Resilience**: Application continues working despite failures\n" +
      "- **Flexibility**: Different retry strategies for different scenarios\n" +
      "- **Monitoring**: Track retry attempts and success rates\n" +
      "- **Performance**: Optimize retry timing and frequency\n" +
      "- **Error Handling**: Graceful degradation when retries fail\n" +
      "- **Circuit Breaker**: Prevent cascading failures\n\n" +
      "**Best Practices:**\n" +
      "- Use exponential backoff to avoid overwhelming servers\n" +
      "- Set reasonable retry limits (3-5 attempts)\n" +
      "- Only retry for appropriate error types (5xx, network errors)\n" +
      "- Implement circuit breaker for critical services\n" +
      "- Log retry attempts for monitoring\n" +
      "- Consider user experience during retries\n" +
      "- Test retry logic thoroughly\n" +
      "- Monitor retry success rates",
    category: "HTTP",
    difficulty: "intermediate",
    tags: ["retry", "HTTP", "error-handling", "resilience", "RxJS", "circuit-breaker"],
  },
  {
    id: 201,
    question: "What are the parts of JWT Token?",
    answer:
      "JWT (JSON Web Token) consists of three parts separated by dots (`.`): Header, Payload, and Signature. Each part is Base64URL encoded and contains specific information about the token.\n\n" +
      "**JWT Structure:**\n" +
      "```\n" +
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n" +
      "```\n\n" +
      "**1. Header (Header.Payload.Signature):**\n" +
      "```json\n" +
      "{\n" +
      '  "alg": "HS256",\n' +
      '  "typ": "JWT"\n' +
      "}\n" +
      "```\n\n" +
      "**Header Fields:**\n" +
      "- **`alg` (Algorithm)**: The signing algorithm used (e.g., HS256, RS256, ES256)\n" +
      '- **`typ` (Type)**: The token type, always "JWT"\n' +
      "- **`kid` (Key ID)**: Optional key identifier for key rotation\n" +
      "- **`cty` (Content Type)**: Optional content type for nested JWTs\n" +
      "\n" +
      "**2. Payload (Claims):**\n" +
      "```json\n" +
      "{\n" +
      '  "sub": "1234567890",\n' +
      '  "name": "John Doe",\n' +
      '  "iat": 1516239022,\n' +
      '  "exp": 1516242622,\n' +
      '  "iss": "https://example.com",\n' +
      '  "aud": "https://api.example.com",\n' +
      '  "jti": "unique-token-id",\n' +
      '  "role": "admin",\n' +
      '  "permissions": ["read:users", "write:users"]\n' +
      "}\n" +
      "```\n\n" +
      "**Standard Claims (Registered Claims):**\n" +
      "- **`iss` (Issuer)**: Who issued the token\n" +
      "- **`sub` (Subject)**: The subject (usually user ID)\n" +
      "- **`aud` (Audience)**: Who the token is intended for\n" +
      "- **`exp` (Expiration Time)**: When the token expires (Unix timestamp)\n" +
      "- **`nbf` (Not Before)**: Token not valid before this time\n" +
      "- **`iat` (Issued At)**: When the token was issued\n" +
      "- **`jti` (JWT ID)**: Unique identifier for the token\n" +
      "\n" +
      "**Public Claims:**\n" +
      "- **`name`**: User's full name\n" +
      "- **`email`**: User's email address\n" +
      "- **`role`**: User's role\n" +
      "- **`permissions`**: Array of user permissions\n" +
      "- **`department`**: User's department\n" +
      "- **`company`**: User's company\n" +
      "\n" +
      "**Private Claims:**\n" +
      "- **`custom_field`**: Any custom data\n" +
      "- **`preferences`**: User preferences\n" +
      "- **`metadata`**: Additional metadata\n" +
      "\n" +
      "**3. Signature:**\n" +
      "```\n" +
      "HMACSHA256(\n" +
      '  base64UrlEncode(header) + "." +\n' +
      "  base64UrlEncode(payload),\n" +
      "  secret\n" +
      ")\n" +
      "```\n\n" +
      "**Signature Purpose:**\n" +
      "- **Integrity**: Ensures token hasn't been tampered with\n" +
      "- **Authentication**: Verifies the token was issued by trusted party\n" +
      "- **Non-repudiation**: Proves the token was created by the issuer\n" +
      "\n" +
      "**JWT Implementation in Angular:**\n" +
      "```typescript\n" +
      "// jwt-utils.service.ts\n" +
      "import { Injectable } from '@angular/core';\n" +
      "\n" +
      "export interface JWTHeader {\n" +
      "  alg: string;\n" +
      "  typ: string;\n" +
      "  kid?: string;\n" +
      "  cty?: string;\n" +
      "}\n" +
      "\n" +
      "export interface JWTPayload {\n" +
      "  // Standard claims\n" +
      "  iss?: string;    // Issuer\n" +
      "  sub?: string;    // Subject\n" +
      "  aud?: string;    // Audience\n" +
      "  exp?: number;    // Expiration time\n" +
      "  nbf?: number;    // Not before\n" +
      "  iat?: number;    // Issued at\n" +
      "  jti?: string;    // JWT ID\n" +
      "  \n" +
      "  // Public claims\n" +
      "  name?: string;\n" +
      "  email?: string;\n" +
      "  role?: string;\n" +
      "  permissions?: string[];\n" +
      "  \n" +
      "  // Private claims\n" +
      "  [key: string]: any;\n" +
      "}\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class JWTUtilsService {\n" +
      "  \n" +
      "  // Decode JWT token\n" +
      "  decodeToken(token: string): { header: JWTHeader; payload: JWTPayload } {\n" +
      "    try {\n" +
      "      const parts = token.split('.');\n" +
      "      \n" +
      "      if (parts.length !== 3) {\n" +
      "        throw new Error('Invalid JWT format');\n" +
      "      }\n" +
      "      \n" +
      "      const header = this.base64UrlDecode(parts[0]);\n" +
      "      const payload = this.base64UrlDecode(parts[1]);\n" +
      "      \n" +
      "      return {\n" +
      "        header: JSON.parse(header),\n" +
      "        payload: JSON.parse(payload)\n" +
      "      };\n" +
      "    } catch (error) {\n" +
      "      throw new Error('Invalid JWT token');\n" +
      "    }\n" +
      "  }\n" +
      "  \n" +
      "  // Check if token is expired\n" +
      "  isTokenExpired(token: string): boolean {\n" +
      "    try {\n" +
      "      const { payload } = this.decodeToken(token);\n" +
      "      const currentTime = Math.floor(Date.now() / 1000);\n" +
      "      return payload.exp ? payload.exp < currentTime : true;\n" +
      "    } catch {\n" +
      "      return true;\n" +
      "    }\n" +
      "  }\n" +
      "  \n" +
      "  // Get token expiration time\n" +
      "  getTokenExpiration(token: string): Date | null {\n" +
      "    try {\n" +
      "      const { payload } = this.decodeToken(token);\n" +
      "      return payload.exp ? new Date(payload.exp * 1000) : null;\n" +
      "    } catch {\n" +
      "      return null;\n" +
      "    }\n" +
      "  }\n" +
      "  \n" +
      "  // Get token issued time\n" +
      "  getTokenIssuedAt(token: string): Date | null {\n" +
      "    try {\n" +
      "      const { payload } = this.decodeToken(token);\n" +
      "      return payload.iat ? new Date(payload.iat * 1000) : null;\n" +
      "    } catch {\n" +
      "      return null;\n" +
      "    }\n" +
      "  }\n" +
      "  \n" +
      "  // Get user ID from token\n" +
      "  getUserId(token: string): string | null {\n" +
      "    try {\n" +
      "      const { payload } = this.decodeToken(token);\n" +
      "      return payload.sub || null;\n" +
      "    } catch {\n" +
      "      return null;\n" +
      "    }\n" +
      "  }\n" +
      "  \n" +
      "  // Get user role from token\n" +
      "  getUserRole(token: string): string | null {\n" +
      "    try {\n" +
      "      const { payload } = this.decodeToken(token);\n" +
      "      return payload.role || null;\n" +
      "    } catch {\n" +
      "      return null;\n" +
      "    }\n" +
      "  }\n" +
      "  \n" +
      "  // Get user permissions from token\n" +
      "  getUserPermissions(token: string): string[] {\n" +
      "    try {\n" +
      "      const { payload } = this.decodeToken(token);\n" +
      "      return payload.permissions || [];\n" +
      "    } catch {\n" +
      "      return [];\n" +
      "    }\n" +
      "  }\n" +
      "  \n" +
      "  // Get token time remaining\n" +
      "  getTimeRemaining(token: string): number {\n" +
      "    try {\n" +
      "      const { payload } = this.decodeToken(token);\n" +
      "      if (!payload.exp) return 0;\n" +
      "      \n" +
      "      const currentTime = Math.floor(Date.now() / 1000);\n" +
      "      const remaining = payload.exp - currentTime;\n" +
      "      return Math.max(0, remaining);\n" +
      "    } catch {\n" +
      "      return 0;\n" +
      "    }\n" +
      "  }\n" +
      "  \n" +
      "  // Validate token structure\n" +
      "  isValidTokenStructure(token: string): boolean {\n" +
      "    try {\n" +
      "      const parts = token.split('.');\n" +
      "      return parts.length === 3 && parts.every(part => part.length > 0);\n" +
      "    } catch {\n" +
      "      return false;\n" +
      "    }\n" +
      "  }\n" +
      "  \n" +
      "  // Base64URL decode\n" +
      "  private base64UrlDecode(str: string): string {\n" +
      "    const base64 = str.replace(/-/g, '+').replace(/_/g, '/');\n" +
      "    const padded = base64.padEnd(base64.length + (4 - base64.length % 4) % 4, '=');\n" +
      "    return decodeURIComponent(\n" +
      "      atob(padded)\n" +
      "        .split('')\n" +
      "        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n" +
      "        .join('')\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**JWT Token Analysis Component:**\n" +
      "```typescript\n" +
      "// jwt-analyzer.component.ts\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { JWTUtilsService, JWTHeader, JWTPayload } from './jwt-utils.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-jwt-analyzer',\n" +
      "  template: `\n" +
      '    <div class="jwt-analyzer">\n' +
      "      <h2>JWT Token Analyzer</h2>\n" +
      "      \n" +
      '      <div class="token-input">\n' +
      '        <label for="token">JWT Token:</label>\n' +
      "        <textarea \n" +
      '          id="token" \n' +
      '          [(ngModel)]="token" \n' +
      '          placeholder="Enter JWT token..."\n' +
      '          rows="3"\n' +
      "        ></textarea>\n" +
      '        <button (click)="analyzeToken()">Analyze Token</button>\n' +
      "      </div>\n" +
      "      \n" +
      '      <div *ngIf="analysis" class="analysis">\n' +
      '        <div class="token-parts">\n' +
      "          <h3>Token Parts</h3>\n" +
      '          <div class="part">\n' +
      "            <h4>Header</h4>\n" +
      "            <pre>{{ analysis.header | json }}</pre>\n" +
      "          </div>\n" +
      '          <div class="part">\n' +
      "            <h4>Payload</h4>\n" +
      "            <pre>{{ analysis.payload | json }}</pre>\n" +
      "          </div>\n" +
      "        </div>\n" +
      "        \n" +
      '        <div class="token-info">\n' +
      "          <h3>Token Information</h3>\n" +
      '          <div class="info-item">\n' +
      "            <strong>Issued At:</strong> {{ analysis.issuedAt | date:'medium' }}\n" +
      "          </div>\n" +
      '          <div class="info-item">\n' +
      "            <strong>Expires At:</strong> {{ analysis.expiresAt | date:'medium' }}\n" +
      "          </div>\n" +
      '          <div class="info-item">\n' +
      "            <strong>Time Remaining:</strong> {{ analysis.timeRemaining }} seconds\n" +
      "          </div>\n" +
      '          <div class="info-item">\n' +
      "            <strong>User ID:</strong> {{ analysis.userId }}\n" +
      "          </div>\n" +
      '          <div class="info-item">\n' +
      "            <strong>User Role:</strong> {{ analysis.userRole }}\n" +
      "          </div>\n" +
      '          <div class="info-item">\n' +
      "            <strong>Permissions:</strong> {{ analysis.permissions.join(', ') }}\n" +
      "          </div>\n" +
      '          <div class="info-item">\n' +
      "            <strong>Is Expired:</strong> {{ analysis.isExpired ? 'Yes' : 'No' }}\n" +
      "          </div>\n" +
      "        </div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `,\n" +
      "  styles: [`\n" +
      "    .jwt-analyzer {\n" +
      "      max-width: 800px;\n" +
      "      margin: 0 auto;\n" +
      "      padding: 20px;\n" +
      "    }\n" +
      "    .token-input textarea {\n" +
      "      width: 100%;\n" +
      "      margin: 10px 0;\n" +
      "    }\n" +
      "    .analysis {\n" +
      "      margin-top: 20px;\n" +
      "    }\n" +
      "    .token-parts {\n" +
      "      display: grid;\n" +
      "      grid-template-columns: 1fr 1fr;\n" +
      "      gap: 20px;\n" +
      "      margin-bottom: 20px;\n" +
      "    }\n" +
      "    .part pre {\n" +
      "      background: #f5f5f5;\n" +
      "      padding: 10px;\n" +
      "      border-radius: 4px;\n" +
      "      overflow-x: auto;\n" +
      "    }\n" +
      "    .info-item {\n" +
      "      margin: 10px 0;\n" +
      "    }\n" +
      "  `]\n" +
      "})\n" +
      "export class JWTAnalyzerComponent implements OnInit {\n" +
      "  token = '';\n" +
      "  analysis: any = null;\n" +
      "\n" +
      "  constructor(private jwtUtils: JWTUtilsService) {}\n" +
      "\n" +
      "  ngOnInit(): void {}\n" +
      "\n" +
      "  analyzeToken(): void {\n" +
      "    if (!this.token.trim()) {\n" +
      "      alert('Please enter a JWT token');\n" +
      "      return;\n" +
      "    }\n" +
      "\n" +
      "    try {\n" +
      "      const { header, payload } = this.jwtUtils.decodeToken(this.token);\n" +
      "      \n" +
      "      this.analysis = {\n" +
      "        header,\n" +
      "        payload,\n" +
      "        issuedAt: this.jwtUtils.getTokenIssuedAt(this.token),\n" +
      "        expiresAt: this.jwtUtils.getTokenExpiration(this.token),\n" +
      "        timeRemaining: this.jwtUtils.getTimeRemaining(this.token),\n" +
      "        userId: this.jwtUtils.getUserId(this.token),\n" +
      "        userRole: this.jwtUtils.getUserRole(this.token),\n" +
      "        permissions: this.jwtUtils.getUserPermissions(this.token),\n" +
      "        isExpired: this.jwtUtils.isTokenExpired(this.token)\n" +
      "      };\n" +
      "    } catch (error) {\n" +
      "      alert('Invalid JWT token: ' + error.message);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**JWT Security Considerations:**\n" +
      "- **Token Size**: JWT tokens can be large due to Base64 encoding\n" +
      "- **Sensitive Data**: Don't store sensitive data in the payload\n" +
      "- **Expiration**: Always set reasonable expiration times\n" +
      "- **Signature Verification**: Always verify the signature on the server\n" +
      "- **Algorithm Security**: Use strong algorithms (RS256, ES256)\n" +
      "- **Key Management**: Secure key storage and rotation\n" +
      "- **Token Storage**: Store tokens securely (httpOnly cookies preferred)\n" +
      "- **HTTPS**: Always use HTTPS in production\n" +
      "- **Token Revocation**: Implement token blacklisting for security\n" +
      "- **Audience Validation**: Validate the audience claim\n\n" +
      "**Key Benefits of JWT Structure:**\n" +
      "- **Self-contained**: Contains all necessary information\n" +
      "- **Stateless**: No server-side session storage needed\n" +
      "- **Compact**: Efficient for HTTP headers\n" +
      "- **Standardized**: Based on RFC 7519 standard\n" +
      "- **Cross-domain**: Works across different domains\n" +
      "- **Extensible**: Can include custom claims\n" +
      "- **Verifiable**: Signature ensures integrity\n" +
      "- **Time-based**: Built-in expiration support",
    category: "Security",
    difficulty: "intermediate",
    tags: ["JWT", "token", "authentication", "security", "header", "payload", "signature"],
  },
  {
    id: 202,
    question: "What are the lifecycle hooks of a zone?",
    answer:
      "Zone.js provides four lifecycle hooks for asynchronous operations that allow you to monitor and intercept different phases of async task execution. These hooks are essential for understanding how Angular's change detection works.\n\n" +
      "**1. onScheduleTask Hook:**\n" +
      "This hook triggers when a new asynchronous task is scheduled. It's called before the task is added to the task queue.\n" +
      "```typescript\n" +
      "onScheduleTask: function(delegate, curr, target, task) {\n" +
      "  console.log('new task is scheduled:', task.type, task.source);\n" +
      "  // task.type can be: 'macroTask', 'microTask', 'eventTask'\n" +
      "  // task.source can be: 'setTimeout', 'setInterval', 'Promise', 'XMLHttpRequest', etc.\n" +
      "  return delegate.scheduleTask(target, task);\n" +
      "}\n" +
      "```\n\n" +
      "**2. onInvokeTask Hook:**\n" +
      "This hook triggers when an asynchronous task is about to execute. It's called just before the task's callback function runs.\n" +
      "```typescript\n" +
      "onInvokeTask: function(delegate, curr, target, task, applyThis, applyArgs) {\n" +
      "  console.log('task will be invoked:', task.type, task.source);\n" +
      "  // You can modify applyThis and applyArgs here\n" +
      "  return delegate.invokeTask(target, task, applyThis, applyArgs);\n" +
      "}\n" +
      "```\n\n" +
      "**3. onHasTask Hook:**\n" +
      "This hook triggers when the status of tasks inside a zone changes from stable (no tasks) to unstable (new tasks scheduled) or vice versa.\n" +
      "```typescript\n" +
      "onHasTask: function(delegate, curr, target, hasTaskState) {\n" +
      "  console.log('task state changed in the zone:', hasTaskState);\n" +
      "  // hasTaskState contains:\n" +
      "  // - microTask: boolean\n" +
      "  // - macroTask: boolean\n" +
      "  // - eventTask: boolean\n" +
      "  // - change: 'stable' | 'unstable'\n" +
      "  return delegate.hasTask(target, hasTaskState);\n" +
      "}\n" +
      "```\n\n" +
      "**4. onInvoke Hook:**\n" +
      "This hook triggers when a synchronous function is going to execute in the zone.\n" +
      "```typescript\n" +
      "onInvoke: function(delegate, curr, target, callback, applyThis, applyArgs) {\n" +
      "  console.log('the callback will be invoked:', callback);\n" +
      "  // This runs for synchronous operations\n" +
      "  return delegate.invoke(target, callback, applyThis, applyArgs);\n" +
      "}\n" +
      "```\n\n" +
      "**Complete Zone Implementation Example:**\n" +
      "```typescript\n" +
      "import { NgZone } from '@angular/core';\n" +
      "\n" +
      "export class ZoneMonitoringService {\n" +
      "  private monitoringZone: Zone;\n" +
      "\n" +
      "  constructor(private ngZone: NgZone) {\n" +
      "    this.setupZoneMonitoring();\n" +
      "  }\n" +
      "\n" +
      "  private setupZoneMonitoring(): void {\n" +
      "    this.monitoringZone = Zone.current.fork({\n" +
      "      name: 'monitoring-zone',\n" +
      "      onScheduleTask: (delegate, curr, target, task) => {\n" +
      "        console.log(`[${task.type}] Task scheduled:`, task.source);\n" +
      "        return delegate.scheduleTask(target, task);\n" +
      "      },\n" +
      "      onInvokeTask: (delegate, curr, target, task, applyThis, applyArgs) => {\n" +
      "        console.log(`[${task.type}] Task executing:`, task.source);\n" +
      "        return delegate.invokeTask(target, task, applyThis, applyArgs);\n" +
      "      },\n" +
      "      onHasTask: (delegate, curr, target, hasTaskState) => {\n" +
      "        console.log('Zone state changed:', hasTaskState);\n" +
      "        return delegate.hasTask(target, hasTaskState);\n" +
      "      },\n" +
      "      onInvoke: (delegate, curr, target, callback, applyThis, applyArgs) => {\n" +
      "        console.log('Synchronous function invoked:', callback.name);\n" +
      "        return delegate.invoke(target, callback, applyThis, applyArgs);\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "\n" +
      "  runInMonitoringZone(fn: Function): any {\n" +
      "    return this.monitoringZone.run(fn);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Task Types:**\n" +
      "- **macroTask**: setTimeout, setInterval, setImmediate, I/O operations\n" +
      "- **microTask**: Promise.then, queueMicrotask, MutationObserver\n" +
      "- **eventTask**: DOM events, WebSocket events\n\n" +
      "**Practical Usage:**\n" +
      "```typescript\n" +
      "// Component using zone monitoring\n" +
      "export class AppComponent {\n" +
      "  constructor(private zoneMonitoring: ZoneMonitoringService) {\n" +
      "    // Monitor async operations\n" +
      "    this.zoneMonitoring.runInMonitoringZone(() => {\n" +
      "      setTimeout(() => {\n" +
      "        console.log('This will trigger onScheduleTask and onInvokeTask');\n" +
      "      }, 1000);\n" +
      "\n" +
      "      Promise.resolve().then(() => {\n" +
      "        console.log('This will trigger microTask hooks');\n" +
      "      });\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Benefits:**\n" +
      "- **Debugging**: Track async operations and their execution\n" +
      "- **Performance Monitoring**: Identify performance bottlenecks\n" +
      "- **Change Detection**: Understand when Angular triggers change detection\n" +
      "- **Error Tracking**: Monitor task failures and exceptions\n" +
      "- **Custom Behavior**: Intercept and modify task execution\n\n" +
      "**Best Practices:**\n" +
      "- Use zone hooks for debugging and monitoring\n" +
      "- Avoid heavy operations in hooks to prevent performance issues\n" +
      "- Be careful when modifying task execution\n" +
      "- Use zone hooks to understand Angular's change detection cycle\n" +
      "- Monitor both macro and micro tasks for complete coverage",
    category: "Zone.js",
    difficulty: "advanced",
    tags: ["zone", "lifecycle", "hooks", "async", "change-detection", "monitoring"],
  },
  {
    id: 203,
    question: "What are the methods of NgZone used to control change detection?",
    answer:
      "NgZone service provides several methods to control change detection and execute code within or outside Angular's zone. These methods are essential for managing performance and integrating third-party libraries.\n\n" +
      "**1. run() Method:**\n" +
      "Executes a function inside Angular's zone, triggering change detection automatically.\n" +
      "```typescript\n" +
      "import { NgZone } from '@angular/core';\n" +
      "\n" +
      "export class AppComponent implements OnInit {\n" +
      "  constructor(private ngZone: NgZone) {}\n" +
      "  \n" +
      "  ngOnInit() {\n" +
      "    // Use ngZone.run() to make the asynchronous operation in the angular zone\n" +
      "    this.ngZone.run(() => {\n" +
      "      someNewAsyncAPI(() => {\n" +
      "        // Update the data of the component\n" +
      "        this.data = 'Updated data';\n" +
      "        // Change detection will run automatically\n" +
      "      });\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**2. runOutsideAngular() Method:**\n" +
      "Executes a function outside Angular's zone, preventing automatic change detection.\n" +
      "```typescript\n" +
      "export class PerformanceComponent {\n" +
      "  constructor(private ngZone: NgZone) {}\n" +
      "  \n" +
      "  startHeavyComputation() {\n" +
      "    // Run heavy computation outside Angular zone\n" +
      "    this.ngZone.runOutsideAngular(() => {\n" +
      "      const result = this.performHeavyCalculation();\n" +
      "      \n" +
      "      // When done, update UI inside Angular zone\n" +
      "      this.ngZone.run(() => {\n" +
      "        this.result = result;\n" +
      "      });\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  private performHeavyCalculation(): number {\n" +
      "    let result = 0;\n" +
      "    for (let i = 0; i < 1000000; i++) {\n" +
      "      result += Math.random();\n" +
      "    }\n" +
      "    return result;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. runGuarded() Method:**\n" +
      "Executes a function inside Angular's zone with error handling.\n" +
      "```typescript\n" +
      "export class ErrorHandlingComponent {\n" +
      "  constructor(private ngZone: NgZone) {}\n" +
      "  \n" +
      "  performRiskyOperation() {\n" +
      "    this.ngZone.runGuarded(() => {\n" +
      "      try {\n" +
      "        // Risky operation that might throw\n" +
      "        this.processData();\n" +
      "      } catch (error) {\n" +
      "        console.error('Error in guarded operation:', error);\n" +
      "        this.handleError(error);\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**4. isStable Property:**\n" +
      "Returns a boolean indicating whether the zone is stable (no pending tasks).\n" +
      "```typescript\n" +
      "export class StabilityComponent {\n" +
      "  constructor(private ngZone: NgZone) {\n" +
      "    // Check if zone is stable\n" +
      "    console.log('Zone is stable:', this.ngZone.isStable);\n" +
      "  }\n" +
      "  \n" +
      "  waitForStability() {\n" +
      "    if (this.ngZone.isStable) {\n" +
      "      this.performAction();\n" +
      "    } else {\n" +
      "      // Wait for stability\n" +
      "      setTimeout(() => this.waitForStability(), 100);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**5. onStable Observable:**\n" +
      "An observable that emits when the zone becomes stable.\n" +
      "```typescript\n" +
      "import { take } from 'rxjs/operators';\n" +
      "\n" +
      "export class StabilityObserverComponent {\n" +
      "  constructor(private ngZone: NgZone) {\n" +
      "    // Subscribe to stability changes\n" +
      "    this.ngZone.onStable.pipe(\n" +
      "      take(1) // Take only the first emission\n" +
      "    ).subscribe(() => {\n" +
      "      console.log('Zone became stable');\n" +
      "      this.performPostStabilityAction();\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**6. onUnstable Observable:**\n" +
      "An observable that emits when the zone becomes unstable.\n" +
      "```typescript\n" +
      "export class UnstableObserverComponent {\n" +
      "  constructor(private ngZone: NgZone) {\n" +
      "    // Monitor when zone becomes unstable\n" +
      "    this.ngZone.onUnstable.subscribe(() => {\n" +
      "      console.log('Zone became unstable - tasks are pending');\n" +
      "      this.showLoadingIndicator();\n" +
      "    });\n" +
      "    \n" +
      "    this.ngZone.onStable.subscribe(() => {\n" +
      "      console.log('Zone became stable - all tasks completed');\n" +
      "      this.hideLoadingIndicator();\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Complete Example - Third-Party Integration:**\n" +
      "```typescript\n" +
      "export class ThirdPartyIntegrationComponent {\n" +
      "  private chart: any;\n" +
      "  \n" +
      "  constructor(private ngZone: NgZone) {}\n" +
      "  \n" +
      "  ngOnInit() {\n" +
      "    // Initialize third-party library outside Angular zone\n" +
      "    this.ngZone.runOutsideAngular(() => {\n" +
      "      this.chart = new ThirdPartyChart({\n" +
      "        onDataUpdate: (data) => {\n" +
      "          // Update Angular component data inside zone\n" +
      "          this.ngZone.run(() => {\n" +
      "            this.chartData = data;\n" +
      "          });\n" +
      "        },\n" +
      "        onError: (error) => {\n" +
      "          // Handle errors inside zone\n" +
      "          this.ngZone.runGuarded(() => {\n" +
      "            this.handleChartError(error);\n" +
      "          });\n" +
      "        }\n" +
      "      });\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  ngOnDestroy() {\n" +
      "    // Cleanup outside Angular zone\n" +
      "    this.ngZone.runOutsideAngular(() => {\n" +
      "      if (this.chart) {\n" +
      "        this.chart.destroy();\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Performance Optimization Example:**\n" +
      "```typescript\n" +
      "export class PerformanceOptimizedComponent {\n" +
      "  private animationFrameId: number;\n" +
      "  \n" +
      "  constructor(private ngZone: NgZone) {}\n" +
      "  \n" +
      "  startAnimation() {\n" +
      "    const animate = () => {\n" +
      "      // Run animation outside Angular zone for better performance\n" +
      "      this.ngZone.runOutsideAngular(() => {\n" +
      "        this.updateAnimationFrame();\n" +
      "        this.animationFrameId = requestAnimationFrame(animate);\n" +
      "      });\n" +
      "    };\n" +
      "    \n" +
      "    animate();\n" +
      "  }\n" +
      "  \n" +
      "  stopAnimation() {\n" +
      "    if (this.animationFrameId) {\n" +
      "      cancelAnimationFrame(this.animationFrameId);\n" +
      "    }\n" +
      "  }\n" +
      "  \n" +
      "  updateUI() {\n" +
      "    // Update UI inside Angular zone when needed\n" +
      "    this.ngZone.run(() => {\n" +
      "      this.uiData = this.calculateUIData();\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Benefits:**\n" +
      "- **Performance Control**: Run heavy operations outside Angular zone\n" +
      "- **Change Detection Management**: Control when change detection runs\n" +
      "- **Third-Party Integration**: Integrate libraries that don't work with Angular zones\n" +
      "- **Error Handling**: Handle errors gracefully with runGuarded\n" +
      "- **Stability Monitoring**: Track zone stability for debugging\n" +
      "- **Animation Optimization**: Optimize animations and heavy computations\n\n" +
      "**Best Practices:**\n" +
      "- Use `runOutsideAngular()` for performance-critical operations\n" +
      "- Use `run()` to ensure change detection runs when needed\n" +
      "- Use `runGuarded()` for error-prone operations\n" +
      "- Monitor zone stability for debugging purposes\n" +
      "- Clean up resources properly in ngOnDestroy\n" +
      "- Be careful with third-party library integration",
    category: "Zone.js",
    difficulty: "intermediate",
    tags: ["NgZone", "change-detection", "performance", "zone", "run", "runOutsideAngular"],
  },
  {
    id: 204,
    question: "What is an optional dependency?",
    answer:
      "An optional dependency is a parameter decorator (`@Optional()`) used on constructor parameters to mark them as optional. When Angular's dependency injection system cannot find a provider for the dependency, it will inject `null` instead of throwing an error.\n\n" +
      "**Basic Usage:**\n" +
      "```typescript\n" +
      "import { Optional } from '@angular/core';\n" +
      "\n" +
      "export class AppComponent {\n" +
      "  constructor(@Optional() private logger?: Logger) {\n" +
      "    if (this.logger) {\n" +
      "      this.logger.log('This is an optional dependency message');\n" +
      "    } else {\n" +
      "      console.log('The logger is not registered');\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Complete Example with Service:**\n" +
      "```typescript\n" +
      "// Logger service\n" +
      "export class Logger {\n" +
      "  log(message: string): void {\n" +
      "    console.log(`[LOG]: ${message}`);\n" +
      "  }\n" +
      "  \n" +
      "  error(message: string): void {\n" +
      "    console.error(`[ERROR]: ${message}`);\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "// Component using optional logger\n" +
      "export class UserService {\n" +
      "  constructor(@Optional() private logger?: Logger) {}\n" +
      "  \n" +
      "  getUser(id: string): User {\n" +
      "    // Use logger if available\n" +
      "    if (this.logger) {\n" +
      "      this.logger.log(`Fetching user with ID: ${id}`);\n" +
      "    }\n" +
      "    \n" +
      "    // Business logic here\n" +
      "    return this.fetchUserFromAPI(id);\n" +
      "  }\n" +
      "  \n" +
      "  private fetchUserFromAPI(id: string): User {\n" +
      "    // Implementation\n" +
      "    return { id, name: 'John Doe' };\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Module Configuration:**\n" +
      "```typescript\n" +
      "// app.module.ts\n" +
      "import { NgModule } from '@angular/core';\n" +
      "import { Logger } from './logger.service';\n" +
      "import { UserService } from './user.service';\n" +
      "\n" +
      "@NgModule({\n" +
      "  providers: [\n" +
      "    // Logger is NOT provided here - it's optional\n" +
      "    UserService,\n" +
      "    // Uncomment to make logger available:\n" +
      "    // Logger\n" +
      "  ],\n" +
      "})\n" +
      "export class AppModule {}\n" +
      "```\n\n" +
      "**Advanced Example - Multiple Optional Dependencies:**\n" +
      "```typescript\n" +
      "export class AnalyticsService {\n" +
      "  constructor(\n" +
      "    @Optional() private googleAnalytics?: GoogleAnalytics,\n" +
      "    @Optional() private mixpanel?: Mixpanel,\n" +
      "    @Optional() private logger?: Logger\n" +
      "  ) {}\n" +
      "  \n" +
      "  trackEvent(eventName: string, data: any): void {\n" +
      "    // Track with Google Analytics if available\n" +
      "    if (this.googleAnalytics) {\n" +
      "      this.googleAnalytics.track(eventName, data);\n" +
      "    }\n" +
      "    \n" +
      "    // Track with Mixpanel if available\n" +
      "    if (this.mixpanel) {\n" +
      "      this.mixpanel.track(eventName, data);\n" +
      "    }\n" +
      "    \n" +
      "    // Log if logger is available\n" +
      "    if (this.logger) {\n" +
      "      this.logger.log(`Event tracked: ${eventName}`);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Conditional Service Registration:**\n" +
      "```typescript\n" +
      "// environment-based service registration\n" +
      "export function provideAnalytics(): Provider[] {\n" +
      "  const providers: Provider[] = [];\n" +
      "  \n" +
      "  if (environment.production) {\n" +
      "    providers.push(GoogleAnalytics);\n" +
      "  }\n" +
      "  \n" +
      "  if (environment.enableMixpanel) {\n" +
      "    providers.push(Mixpanel);\n" +
      "  }\n" +
      "  \n" +
      "  return providers;\n" +
      "}\n" +
      "\n" +
      "@NgModule({\n" +
      "  providers: [\n" +
      "    AnalyticsService,\n" +
      "    ...provideAnalytics() // Conditionally provide analytics services\n" +
      "  ],\n" +
      "})\n" +
      "export class AppModule {}\n" +
      "```\n\n" +
      "**Testing with Optional Dependencies:**\n" +
      "```typescript\n" +
      "describe('UserService', () => {\n" +
      "  let service: UserService;\n" +
      "  let mockLogger: jasmine.SpyObj<Logger>;\n" +
      "  \n" +
      "  beforeEach(() => {\n" +
      "    mockLogger = jasmine.createSpyObj('Logger', ['log', 'error']);\n" +
      "    \n" +
      "    TestBed.configureTestingModule({\n" +
      "      providers: [\n" +
      "        UserService,\n" +
      "        { provide: Logger, useValue: mockLogger } // Provide mock logger\n" +
      "      ]\n" +
      "    });\n" +
      "    \n" +
      "    service = TestBed.inject(UserService);\n" +
      "  });\n" +
      "  \n" +
      "  it('should use logger when available', () => {\n" +
      "    service.getUser('123');\n" +
      "    expect(mockLogger.log).toHaveBeenCalledWith('Fetching user with ID: 123');\n" +
      "  });\n" +
      "});\n" +
      "\n" +
      "// Test without logger\n" +
      "describe('UserService without Logger', () => {\n" +
      "  let service: UserService;\n" +
      "  \n" +
      "  beforeEach(() => {\n" +
      "    TestBed.configureTestingModule({\n" +
      "      providers: [UserService] // No logger provided\n" +
      "    });\n" +
      "    \n" +
      "    service = TestBed.inject(UserService);\n" +
      "  });\n" +
      "  \n" +
      "  it('should work without logger', () => {\n" +
      "    const user = service.getUser('123');\n" +
      "    expect(user).toBeDefined();\n" +
      "    expect(user.id).toBe('123');\n" +
      "  });\n" +
      "});\n" +
      "```\n\n" +
      "**Real-World Example - Feature Flags:**\n" +
      "```typescript\n" +
      "export class FeatureService {\n" +
      "  constructor(\n" +
      "    @Optional() private featureFlags?: FeatureFlagsService,\n" +
      "    @Optional() private analytics?: AnalyticsService\n" +
      "  ) {}\n" +
      "  \n" +
      "  isFeatureEnabled(featureName: string): boolean {\n" +
      "    // Use feature flags service if available\n" +
      "    if (this.featureFlags) {\n" +
      "      return this.featureFlags.isEnabled(featureName);\n" +
      "    }\n" +
      "    \n" +
      "    // Fallback to environment configuration\n" +
      "    return environment.features[featureName] || false;\n" +
      "  }\n" +
      "  \n" +
      "  trackFeatureUsage(featureName: string): void {\n" +
      "    if (this.analytics) {\n" +
      "      this.analytics.trackEvent('feature_used', { feature: featureName });\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Error Handling with Optional Dependencies:**\n" +
      "```typescript\n" +
      "export class ErrorHandlingService {\n" +
      "  constructor(\n" +
      "    @Optional() private logger?: Logger,\n" +
      "    @Optional() private errorReporting?: ErrorReportingService\n" +
      "  ) {}\n" +
      "  \n" +
      "  handleError(error: Error): void {\n" +
      "    // Log error if logger is available\n" +
      "    if (this.logger) {\n" +
      "      this.logger.error(`Error occurred: ${error.message}`);\n" +
      "    }\n" +
      "    \n" +
      "    // Report error if service is available\n" +
      "    if (this.errorReporting) {\n" +
      "      this.errorReporting.reportError(error);\n" +
      "    }\n" +
      "    \n" +
      "    // Fallback to console\n" +
      "    console.error('Unhandled error:', error);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Benefits:**\n" +
      "- **Flexible Configuration**: Services can work with or without optional dependencies\n" +
      "- **Environment-Specific**: Different services for different environments\n" +
      "  - **Testing**: Easy to mock or omit dependencies in tests\n" +
      "- **Feature Flags**: Enable/disable features based on configuration\n" +
      "- **Graceful Degradation**: Application continues to work even if optional services are unavailable\n" +
      "- **Modular Architecture**: Services can be added/removed without breaking existing code\n\n" +
      "**Best Practices:**\n" +
      "- Always check if optional dependency exists before using it\n" +
      "- Provide meaningful fallbacks when optional dependencies are not available\n" +
      "- Use optional dependencies for cross-cutting concerns (logging, analytics, monitoring)\n" +
      "- Document which dependencies are optional in your service documentation\n" +
      "- Consider using factory providers for complex optional dependency scenarios\n" +
      "- Test both scenarios: with and without optional dependencies",
    category: "Dependency Injection",
    difficulty: "intermediate",
    tags: ["@Optional", "dependency-injection", "optional", "decorator", "DI"],
  },
  {
    id: 205,
    question: "What are reactive forms?",
    answer:
      "Reactive forms is a model-driven approach for creating forms in Angular using a reactive style where form inputs and values are provided as streams of input values. They are built around observable streams and provide explicit, immutable access to the form data model.\n\n" +
      "**Key Characteristics:**\n" +
      "- **Model-driven**: Form structure is defined in the component class\n" +
      "- **Reactive**: Built around observable streams\n" +
      "- **Immutable**: Form state changes return new states\n" +
      "- **Explicit**: Direct access to form control instances\n" +
      "- **Testable**: Easy to unit test without UI interaction\n\n" +
      "**Basic Setup:**\n" +
      "```typescript\n" +
      "// 1. Import ReactiveFormsModule\n" +
      "import { ReactiveFormsModule } from '@angular/forms';\n" +
      "\n" +
      "@NgModule({\n" +
      "  imports: [\n" +
      "    // other imports ...\n" +
      "    ReactiveFormsModule\n" +
      "  ],\n" +
      "})\n" +
      "export class AppModule { }\n" +
      "```\n\n" +
      "**2. Create FormControl in Component:**\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "import { FormControl } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'user-profile',\n" +
      "  styleUrls: ['./user-profile.component.css']\n" +
      "})\n" +
      "export class UserProfileComponent {\n" +
      "  userName = new FormControl('');\n" +
      "}\n" +
      "```\n\n" +
      "**3. Register FormControl in Template:**\n" +
      "```html\n" +
      "<label>\n" +
      "  User name:\n" +
      '  <input type="text" [formControl]="userName">\n' +
      "</label>\n" +
      "```\n\n" +
      "**Complete Example:**\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "import { FormControl } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'user-profile',\n" +
      "  styleUrls: ['./user-profile.component.css'],\n" +
      "  template: `\n" +
      "    <label>\n" +
      "      User name:\n" +
      '      <input type="text" [formControl]="userName">\n' +
      "    </label>\n" +
      "    <p>Value: {{ userName.value }}</p>\n" +
      "  `\n" +
      "})\n" +
      "export class UserProfileComponent {\n" +
      "  userName = new FormControl('');\n" +
      "}\n" +
      "```\n\n" +
      "**FormGroup Example:**\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "import { FormGroup, FormControl, Validators } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'user-form',\n" +
      "  template: `\n" +
      '    <form [formGroup]="userForm" (ngSubmit)="onSubmit()">\n' +
      "      <div>\n" +
      "        <label>First Name:</label>\n" +
      '        <input formControlName="firstName" placeholder="Enter first name">\n' +
      "        <div *ngIf=\"userForm.get('firstName')?.invalid && userForm.get('firstName')?.touched\">\n" +
      "          First name is required\n" +
      "        </div>\n" +
      "      </div>\n" +
      "      \n" +
      "      <div>\n" +
      "        <label>Email:</label>\n" +
      '        <input formControlName="email" placeholder="Enter email">\n' +
      "        <div *ngIf=\"userForm.get('email')?.invalid && userForm.get('email')?.touched\">\n" +
      "          <div *ngIf=\"userForm.get('email')?.errors?.['required']\">Email is required</div>\n" +
      "          <div *ngIf=\"userForm.get('email')?.errors?.['email']\">Invalid email format</div>\n" +
      "        </div>\n" +
      "      </div>\n" +
      "      \n" +
      '      <button type="submit" [disabled]="userForm.invalid">Submit</button>\n' +
      "    </form>\n" +
      "  `\n" +
      "})\n" +
      "export class UserFormComponent {\n" +
      "  userForm = new FormGroup({\n" +
      "    firstName: new FormControl('', Validators.required),\n" +
      "    email: new FormControl('', [Validators.required, Validators.email])\n" +
      "  });\n" +
      "  \n" +
      "  onSubmit() {\n" +
      "    if (this.userForm.valid) {\n" +
      "      console.log('Form submitted:', this.userForm.value);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**FormBuilder Example:**\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "import { FormBuilder, FormGroup, Validators } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'user-profile',\n" +
      "  template: `\n" +
      '    <form [formGroup]="profileForm" (ngSubmit)="onSubmit()">\n' +
      '      <div formGroupName="address">\n' +
      '        <input formControlName="street" placeholder="Street">\n' +
      '        <input formControlName="city" placeholder="City">\n' +
      '        <input formControlName="state" placeholder="State">\n' +
      '        <input formControlName="zip" placeholder="ZIP">\n' +
      "      </div>\n" +
      '      <button type="submit">Submit</button>\n' +
      "    </form>\n" +
      "  `\n" +
      "})\n" +
      "export class UserProfileComponent {\n" +
      "  profileForm = this.formBuilder.group({\n" +
      "    firstName: ['', Validators.required],\n" +
      "    lastName: ['', Validators.required],\n" +
      "    address: this.formBuilder.group({\n" +
      "      street: [''],\n" +
      "      city: [''],\n" +
      "      state: [''],\n" +
      "      zip: ['']\n" +
      "    }),\n" +
      "  });\n" +
      "  \n" +
      "  constructor(private formBuilder: FormBuilder) { }\n" +
      "  \n" +
      "  onSubmit() {\n" +
      "    console.log('Profile form submitted:', this.profileForm.value);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**FormArray Example:**\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "import { FormBuilder, FormGroup, FormArray, FormControl } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'dynamic-form',\n" +
      "  template: `\n" +
      '    <form [formGroup]="dynamicForm" (ngSubmit)="onSubmit()">\n' +
      '      <div formArrayName="hobbies">\n' +
      '        <div *ngFor="let hobby of hobbies.controls; let i = index" [formGroupName]="i">\n' +
      '          <input formControlName="name" placeholder="Hobby name">\n' +
      '          <button type="button" (click)="removeHobby(i)">Remove</button>\n' +
      "        </div>\n" +
      '        <button type="button" (click)="addHobby()">Add Hobby</button>\n' +
      "      </div>\n" +
      '      <button type="submit">Submit</button>\n' +
      "    </form>\n" +
      "  `\n" +
      "})\n" +
      "export class DynamicFormComponent {\n" +
      "  dynamicForm = this.formBuilder.group({\n" +
      "    hobbies: this.formBuilder.array([])\n" +
      "  });\n" +
      "  \n" +
      "  constructor(private formBuilder: FormBuilder) { }\n" +
      "  \n" +
      "  get hobbies() {\n" +
      "    return this.dynamicForm.get('hobbies') as FormArray;\n" +
      "  }\n" +
      "  \n" +
      "  addHobby() {\n" +
      "    const hobbyGroup = this.formBuilder.group({\n" +
      "      name: ['']\n" +
      "    });\n" +
      "    this.hobbies.push(hobbyGroup);\n" +
      "  }\n" +
      "  \n" +
      "  removeHobby(index: number) {\n" +
      "    this.hobbies.removeAt(index);\n" +
      "  }\n" +
      "  \n" +
      "  onSubmit() {\n" +
      "    console.log('Dynamic form submitted:', this.dynamicForm.value);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Custom Validators:**\n" +
      "```typescript\n" +
      "import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\n" +
      "\n" +
      "export function passwordMatchValidator(): ValidatorFn {\n" +
      "  return (control: AbstractControl): ValidationErrors | null => {\n" +
      "    const password = control.get('password');\n" +
      "    const confirmPassword = control.get('confirmPassword');\n" +
      "    \n" +
      "    if (password && confirmPassword && password.value !== confirmPassword.value) {\n" +
      "      return { passwordMismatch: true };\n" +
      "    }\n" +
      "    \n" +
      "    return null;\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'password-form',\n" +
      "  template: `\n" +
      '    <form [formGroup]="passwordForm">\n' +
      '      <input formControlName="password" type="password" placeholder="Password">\n' +
      '      <input formControlName="confirmPassword" type="password" placeholder="Confirm Password">\n' +
      "      <div *ngIf=\"passwordForm.hasError('passwordMismatch')\">\n" +
      "        Passwords do not match\n" +
      "      </div>\n" +
      "    </form>\n" +
      "  `\n" +
      "})\n" +
      "export class PasswordFormComponent {\n" +
      "  passwordForm = this.formBuilder.group({\n" +
      "    password: ['', Validators.required],\n" +
      "    confirmPassword: ['', Validators.required]\n" +
      "  }, { validators: passwordMatchValidator() });\n" +
      "  \n" +
      "  constructor(private formBuilder: FormBuilder) { }\n" +
      "}\n" +
      "```\n\n" +
      "**Async Validators:**\n" +
      "```typescript\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';\n" +
      "import { Observable, of } from 'rxjs';\n" +
      "import { map, catchError } from 'rxjs/operators';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class UserService {\n" +
      "  checkEmailExists(email: string): Observable<boolean> {\n" +
      "    // Simulate API call\n" +
      "    return of(email === 'test@example.com').pipe(\n" +
      "      map(exists => exists)\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "export function emailExistsValidator(userService: UserService): AsyncValidatorFn {\n" +
      "  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n" +
      "    if (!control.value) {\n" +
      "      return of(null);\n" +
      "    }\n" +
      "    \n" +
      "    return userService.checkEmailExists(control.value).pipe(\n" +
      "      map(exists => exists ? { emailExists: true } : null),\n" +
      "      catchError(() => of(null))\n" +
      "    );\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'async-form',\n" +
      "  template: `\n" +
      '    <form [formGroup]="asyncForm">\n' +
      '      <input formControlName="email" placeholder="Email">\n' +
      "      <div *ngIf=\"asyncForm.get('email')?.pending\">\n" +
      "        Checking email availability...\n" +
      "      </div>\n" +
      "      <div *ngIf=\"asyncForm.get('email')?.errors?.['emailExists']\">\n" +
      "        Email already exists\n" +
      "      </div>\n" +
      "    </form>\n" +
      "  `\n" +
      "})\n" +
      "export class AsyncFormComponent {\n" +
      "  asyncForm = this.formBuilder.group({\n" +
      "    email: ['', Validators.email, emailExistsValidator(this.userService)]\n" +
      "  });\n" +
      "  \n" +
      "  constructor(\n" +
      "    private formBuilder: FormBuilder,\n" +
      "    private userService: UserService\n" +
      "  ) { }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Benefits:**\n" +
      "- **Predictable**: Form state is explicit and immutable\n" +
      "- **Testable**: Easy to unit test without DOM interaction\n" +
      "- **Scalable**: Better for complex forms with dynamic behavior\n" +
      "- **Type-safe**: Full TypeScript support\n" +
      "- **Reactive**: Built around observable streams\n" +
      "- **Flexible**: Easy to add custom validators and async validation\n" +
      "- **Performance**: Better performance for complex forms\n\n" +
      "**Best Practices:**\n" +
      "- Use FormBuilder for cleaner syntax\n" +
      "- Implement custom validators for complex validation logic\n" +
      "- Use async validators for server-side validation\n" +
      "- Handle form state changes reactively\n" +
      "- Validate on blur or submit to improve UX\n" +
      "- Use FormArray for dynamic form sections\n" +
      "- Implement proper error handling and user feedback",
    category: "Forms",
    difficulty: "intermediate",
    tags: ["reactive-forms", "FormControl", "FormGroup", "FormBuilder", "validation", "observable"],
  },
  {
    id: 206,
    question: "What are template driven forms?",
    answer:
      "Template-driven forms are model-driven forms where you write the logic, validations, controls, etc., in the template part of the code using directives. They are suitable for simple scenarios and use two-way binding with `[(ngModel)]` syntax.\n\n" +
      "**Key Characteristics:**\n" +
      "- **Template-driven**: Form logic is defined in the template\n" +
      "- **Two-way binding**: Uses `[(ngModel)]` for data binding\n" +
      "- **Implicit**: Form controls are created automatically by directives\n" +
      "- **Asynchronous**: Form state changes are asynchronous\n" +
      "- **Mutable**: Form state is mutable\n" +
      "- **Simple**: Easy to implement for basic forms\n\n" +
      "**Basic Setup:**\n" +
      "```typescript\n" +
      "// 1. Import FormsModule\n" +
      "import { BrowserModule } from '@angular/platform-browser';\n" +
      "import { NgModule } from '@angular/core';\n" +
      "import { FormsModule } from '@angular/forms';\n" +
      "import { RegisterComponent } from './app.component';\n" +
      "\n" +
      "@NgModule({\n" +
      "  declarations: [\n" +
      "    RegisterComponent,\n" +
      "  ],\n" +
      "  imports: [\n" +
      "    BrowserModule,\n" +
      "    FormsModule\n" +
      "  ],\n" +
      "  providers: [],\n" +
      "  bootstrap: [RegisterComponent]\n" +
      "})\n" +
      "export class AppModule { }\n" +
      "```\n\n" +
      "**2. Component with Template-Driven Form:**\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "export class RegisterComponent {\n" +
      "  model = {\n" +
      "    name: '',\n" +
      "    email: '',\n" +
      "    password: ''\n" +
      "  };\n" +
      "  \n" +
      "  onSubmit() {\n" +
      "    console.log('Form submitted:', this.model);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. Template with Form Directives:**\n" +
      "```html\n" +
      '<div class="container">\n' +
      "  <h1>Registration Form</h1>\n" +
      '  <form (ngSubmit)="onSubmit()" #registerForm="ngForm">\n' +
      '    <div class="form-group">\n' +
      '      <label for="name">Name</label>\n' +
      '      <input type="text" class="form-control" id="name"\n' +
      "             required\n" +
      '             [(ngModel)]="model.name" name="name"\n' +
      '             #name="ngModel">\n' +
      '      <div [hidden]="name.valid || name.pristine"\n' +
      '           class="alert alert-danger">\n' +
      "        Please enter your name\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      '    <div class="form-group">\n' +
      '      <label for="email">Email</label>\n' +
      '      <input type="email" class="form-control" id="email"\n' +
      "             required email\n" +
      '             [(ngModel)]="model.email" name="email"\n' +
      '             #email="ngModel">\n' +
      '      <div [hidden]="email.valid || email.pristine"\n' +
      '           class="alert alert-danger">\n' +
      "        <div *ngIf=\"email.errors?.['required']\">Email is required</div>\n" +
      "        <div *ngIf=\"email.errors?.['email']\">Invalid email format</div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      '    <div class="form-group">\n' +
      '      <label for="password">Password</label>\n' +
      '      <input type="password" class="form-control" id="password"\n' +
      '             required minlength="6"\n' +
      '             [(ngModel)]="model.password" name="password"\n' +
      '             #password="ngModel">\n' +
      '      <div [hidden]="password.valid || password.pristine"\n' +
      '           class="alert alert-danger">\n' +
      "        <div *ngIf=\"password.errors?.['required']\">Password is required</div>\n" +
      "        <div *ngIf=\"password.errors?.['minlength']\">Password must be at least 6 characters</div>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "    \n" +
      '    <button type="submit" class="btn btn-success" \n' +
      '            [disabled]="!registerForm.form.valid">Submit</button>\n' +
      "  </form>\n" +
      "</div>\n" +
      "```\n\n" +
      "**Complete Example:**\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-register',\n" +
      "  template: `\n" +
      '    <div class="container">\n' +
      "      <h1>Registration Form</h1>\n" +
      '      <form (ngSubmit)="onSubmit()" #registerForm="ngForm">\n' +
      '        <div class="form-group">\n' +
      '          <label for="name">Name</label>\n' +
      '          <input type="text" class="form-control" id="name"\n' +
      "                 required\n" +
      '                 [(ngModel)]="model.name" name="name"\n' +
      '                 #name="ngModel">\n' +
      '          <div [hidden]="name.valid || name.pristine"\n' +
      '               class="alert alert-danger">\n' +
      "            Please enter your name\n" +
      "          </div>\n" +
      "        </div>\n" +
      "        \n" +
      '        <div class="form-group">\n' +
      '          <label for="email">Email</label>\n' +
      '          <input type="email" class="form-control" id="email"\n' +
      "                 required email\n" +
      '                 [(ngModel)]="model.email" name="email"\n' +
      '                 #email="ngModel">\n' +
      '          <div [hidden]="email.valid || email.pristine"\n' +
      '               class="alert alert-danger">\n' +
      "            <div *ngIf=\"email.errors?.['required']\">Email is required</div>\n" +
      "            <div *ngIf=\"email.errors?.['email']\">Invalid email format</div>\n" +
      "          </div>\n" +
      "        </div>\n" +
      "        \n" +
      '        <div class="form-group">\n' +
      '          <label for="password">Password</label>\n' +
      '          <input type="password" class="form-control" id="password"\n' +
      '                 required minlength="6"\n' +
      '                 [(ngModel)]="model.password" name="password"\n' +
      '                 #password="ngModel">\n' +
      '          <div [hidden]="password.valid || password.pristine"\n' +
      '               class="alert alert-danger">\n' +
      "            <div *ngIf=\"password.errors?.['required']\">Password is required</div>\n" +
      "            <div *ngIf=\"password.errors?.['minlength']\">Password must be at least 6 characters</div>\n" +
      "          </div>\n" +
      "        </div>\n" +
      "        \n" +
      '        <button type="submit" class="btn btn-success" \n' +
      '                [disabled]="!registerForm.form.valid">Submit</button>\n' +
      "      </form>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class RegisterComponent {\n" +
      "  model = {\n" +
      "    name: '',\n" +
      "    email: '',\n" +
      "    password: ''\n" +
      "  };\n" +
      "  \n" +
      "  onSubmit() {\n" +
      "    console.log('Form submitted:', this.model);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Custom Validators for Template-Driven Forms:**\n" +
      "```typescript\n" +
      "import { Directive, Input } from '@angular/core';\n" +
      "import { AbstractControl, NG_VALIDATORS, ValidationErrors, Validator } from '@angular/forms';\n" +
      "\n" +
      "@Directive({\n" +
      "  selector: '[appPasswordMatch]',\n" +
      "  providers: [{\n" +
      "    provide: NG_VALIDATORS,\n" +
      "    useExisting: PasswordMatchValidatorDirective,\n" +
      "    multi: true\n" +
      "  }]\n" +
      "})\n" +
      "export class PasswordMatchValidatorDirective implements Validator {\n" +
      "  @Input('appPasswordMatch') passwordField: string;\n" +
      "  \n" +
      "  validate(control: AbstractControl): ValidationErrors | null {\n" +
      "    const password = control.parent?.get(this.passwordField);\n" +
      "    \n" +
      "    if (password && control.value !== password.value) {\n" +
      "      return { passwordMismatch: true };\n" +
      "    }\n" +
      "    \n" +
      "    return null;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Using Custom Validator:**\n" +
      "```html\n" +
      '<form #passwordForm="ngForm">\n' +
      '  <div class="form-group">\n' +
      '    <label for="password">Password</label>\n' +
      '    <input type="password" id="password"\n' +
      '           [(ngModel)]="model.password" name="password"\n' +
      '           required minlength="6">\n' +
      "  </div>\n" +
      "  \n" +
      '  <div class="form-group">\n' +
      '    <label for="confirmPassword">Confirm Password</label>\n' +
      '    <input type="password" id="confirmPassword"\n' +
      '           [(ngModel)]="model.confirmPassword" name="confirmPassword"\n' +
      '           appPasswordMatch="password"\n' +
      '           #confirmPassword="ngModel">\n' +
      "    <div *ngIf=\"confirmPassword.errors?.['passwordMismatch']\">\n" +
      "      Passwords do not match\n" +
      "    </div>\n" +
      "  </div>\n" +
      "</form>\n" +
      "```\n\n" +
      "**Form State Properties:**\n" +
      "```typescript\n" +
      "export class FormStateComponent {\n" +
      "  model = { name: '', email: '' };\n" +
      "  \n" +
      "  // Access form state\n" +
      "  getFormState(form: NgForm) {\n" +
      "    return {\n" +
      "      valid: form.valid,\n" +
      "      invalid: form.invalid,\n      " +
      "      pristine: form.pristine,\n" +
      "      dirty: form.dirty,\n" +
      "      touched: form.touched,\n" +
      "      untouched: form.untouched,\n" +
      "      value: form.value,\n" +
      "      errors: form.errors\n" +
      "    };\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template with Form State:**\n" +
      "```html\n" +
      '<form #myForm="ngForm" (ngSubmit)="onSubmit()">\n' +
      '  <div class="form-group">\n' +
      '    <label for="name">Name</label>\n' +
      '    <input type="text" id="name"\n' +
      '           [(ngModel)]="model.name" name="name"\n' +
      "           required\n" +
      '           #name="ngModel">\n' +
      "    \n" +
      "    <!-- Form state display -->\n" +
      '    <div class="form-state">\n' +
      "      <p>Valid: {{ name.valid }}</p>\n" +
      "      <p>Invalid: {{ name.invalid }}</p>\n" +
      "      <p>Pristine: {{ name.pristine }}</p>\n" +
      "      <p>Dirty: {{ name.dirty }}</p>\n" +
      "      <p>Touched: {{ name.touched }}</p>\n" +
      "      <p>Untouched: {{ name.untouched }}</p>\n" +
      "      <p>Value: {{ name.value }}</p>\n" +
      "      <p>Errors: {{ name.errors | json }}</p>\n" +
      "    </div>\n" +
      "  </div>\n" +
      "  \n" +
      '  <button type="submit" [disabled]="!myForm.valid">Submit</button>\n' +
      "</form>\n" +
      "```\n\n" +
      "**Key Benefits:**\n" +
      "- **Simple**: Easy to implement for basic forms\n" +
      "- **Familiar**: Similar to traditional HTML forms\n" +
      "- **Quick Setup**: Minimal code required\n" +
      "- **Two-way Binding**: Automatic data synchronization\n" +
      "- **Template-based**: Logic is visible in the template\n" +
      "- **Good for Prototyping**: Fast development for simple forms\n\n" +
      "**Limitations:**\n" +
      "- **Less Testable**: Harder to unit test\n" +
      "- **Asynchronous**: Form state changes are async\n" +
      "- **Mutable**: Form state is mutable\n" +
      "- **Less Scalable**: Not ideal for complex forms\n" +
      "- **Template Bloat**: Can make templates complex\n" +
      "- **Limited Control**: Less control over form behavior\n\n" +
      "**Best Practices:**\n" +
      "- Use for simple forms with basic validation\n" +
      "- Keep validation logic simple\n" +
      "- Use template reference variables for form state access\n" +
      "- Implement custom validators as directives\n" +
      "- Handle form submission properly\n" +
      "- Use proper error messaging\n" +
      "- Consider reactive forms for complex scenarios",
    category: "Forms",
    difficulty: "beginner",
    tags: ["template-driven-forms", "ngModel", "FormsModule", "two-way-binding", "validation"],
  },
  {
    id: 207,
    question: "What are the differences between reactive forms and template driven forms?",
    answer:
      "Reactive forms and template-driven forms are two different approaches to handling forms in Angular. Each has its own strengths and use cases.\n\n" +
      "**Key Differences:**\n\n" +
      "| **Feature** | **Reactive Forms** | **Template-Driven Forms** |\n" +
      "|--------------|-------------------|--------------------------|\n" +
      "| **Form Model Setup** | Created (FormControl instance) in component explicitly | Created by directives |\n" +
      "| **Data Updates** | Synchronous | Asynchronous |\n" +
      "| **Form Custom Validation** | Defined as Functions | Defined as Directives |\n" +
      "| **Testing** | No interaction with change detection cycle | Need knowledge of the change detection process |\n" +
      "| **Mutability** | Immutable (by always returning new value for FormControl instance) | Mutable (Property always modified to new value) |\n" +
      "| **Scalability** | More scalable using low-level APIs | Less scalable using due to abstraction on APIs |\n" +
      "| **Complexity** | More complex setup, better for complex forms | Simpler setup, good for simple forms |\n" +
      "| **Type Safety** | Full TypeScript support | Limited TypeScript support |\n" +
      "| **Performance** | Better performance for complex forms | Good performance for simple forms |\n" +
      "| **Form State** | Explicit and immutable | Implicit and mutable |\n" +
      "| **Validation** | Synchronous and asynchronous validators | Primarily synchronous validators |\n" +
      "| **Dynamic Forms** | Excellent support with FormArray | Limited support |\n" +
      "| **Reactive Programming** | Built around observables | Not reactive |\n\n" +
      "**Reactive Forms Example:**\n" +
      "```typescript\n" +
      "// Component\n" +
      "export class ReactiveFormComponent {\n" +
      "  userForm = new FormGroup({\n" +
      "    firstName: new FormControl('', Validators.required),\n" +
      "    email: new FormControl('', [Validators.required, Validators.email]),\n" +
      "    address: new FormGroup({\n" +
      "      street: new FormControl(''),\n" +
      "      city: new FormControl('')\n" +
      "    })\n" +
      "  });\n" +
      "  \n" +
      "  onSubmit() {\n" +
      "    if (this.userForm.valid) {\n" +
      "      console.log('Form submitted:', this.userForm.value);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "```html\n" +
      "<!-- Template -->\n" +
      '<form [formGroup]="userForm" (ngSubmit)="onSubmit()">\n' +
      '  <input formControlName="firstName" placeholder="First Name">\n' +
      '  <input formControlName="email" placeholder="Email">\n' +
      "  \n" +
      '  <div formGroupName="address">\n' +
      '    <input formControlName="street" placeholder="Street">\n' +
      '    <input formControlName="city" placeholder="City">\n' +
      "  </div>\n" +
      "  \n" +
      '  <button type="submit" [disabled]="userForm.invalid">Submit</button>\n' +
      "</form>\n" +
      "```\n\n" +
      "**Template-Driven Forms Example:**\n" +
      "```typescript\n" +
      "// Component\n" +
      "export class TemplateFormComponent {\n" +
      "  model = {\n" +
      "    firstName: '',\n" +
      "    email: '',\n" +
      "    address: {\n" +
      "      street: '',\n" +
      "      city: ''\n" +
      "    }\n" +
      "  };\n" +
      "  \n" +
      "  onSubmit() {\n" +
      "    console.log('Form submitted:', this.model);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "```html\n" +
      "<!-- Template -->\n" +
      '<form (ngSubmit)="onSubmit()" #userForm="ngForm">\n' +
      '  <input [(ngModel)]="model.firstName" name="firstName" \n' +
      '         required placeholder="First Name">\n' +
      '  <input [(ngModel)]="model.email" name="email" \n' +
      '         required email placeholder="Email">\n' +
      "  \n" +
      '  <div ngModelGroup="address">\n' +
      '    <input [(ngModel)]="model.address.street" name="street" \n' +
      '           placeholder="Street">\n' +
      '    <input [(ngModel)]="model.address.city" name="city" \n' +
      '           placeholder="City">\n' +
      "  </div>\n" +
      "  \n" +
      '  <button type="submit" [disabled]="!userForm.form.valid">Submit</button>\n' +
      "</form>\n" +
      "```\n\n" +
      "**Validation Comparison:**\n\n" +
      "**Reactive Forms - Custom Validator:**\n" +
      "```typescript\n" +
      "export function passwordMatchValidator(): ValidatorFn {\n" +
      "  return (control: AbstractControl): ValidationErrors | null => {\n" +
      "    const password = control.get('password');\n" +
      "    const confirmPassword = control.get('confirmPassword');\n" +
      "    \n" +
      "    if (password && confirmPassword && password.value !== confirmPassword.value) {\n" +
      "      return { passwordMismatch: true };\n" +
      "    }\n" +
      "    return null;\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "// Usage\n" +
      "passwordForm = new FormGroup({\n" +
      "  password: new FormControl('', Validators.required),\n" +
      "  confirmPassword: new FormControl('', Validators.required)\n" +
      "}, { validators: passwordMatchValidator() });\n" +
      "```\n\n" +
      "**Template-Driven Forms - Custom Validator:**\n" +
      "```typescript\n" +
      "@Directive({\n" +
      "  selector: '[appPasswordMatch]',\n" +
      "  providers: [{\n" +
      "    provide: NG_VALIDATORS,\n" +
      "    useExisting: PasswordMatchValidatorDirective,\n" +
      "    multi: true\n" +
      "  }]\n" +
      "})\n" +
      "export class PasswordMatchValidatorDirective implements Validator {\n" +
      "  @Input('appPasswordMatch') passwordField: string;\n" +
      "  \n" +
      "  validate(control: AbstractControl): ValidationErrors | null {\n" +
      "    const password = control.parent?.get(this.passwordField);\n" +
      "    \n" +
      "    if (password && control.value !== password.value) {\n" +
      "      return { passwordMismatch: true };\n" +
      "    }\n" +
      "    return null;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "```html\n" +
      "<!-- Usage -->\n" +
      '<input [(ngModel)]="model.password" name="password" required>\n' +
      '<input [(ngModel)]="model.confirmPassword" name="confirmPassword" \n' +
      '       appPasswordMatch="password" required>\n' +
      "```\n\n" +
      "**Testing Comparison:**\n\n" +
      "**Reactive Forms Testing:**\n" +
      "```typescript\n" +
      "describe('ReactiveFormComponent', () => {\n" +
      "  let component: ReactiveFormComponent;\n" +
      "  \n" +
      "  beforeEach(() => {\n" +
      "    TestBed.configureTestingModule({\n" +
      "      declarations: [ReactiveFormComponent],\n" +
      "      imports: [ReactiveFormsModule]\n" +
      "    });\n" +
      "    \n" +
      "    component = TestBed.createComponent(ReactiveFormComponent).componentInstance;\n" +
      "  });\n" +
      "  \n" +
      "  it('should create form with validators', () => {\n" +
      "    expect(component.userForm.get('firstName')?.hasError('required')).toBe(true);\n" +
      "    expect(component.userForm.get('email')?.hasError('required')).toBe(true);\n" +
      "  });\n" +
      "  \n" +
      "  it('should validate email format', () => {\n" +
      "    const emailControl = component.userForm.get('email');\n" +
      "    emailControl?.setValue('invalid-email');\n" +
      "    expect(emailControl?.hasError('email')).toBe(true);\n" +
      "  });\n" +
      "});\n" +
      "```\n\n" +
      "**Template-Driven Forms Testing:**\n" +
      "```typescript\n" +
      "describe('TemplateFormComponent', () => {\n" +
      "  let component: TemplateFormComponent;\n" +
      "  let fixture: ComponentFixture<TemplateFormComponent>;\n" +
      "  \n" +
      "  beforeEach(() => {\n" +
      "    TestBed.configureTestingModule({\n" +
      "      declarations: [TemplateFormComponent],\n" +
      "      imports: [FormsModule]\n" +
      "    });\n" +
      "    \n" +
      "    fixture = TestBed.createComponent(TemplateFormComponent);\n" +
      "    component = fixture.componentInstance;\n" +
      "    fixture.detectChanges();\n" +
      "  });\n" +
      "  \n" +
      "  it('should validate required fields', () => {\n" +
      "    const firstNameInput = fixture.debugElement.query(By.css('input[name=\"firstName\"]'));\n" +
      "    firstNameInput.nativeElement.value = '';\n" +
      "    firstNameInput.nativeElement.dispatchEvent(new Event('input'));\n" +
      "    fixture.detectChanges();\n" +
      "    \n" +
      "    // Need to trigger change detection for template-driven forms\n" +
      "    expect(component.model.firstName).toBe('');\n" +
      "  });\n" +
      "});\n" +
      "```\n\n" +
      "**Dynamic Forms Comparison:**\n\n" +
      "**Reactive Forms - Dynamic FormArray:**\n" +
      "```typescript\n" +
      "export class DynamicReactiveFormComponent {\n" +
      "  dynamicForm = new FormGroup({\n" +
      "    items: new FormArray([])\n" +
      "  });\n" +
      "  \n" +
      "  get items() {\n" +
      "    return this.dynamicForm.get('items') as FormArray;\n" +
      "  }\n" +
      "  \n" +
      "  addItem() {\n" +
      "    const itemGroup = new FormGroup({\n" +
      "      name: new FormControl('', Validators.required),\n" +
      "      value: new FormControl('', Validators.required)\n" +
      "    });\n" +
      "    this.items.push(itemGroup);\n" +
      "  }\n" +
      "  \n" +
      "  removeItem(index: number) {\n" +
      "    this.items.removeAt(index);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Template-Driven Forms - Limited Dynamic Support:**\n" +
      "```typescript\n" +
      "export class DynamicTemplateFormComponent {\n" +
      "  items: any[] = [];\n" +
      "  \n" +
      "  addItem() {\n" +
      "    this.items.push({ name: '', value: '' });\n" +
      "  }\n" +
      "  \n" +
      "  removeItem(index: number) {\n" +
      "    this.items.splice(index, 1);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**When to Use Each:**\n\n" +
      "**Use Reactive Forms When:**\n" +
      "- Building complex forms with dynamic behavior\n" +
      "- Need fine-grained control over form validation\n" +
      "- Working with large forms or forms with many fields\n" +
      "- Need to implement complex validation logic\n" +
      "- Want to test forms without DOM interaction\n" +
      "- Need to integrate with reactive programming patterns\n" +
      "- Building forms that change based on user input\n" +
      "- Need to implement custom form controls\n\n" +
      "**Use Template-Driven Forms When:**\n" +
      "- Building simple forms with basic validation\n" +
      "- Need quick prototyping\n" +
      "- Working with small forms\n" +
      "- Want familiar HTML form patterns\n" +
      "- Need simple two-way data binding\n" +
      "- Building forms that don't change dynamically\n" +
      "- Working with teams new to Angular\n\n" +
      "**Migration Considerations:**\n" +
      "- Template-driven forms can be migrated to reactive forms\n" +
      "- Reactive forms provide better long-term maintainability\n" +
      "- Consider the complexity and future requirements\n" +
      "- Evaluate team expertise and project timeline\n" +
      "- Reactive forms are recommended for new projects\n" +
      "- Template-driven forms are good for simple, static forms",
    category: "Forms",
    difficulty: "intermediate",
    tags: ["reactive-forms", "template-driven-forms", "comparison", "validation", "testing"],
  },
  {
    id: 208,
    question: "How do you update specific properties of a form model?",
    answer:
      "You can update specific properties of a form model using the `patchValue()` method for partial updates or `setValue()` method for complete updates. These methods are available on FormGroup, FormControl, and FormArray instances.\n\n" +
      "**1. Using patchValue() Method:**\n" +
      "The `patchValue()` method allows you to update specific properties without affecting other form controls.\n" +
      "```typescript\n" +
      "export class UserProfileComponent {\n" +
      "  userProfile = new FormGroup({\n" +
      "    firstName: new FormControl(''),\n" +
      "    lastName: new FormControl(''),\n      " +
      "    email: new FormControl(''),\n" +
      "    address: new FormGroup({\n" +
      "      street: new FormControl(''),\n" +
      "      city: new FormControl(''),\n" +
      "      state: new FormControl(''),\n" +
      "      zip: new FormControl('')\n" +
      "    }),\n" +
      "    preferences: new FormGroup({\n" +
      "      newsletter: new FormControl(false),\n" +
      "      notifications: new FormControl(true)\n" +
      "    })\n" +
      "  });\n" +
      "  \n" +
      "  updateProfile() {\n" +
      "    // Update specific properties\n" +
      "    this.userProfile.patchValue({\n" +
      "      firstName: 'John',\n" +
      "      address: {\n" +
      "        street: '98 Crescent Street'\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  updateAddress() {\n" +
      "    // Update nested form group\n" +
      "    this.userProfile.patchValue({\n" +
      "      address: {\n" +
      "        street: '123 Main St',\n" +
      "        city: 'New York',\n" +
      "        state: 'NY',\n" +
      "        zip: '10001'\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**2. Using setValue() Method:**\n" +
      "The `setValue()` method requires you to provide values for ALL form controls.\n" +
      "```typescript\n" +
      "export class CompleteFormComponent {\n" +
      "  userForm = new FormGroup({\n" +
      "    firstName: new FormControl(''),\n" +
      "    lastName: new FormControl(''),\n" +
      "    email: new FormControl('')\n" +
      "  });\n" +
      "  \n" +
      "  setCompleteForm() {\n" +
      "    // Must provide values for ALL controls\n" +
      "    this.userForm.setValue({\n" +
      "      firstName: 'John',\n" +
      "      lastName: 'Doe',\n" +
      "      email: 'john.doe@example.com'\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. Updating Individual FormControl:**\n" +
      "```typescript\n" +
      "export class IndividualControlComponent {\n" +
      "  firstName = new FormControl('');\n" +
      "  lastName = new FormControl('');\n" +
      "  email = new FormControl('');\n" +
      "  \n" +
      "  updateFirstName() {\n" +
      "    this.firstName.setValue('John');\n" +
      "  }\n" +
      "  \n" +
      "  updateEmail() {\n" +
      "    this.email.patchValue('john@example.com');\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**4. Updating FormArray:**\n" +
      "```typescript\n" +
      "export class DynamicFormComponent {\n" +
      "  dynamicForm = new FormGroup({\n" +
      "    items: new FormArray([])\n" +
      "  });\n" +
      "  \n" +
      "  get items() {\n" +
      "    return this.dynamicForm.get('items') as FormArray;\n" +
      "  }\n" +
      "  \n" +
      "  updateItems() {\n" +
      "    // Update specific items in FormArray\n" +
      "    this.items.patchValue([\n      " +
      "      { name: 'Item 1', value: 'Value 1' },\n" +
      "      { name: 'Item 2', value: 'Value 2' }\n" +
      "    ]);\n" +
      "  }\n" +
      "  \n" +
      "  updateSpecificItem(index: number) {\n" +
      "    // Update specific item at index\n" +
      "    const itemGroup = this.items.at(index) as FormGroup;\n" +
      "    itemGroup.patchValue({\n" +
      "      name: 'Updated Item',\n" +
      "      value: 'Updated Value'\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**5. Real-World Example - User Profile Update:**\n" +
      "```typescript\n" +
      "export class UserProfileService {\n" +
      "  constructor(private http: HttpClient) {}\n" +
      "  \n" +
      "  getUserProfile(userId: string): Observable<UserProfile> {\n" +
      "    return this.http.get<UserProfile>(`/api/users/${userId}`);\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "export class UserProfileComponent implements OnInit {\n" +
      "  userProfile = new FormGroup({\n" +
      "    id: new FormControl(''),\n" +
      "    firstName: new FormControl('', Validators.required),\n" +
      "    lastName: new FormControl('', Validators.required),\n" +
      "    email: new FormControl('', [Validators.required, Validators.email]),\n" +
      "    phone: new FormControl(''),\n" +
      "    address: new FormGroup({\n" +
      "      street: new FormControl(''),\n" +
      "      city: new FormControl(''),\n" +
      "      state: new FormControl(''),\n" +
      "      zip: new FormControl(''),\n" +
      "      country: new FormControl('')\n" +
      "    }),\n" +
      "    preferences: new FormGroup({\n" +
      "      newsletter: new FormControl(false),\n" +
      "      notifications: new FormControl(true),\n" +
      "      theme: new FormControl('light')\n" +
      "    })\n" +
      "  });\n" +
      "  \n" +
      "  constructor(private userService: UserProfileService) {}\n" +
      "  \n" +
      "  ngOnInit() {\n" +
      "    this.loadUserProfile();\n" +
      "  }\n" +
      "  \n" +
      "  loadUserProfile() {\n" +
      "    this.userService.getUserProfile('123').subscribe(profile => {\n" +
      "      // Load complete profile data\n" +
      "      this.userProfile.patchValue(profile);\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  updateBasicInfo() {\n" +
      "    // Update only basic information\n" +
      "    this.userProfile.patchValue({\n" +
      "      firstName: 'John',\n" +
      "      lastName: 'Doe',\n" +
      "      email: 'john.doe@example.com'\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  updateAddress() {\n" +
      "    // Update only address information\n" +
      "    this.userProfile.patchValue({\n" +
      "      address: {\n" +
      "        street: '123 Main Street',\n" +
      "        city: 'New York',\n" +
      "        state: 'NY',\n" +
      "        zip: '10001',\n" +
      "        country: 'USA'\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  updatePreferences() {\n" +
      "    // Update only preferences\n" +
      "    this.userProfile.patchValue({\n" +
      "      preferences: {\n" +
      "        newsletter: true,\n" +
      "        notifications: false,\n" +
      "        theme: 'dark'\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  updateSingleField(fieldName: string, value: any) {\n" +
      "    // Update a single field\n" +
      "    this.userProfile.patchValue({\n" +
      "      [fieldName]: value\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**6. Conditional Updates Based on Form State:**\n" +
      "```typescript\n" +
      "export class ConditionalUpdateComponent {\n" +
      "  userForm = new FormGroup({\n" +
      "    firstName: new FormControl(''),\n" +
      "    lastName: new FormControl(''),\n" +
      "    email: new FormControl(''),\n" +
      "    isVip: new FormControl(false)\n" +
      "  });\n" +
      "  \n" +
      "  updateBasedOnCondition() {\n" +
      "    const isVip = this.userForm.get('isVip')?.value;\n" +
      "    \n" +
      "    if (isVip) {\n" +
      "      // Update VIP user with special privileges\n" +
      "      this.userForm.patchValue({\n" +
      "        firstName: 'VIP ' + this.userForm.get('firstName')?.value,\n" +
      "        email: 'vip@example.com'\n" +
      "      });\n" +
      "    } else {\n" +
      "      // Update regular user\n" +
      "      this.userForm.patchValue({\n" +
      "        firstName: this.userForm.get('firstName')?.value?.replace('VIP ', ''),\n" +
      "        email: 'user@example.com'\n" +
      "      });\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**7. Template Integration:**\n" +
      "```html\n" +
      '<form [formGroup]="userProfile">\n' +
      '  <div formGroupName="address">\n' +
      '    <input formControlName="street" placeholder="Street">\n' +
      '    <input formControlName="city" placeholder="City">\n' +
      '    <input formControlName="state" placeholder="State">\n' +
      '    <input formControlName="zip" placeholder="ZIP">\n' +
      "  </div>\n" +
      "  \n" +
      '  <div formGroupName="preferences">\n' +
      "    <label>\n" +
      '      <input type="checkbox" formControlName="newsletter">\n' +
      "      Subscribe to Newsletter\n" +
      "    </label>\n" +
      "    <label>\n" +
      '      <input type="checkbox" formControlName="notifications">\n' +
      "      Enable Notifications\n" +
      "    </label>\n" +
      "  </div>\n" +
      "  \n" +
      '  <button type="button" (click)="updateBasicInfo()">Update Basic Info</button>\n' +
      '  <button type="button" (click)="updateAddress()">Update Address</button>\n' +
      '  <button type="button" (click)="updatePreferences()">Update Preferences</button>\n' +
      "</form>\n" +
      "```\n\n" +
      "**Key Differences:**\n" +
      "- **patchValue()**: Updates only specified properties, leaves others unchanged\n" +
      "- **setValue()**: Requires values for ALL form controls, throws error if any are missing\n" +
      "- **patchValue()**: More flexible and commonly used\n" +
      "- **setValue()**: Useful when you have complete data to populate the form\n\n" +
      "**Best Practices:**\n" +
      "- Use `patchValue()` for partial updates\n" +
      "- Use `setValue()` when you have complete form data\n" +
      "- Always check form validity after updates\n" +
      "- Handle nested FormGroups and FormArrays properly\n" +
      "- Use TypeScript interfaces for type safety\n" +
      "- Consider form state when updating values\n" +
      "- Test form updates thoroughly\n" +
      "- Document which properties are being updated",
    category: "Forms",
    difficulty: "intermediate",
    tags: ["patchValue", "setValue", "FormGroup", "FormControl", "FormArray", "update"],
  },
  {
    id: 209,
    question: "What is the purpose of FormBuilder?",
    answer:
      "FormBuilder is used as syntactic sugar for easily creating instances of a FormControl, FormGroup, or FormArray. This is helpful to reduce the amount of boilerplate needed to build complex reactive forms. It is available as an injectable helper class of the `@angular/forms` package.\n\n" +
      "**Key Benefits:**\n" +
      "- **Reduces Boilerplate**: Less code to create form controls\n" +
      "- **Cleaner Syntax**: More readable form definitions\n" +
      "- **Easier Maintenance**: Simpler to modify form structure\n" +
      "- **Type Safety**: Better TypeScript support\n" +
      "- **Consistency**: Standardized way to create forms\n\n" +
      "**Basic Usage:**\n" +
      "```typescript\n" +
      "import { FormBuilder, FormGroup, Validators } from '@angular/forms';\n" +
      "\n" +
      "export class UserProfileComponent {\n" +
      "  profileForm = this.formBuilder.group({\n" +
      "    firstName: ['', Validators.required],\n" +
      "    lastName: ['', Validators.required],\n" +
      "    email: ['', [Validators.required, Validators.email]],\n" +
      "    address: this.formBuilder.group({\n" +
      "      street: [''],\n" +
      "      city: [''],\n" +
      "      state: [''],\n" +
      "      zip: ['']\n" +
      "    }),\n" +
      "  });\n" +
      "  \n" +
      "  constructor(private formBuilder: FormBuilder) { }\n" +
      "}\n" +
      "```\n\n" +
      "**Comparison - Without FormBuilder:**\n" +
      "```typescript\n" +
      "// Without FormBuilder - More verbose\n" +
      "export class WithoutFormBuilderComponent {\n" +
      "  profileForm = new FormGroup({\n" +
      "    firstName: new FormControl('', Validators.required),\n" +
      "    lastName: new FormControl('', Validators.required),\n" +
      "    email: new FormControl('', [Validators.required, Validators.email]),\n" +
      "    address: new FormGroup({\n" +
      "      street: new FormControl(''),\n" +
      "      city: new FormControl(''),\n" +
      "      state: new FormControl(''),\n" +
      "      zip: new FormControl('')\n" +
      "    }),\n" +
      "  });\n" +
      "}\n" +
      "```\n\n" +
      "**With FormBuilder - Cleaner:**\n" +
      "```typescript\n" +
      "// With FormBuilder - Cleaner syntax\n" +
      "export class WithFormBuilderComponent {\n" +
      "  profileForm = this.formBuilder.group({\n" +
      "    firstName: ['', Validators.required],\n" +
      "    lastName: ['', Validators.required],\n" +
      "    email: ['', [Validators.required, Validators.email]],\n" +
      "    address: this.formBuilder.group({\n" +
      "      street: [''],\n" +
      "      city: [''],\n" +
      "      state: [''],\n" +
      "      zip: ['']\n" +
      "    }),\n" +
      "  });\n" +
      "  \n" +
      "  constructor(private formBuilder: FormBuilder) { }\n" +
      "}\n" +
      "```\n\n" +
      "**FormBuilder Methods:**\n\n" +
      "**1. group() - Creates FormGroup:**\n" +
      "```typescript\n" +
      "export class FormGroupExample {\n" +
      "  userForm = this.formBuilder.group({\n" +
      "    firstName: ['John', Validators.required],\n" +
      "    lastName: ['Doe', Validators.required],\n" +
      "    email: ['john@example.com', [Validators.required, Validators.email]],\n" +
      "    age: [25, [Validators.min(18), Validators.max(100)]]\n" +
      "  });\n" +
      "  \n" +
      "  constructor(private formBuilder: FormBuilder) { }\n" +
      "}\n" +
      "```\n\n" +
      "**2. control() - Creates FormControl:**\n" +
      "```typescript\n" +
      "export class FormControlExample {\n" +
      "  firstName = this.formBuilder.control('John', Validators.required);\n" +
      "  lastName = this.formBuilder.control('Doe', Validators.required);\n" +
      "  email = this.formBuilder.control('john@example.com', [Validators.required, Validators.email]);\n" +
      "  \n" +
      "  constructor(private formBuilder: FormBuilder) { }\n" +
      "}\n" +
      "```\n\n" +
      "**3. array() - Creates FormArray:**\n" +
      "```typescript\n" +
      "export class FormArrayExample {\n" +
      "  dynamicForm = this.formBuilder.group({\n" +
      "    items: this.formBuilder.array([\n" +
      "      this.formBuilder.group({\n" +
      "        name: ['', Validators.required],\n" +
      "        value: ['', Validators.required]\n" +
      "      })\n" +
      "    ])\n" +
      "  });\n" +
      "  \n" +
      "  get items() {\n" +
      "    return this.dynamicForm.get('items') as FormArray;\n" +
      "  }\n" +
      "  \n" +
      "  addItem() {\n" +
      "    const itemGroup = this.formBuilder.group({\n" +
      "      name: ['', Validators.required],\n" +
      "      value: ['', Validators.required]\n" +
      "    });\n" +
      "    this.items.push(itemGroup);\n" +
      "  }\n" +
      "  \n" +
      "  constructor(private formBuilder: FormBuilder) { }\n" +
      "}\n" +
      "```\n\n" +
      "**Complex Form Example:**\n" +
      "```typescript\n" +
      "export class ComplexFormComponent {\n" +
      "  userForm = this.formBuilder.group({\n" +
      "    personalInfo: this.formBuilder.group({\n" +
      "      firstName: ['', Validators.required],\n" +
      "      lastName: ['', Validators.required],\n" +
      "      email: ['', [Validators.required, Validators.email]],\n" +
      "      phone: ['', Validators.pattern(/^[0-9]{10}$/)]\n" +
      "    }),\n" +
      "    address: this.formBuilder.group({\n" +
      "      street: ['', Validators.required],\n" +
      "      city: ['', Validators.required],\n" +
      "      state: ['', Validators.required],\n" +
      "      zip: ['', [Validators.required, Validators.pattern(/^[0-9]{5}$/)]]\n" +
      "    }),\n" +
      "    preferences: this.formBuilder.group({\n" +
      "      newsletter: [false],\n" +
      "      notifications: [true],\n" +
      "      theme: ['light', Validators.required]\n" +
      "    }),\n" +
      "    skills: this.formBuilder.array([\n" +
      "      this.formBuilder.control('', Validators.required)\n" +
      "    ])\n" +
      "  });\n" +
      "  \n" +
      "  get skills() {\n" +
      "    return this.userForm.get('skills') as FormArray;\n" +
      "  }\n" +
      "  \n" +
      "  addSkill() {\n" +
      "    this.skills.push(this.formBuilder.control('', Validators.required));\n" +
      "  }\n" +
      "  \n" +
      "  removeSkill(index: number) {\n" +
      "    this.skills.removeAt(index);\n" +
      "  }\n" +
      "  \n" +
      "  constructor(private formBuilder: FormBuilder) { }\n" +
      "}\n" +
      "```\n\n" +
      "**Dynamic Form Creation:**\n" +
      "```typescript\n" +
      "export class DynamicFormBuilderComponent {\n" +
      "  formConfig = {\n" +
      "    firstName: { value: '', validators: [Validators.required] },\n" +
      "    lastName: { value: '', validators: [Validators.required] },\n" +
      "    email: { value: '', validators: [Validators.required, Validators.email] },\n" +
      "    age: { value: 0, validators: [Validators.min(18)] }\n" +
      "  };\n" +
      "  \n" +
      "  dynamicForm: FormGroup;\n" +
      "  \n" +
      "  constructor(private formBuilder: FormBuilder) {\n" +
      "    this.createDynamicForm();\n" +
      "  }\n" +
      "  \n" +
      "  createDynamicForm() {\n" +
      "    const formControls: { [key: string]: FormControl } = {};\n" +
      "    \n" +
      "    Object.keys(this.formConfig).forEach(key => {\n" +
      "      const config = this.formConfig[key];\n" +
      "      formControls[key] = this.formBuilder.control(\n" +
      "        config.value,\n" +
      "        config.validators\n" +
      "      );\n" +
      "    });\n" +
      "    \n" +
      "    this.dynamicForm = this.formBuilder.group(formControls);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**FormBuilder with Custom Validators:**\n" +
      "```typescript\n" +
      "export class CustomValidatorFormComponent {\n" +
      "  passwordForm = this.formBuilder.group({\n" +
      "    password: ['', [Validators.required, Validators.minLength(8)]],\n" +
      "    confirmPassword: ['', Validators.required]\n" +
      "  }, { validators: this.passwordMatchValidator });\n" +
      "  \n" +
      "  passwordMatchValidator(control: AbstractControl): ValidationErrors | null {\n" +
      "    const password = control.get('password');\n" +
      "    const confirmPassword = control.get('confirmPassword');\n" +
      "    \n" +
      "    if (password && confirmPassword && password.value !== confirmPassword.value) {\n" +
      "      return { passwordMismatch: true };\n" +
      "    }\n" +
      "    \n" +
      "    return null;\n" +
      "  }\n" +
      "  \n" +
      "  constructor(private formBuilder: FormBuilder) { }\n" +
      "}\n" +
      "```\n\n" +
      "**FormBuilder with Async Validators:**\n" +
      "```typescript\n" +
      "export class AsyncValidatorFormComponent {\n" +
      "  userForm = this.formBuilder.group({\n" +
      "    username: ['', Validators.required, this.usernameExistsValidator.bind(this)],\n" +
      "    email: ['', [Validators.required, Validators.email], this.emailExistsValidator.bind(this)]\n" +
      "  });\n" +
      "  \n" +
      "  usernameExistsValidator(control: AbstractControl): Observable<ValidationErrors | null> {\n" +
      "    if (!control.value) {\n" +
      "      return of(null);\n" +
      "    }\n" +
      "    \n" +
      "    return this.userService.checkUsernameExists(control.value).pipe(\n" +
      "      map(exists => exists ? { usernameExists: true } : null),\n" +
      "      catchError(() => of(null))\n" +
      "    );\n" +
      "  }\n" +
      "  \n" +
      "  emailExistsValidator(control: AbstractControl): Observable<ValidationErrors | null> {\n" +
      "    if (!control.value) {\n" +
      "      return of(null);\n" +
      "    }\n" +
      "    \n" +
      "    return this.userService.checkEmailExists(control.value).pipe(\n" +
      "      map(exists => exists ? { emailExists: true } : null),\n" +
      "      catchError(() => of(null))\n" +
      "    );\n" +
      "  }\n" +
      "  \n" +
      "  constructor(\n" +
      "    private formBuilder: FormBuilder,\n" +
      "    private userService: UserService\n" +
      "  ) { }\n" +
      "}\n" +
      "```\n\n" +
      "**Template Integration:**\n" +
      "```html\n" +
      '<form [formGroup]="userForm" (ngSubmit)="onSubmit()">\n' +
      '  <div formGroupName="personalInfo">\n' +
      '    <input formControlName="firstName" placeholder="First Name">\n' +
      '    <input formControlName="lastName" placeholder="Last Name">\n' +
      '    <input formControlName="email" placeholder="Email">\n' +
      '    <input formControlName="phone" placeholder="Phone">\n' +
      "  </div>\n" +
      "  \n" +
      '  <div formGroupName="address">\n' +
      '    <input formControlName="street" placeholder="Street">\n' +
      '    <input formControlName="city" placeholder="City">\n' +
      '    <input formControlName="state" placeholder="State">\n' +
      '    <input formControlName="zip" placeholder="ZIP">\n' +
      "  </div>\n" +
      "  \n" +
      '  <div formGroupName="preferences">\n' +
      "    <label>\n" +
      '      <input type="checkbox" formControlName="newsletter">\n' +
      "      Newsletter\n" +
      "    </label>\n" +
      "    <label>\n" +
      '      <input type="checkbox" formControlName="notifications">\n' +
      "      Notifications\n" +
      "    </label>\n" +
      '    <select formControlName="theme">\n' +
      '      <option value="light">Light</option>\n' +
      '      <option value="dark">Dark</option>\n' +
      "    </select>\n" +
      "  </div>\n" +
      "  \n" +
      '  <div formArrayName="skills">\n' +
      '    <div *ngFor="let skill of skills.controls; let i = index">\n' +
      '      <input [formControlName]="i" placeholder="Skill">\n' +
      '      <button type="button" (click)="removeSkill(i)">Remove</button>\n' +
      "    </div>\n" +
      '    <button type="button" (click)="addSkill()">Add Skill</button>\n' +
      "  </div>\n" +
      "  \n" +
      '  <button type="submit" [disabled]="userForm.invalid">Submit</button>\n' +
      "</form>\n" +
      "```\n\n" +
      "**Key Advantages:**\n" +
      "- **Reduced Boilerplate**: Less code to write and maintain\n" +
      "- **Better Readability**: Cleaner, more intuitive syntax\n" +
      "- **Easier Refactoring**: Simple to modify form structure\n" +
      "- **Consistent API**: Standardized way to create forms\n" +
      "- **Type Safety**: Better TypeScript integration\n" +
      "- **Flexibility**: Easy to create dynamic forms\n" +
      "- **Maintainability**: Easier to understand and modify\n\n" +
      "**Best Practices:**\n" +
      "- Use FormBuilder for all reactive forms\n" +
      "- Inject FormBuilder in constructor\n" +
      "- Use descriptive form control names\n" +
      "- Group related controls in FormGroups\n" +
      "- Use FormArrays for dynamic content\n" +
      "- Implement proper validation\n" +
      "- Use TypeScript interfaces for form data\n" +
      "- Test form creation and validation\n" +
      "- Document complex form structures",
    category: "Forms",
    difficulty: "intermediate",
    tags: [
      "FormBuilder",
      "reactive-forms",
      "FormGroup",
      "FormControl",
      "FormArray",
      "syntactic-sugar",
    ],
  },
  {
    id: 210,
    question: "How do you optimize the performance of async validators?",
    answer:
      "Since all validators run after every form value change, it creates a major impact on performance with async validators by hitting the external API on each keystroke. This situation can be avoided by delaying the form validity by changing the `updateOn` property from `change` (default) to `submit` or `blur`.\n\n" +
      "**Performance Issues with Async Validators:**\n" +
      "- **API Calls on Every Keystroke**: Async validators trigger on every input change\n" +
      "- **Network Overhead**: Multiple unnecessary API requests\n" +
      "- **Poor User Experience**: Delayed feedback and potential errors\n" +
      "- **Resource Waste**: Server resources consumed by redundant requests\n" +
      "- **Race Conditions**: Multiple requests can complete out of order\n\n" +
      "**1. Using updateOn Property:**\n" +
      "```typescript\n" +
      "// Template-driven forms: Set the property on ngModelOptions directive\n" +
      "export class TemplateFormComponent {\n" +
      "  model = {\n" +
      "    email: '',\n" +
      "    username: ''\n" +
      "  };\n" +
      "}\n" +
      "```\n\n" +
      "```html\n" +
      "<!-- Template-driven forms -->\n" +
      '<input [(ngModel)]="model.email" \n' +
      "       [ngModelOptions]=\"{updateOn: 'blur'}\"\n" +
      '       name="email"\n' +
      '       #email="ngModel">\n' +
      "\n" +
      '<input [(ngModel)]="model.username" \n' +
      "       [ngModelOptions]=\"{updateOn: 'submit'}\"\n" +
      '       name="username"\n' +
      '       #username="ngModel">\n' +
      "```\n\n" +
      "```typescript\n" +
      "// Reactive-forms: Set the property on FormControl instance\n" +
      "export class ReactiveFormComponent {\n" +
      "  email = new FormControl('', { updateOn: 'blur' });\n" +
      "  username = new FormControl('', { updateOn: 'submit' });\n" +
      "  \n" +
      "  userForm = new FormGroup({\n" +
      "    email: this.email,\n" +
      "    username: this.username\n" +
      "  });\n" +
      "}\n" +
      "```\n\n" +
      "**2. Debouncing Async Validators:**\n" +
      "```typescript\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';\n" +
      "import { Observable, of, timer } from 'rxjs';\n" +
      "import { map, switchMap, catchError, debounceTime, distinctUntilChanged } from 'rxjs/operators';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class UserService {\n" +
      "  constructor(private http: HttpClient) {}\n" +
      "  \n" +
      "  checkEmailExists(email: string): Observable<boolean> {\n" +
      "    return this.http.get<boolean>(`/api/check-email?email=${email}`);\n" +
      "  }\n" +
      "  \n" +
      "  checkUsernameExists(username: string): Observable<boolean> {\n" +
      "    return this.http.get<boolean>(`/api/check-username?username=${username}`);\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "export function debouncedEmailValidator(userService: UserService): AsyncValidatorFn {\n" +
      "  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n" +
      "    if (!control.value) {\n" +
      "      return of(null);\n" +
      "    }\n" +
      "    \n" +
      "    return timer(500).pipe(\n" +
      "      debounceTime(500),\n" +
      "      distinctUntilChanged(),\n" +
      "      switchMap(() => userService.checkEmailExists(control.value)),\n" +
      "      map(exists => exists ? { emailExists: true } : null),\n" +
      "      catchError(() => of(null))\n" +
      "    );\n" +
      "  };\n" +
      "}\n" +
      "\n" +
      "export function debouncedUsernameValidator(userService: UserService): AsyncValidatorFn {\n" +
      "  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n" +
      "    if (!control.value) {\n" +
      "      return of(null);\n" +
      "    }\n" +
      "    \n" +
      "    return timer(300).pipe(\n" +
      "      debounceTime(300),\n" +
      "      distinctUntilChanged(),\n" +
      "      switchMap(() => userService.checkUsernameExists(control.value)),\n" +
      "      map(exists => exists ? { usernameExists: true } : null),\n" +
      "      catchError(() => of(null))\n" +
      "    );\n" +
      "  };\n" +
      "}\n" +
      "```\n\n" +
      "**3. Using Debounced Validators:**\n" +
      "```typescript\n" +
      "export class OptimizedFormComponent {\n" +
      "  userForm = new FormGroup({\n" +
      "    email: new FormControl('', \n" +
      "      [Validators.required, Validators.email], \n" +
      "      debouncedEmailValidator(this.userService)\n" +
      "    ),\n" +
      "    username: new FormControl('', \n" +
      "      [Validators.required, Validators.minLength(3)], \n" +
      "      debouncedUsernameValidator(this.userService)\n" +
      "    )\n" +
      "  });\n" +
      "  \n" +
      "  constructor(private userService: UserService) {}\n" +
      "}\n" +
      "```\n\n" +
      "**4. Advanced Debouncing with FormBuilder:**\n" +
      "```typescript\n" +
      "export class AdvancedFormComponent {\n" +
      "  userForm = this.formBuilder.group({\n" +
      "    email: ['', \n" +
      "      [Validators.required, Validators.email], \n" +
      "      debouncedEmailValidator(this.userService)\n" +
      "    ],\n" +
      "    username: ['', \n" +
      "      [Validators.required, Validators.minLength(3)], \n" +
      "      debouncedUsernameValidator(this.userService)\n" +
      "    ]\n" +
      "  }, { updateOn: 'blur' });\n" +
      "  \n" +
      "  constructor(\n" +
      "    private formBuilder: FormBuilder,\n" +
      "    private userService: UserService\n" +
      "  ) {}\n" +
      "}\n" +
      "```\n\n" +
      "**5. Caching Async Validator Results:**\n" +
      "```typescript\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class CachedValidatorService {\n" +
      "  private cache = new Map<string, boolean>();\n" +
      "  private pendingRequests = new Map<string, Observable<boolean>>();\n" +
      "  \n" +
      "  constructor(private http: HttpClient) {}\n" +
      "  \n" +
      "  checkEmailExists(email: string): Observable<boolean> {\n" +
      "    // Check cache first\n" +
      "    if (this.cache.has(email)) {\n" +
      "      return of(this.cache.get(email)!);\n" +
      "    }\n" +
      "    \n" +
      "    // Check if request is already pending\n" +
      "    if (this.pendingRequests.has(email)) {\n" +
      "      return this.pendingRequests.get(email)!;\n" +
      "    }\n" +
      "    \n" +
      "    // Make new request\n" +
      "    const request = this.http.get<boolean>(`/api/check-email?email=${email}`).pipe(\n" +
      "      tap(result => {\n" +
      "        this.cache.set(email, result);\n" +
      "        this.pendingRequests.delete(email);\n" +
      "      }),\n" +
      "      catchError(() => {\n" +
      "        this.pendingRequests.delete(email);\n" +
      "        return of(false);\n" +
      "      }),\n" +
      "      shareReplay(1)\n" +
      "    );\n" +
      "    \n" +
      "    this.pendingRequests.set(email, request);\n" +
      "    return request;\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "export function cachedEmailValidator(validatorService: CachedValidatorService): AsyncValidatorFn {\n" +
      "  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n" +
      "    if (!control.value) {\n" +
      "      return of(null);\n" +
      "    }\n" +
      "    \n" +
      "    return validatorService.checkEmailExists(control.value).pipe(\n" +
      "      map(exists => exists ? { emailExists: true } : null),\n" +
      "      catchError(() => of(null))\n" +
      "    );\n" +
      "  };\n" +
      "}\n" +
      "```\n\n" +
      "**6. Conditional Async Validation:**\n" +
      "```typescript\n" +
      "export function conditionalEmailValidator(userService: UserService): AsyncValidatorFn {\n" +
      "  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n" +
      "    const value = control.value;\n" +
      "    \n" +
      "    // Only validate if email is complete and valid format\n" +
      "    if (!value || !value.includes('@') || value.length < 5) {\n" +
      "      return of(null);\n" +
      "    }\n" +
      "    \n" +
      "    // Only validate if user has stopped typing for 1 second\n" +
      "    return timer(1000).pipe(\n" +
      "      switchMap(() => userService.checkEmailExists(value)),\n" +
      "      map(exists => exists ? { emailExists: true } : null),\n" +
      "      catchError(() => of(null))\n" +
      "    );\n" +
      "  };\n" +
      "}\n" +
      "```\n\n" +
      "**7. Template with Loading States:**\n" +
      "```html\n" +
      '<form [formGroup]="userForm">\n' +
      '  <div class="form-group">\n' +
      '    <label for="email">Email</label>\n' +
      '    <input id="email" \n' +
      '           formControlName="email" \n' +
      '           placeholder="Enter email">\n' +
      "    \n" +
      "    <!-- Loading indicator -->\n" +
      '    <div *ngIf="userForm.get(\'email\')?.pending" class="loading">\n' +
      "      Checking email availability...\n" +
      "    </div>\n" +
      "    \n" +
      "    <!-- Error messages -->\n" +
      "    <div *ngIf=\"userForm.get('email')?.errors?.['emailExists']\" class=\"error\">\n" +
      "      Email already exists\n" +
      "    </div>\n" +
      "  </div>\n" +
      "  \n" +
      '  <div class="form-group">\n' +
      '    <label for="username">Username</label>\n' +
      '    <input id="username" \n' +
      '           formControlName="username" \n' +
      '           placeholder="Enter username">\n' +
      "    \n" +
      "    <!-- Loading indicator -->\n" +
      '    <div *ngIf="userForm.get(\'username\')?.pending" class="loading">\n' +
      "      Checking username availability...\n" +
      "    </div>\n" +
      "    \n" +
      "    <!-- Error messages -->\n" +
      "    <div *ngIf=\"userForm.get('username')?.errors?.['usernameExists']\" class=\"error\">\n" +
      "      Username already exists\n" +
      "    </div>\n" +
      "  </div>\n" +
      "  \n" +
      '  <button type="submit" [disabled]="userForm.invalid || userForm.pending">\n' +
      "    Submit\n" +
      "  </button>\n" +
      "</form>\n" +
      "```\n\n" +
      "**8. Performance Monitoring:**\n" +
      "```typescript\n" +
      "export class PerformanceMonitoringComponent {\n" +
      "  userForm = new FormGroup({\n" +
      "    email: new FormControl('', \n" +
      "      [Validators.required, Validators.email], \n" +
      "      this.monitoredEmailValidator.bind(this)\n" +
      "    )\n" +
      "  });\n" +
      "  \n" +
      "  private validationCount = 0;\n" +
      "  private startTime: number;\n" +
      "  \n" +
      "  monitoredEmailValidator(control: AbstractControl): Observable<ValidationErrors | null> {\n" +
      "    this.validationCount++;\n" +
      "    this.startTime = performance.now();\n" +
      "    \n" +
      "    console.log(`Validation #${this.validationCount} started for: ${control.value}`);\n" +
      "    \n" +
      "    return this.userService.checkEmailExists(control.value).pipe(\n" +
      "      map(exists => {\n" +
      "        const duration = performance.now() - this.startTime;\n" +
      "        console.log(`Validation #${this.validationCount} completed in ${duration}ms`);\n" +
      "        return exists ? { emailExists: true } : null;\n" +
      "      }),\n" +
      "      catchError(error => {\n" +
      "        const duration = performance.now() - this.startTime;\n" +
      "        console.error(`Validation #${this.validationCount} failed after ${duration}ms:`, error);\n" +
      "        return of(null);\n" +
      "      })\n" +
      "    );\n" +
      "  }\n" +
      "  \n" +
      "  constructor(private userService: UserService) {}\n" +
      "}\n" +
      "```\n\n" +
      "**Key Optimization Strategies:**\n" +
      "- **updateOn: 'blur'**: Validate only when user leaves the field\n" +
      "- **updateOn: 'submit'**: Validate only when form is submitted\n" +
      "- **Debouncing**: Delay validation until user stops typing\n" +
      "- **Caching**: Store validation results to avoid duplicate requests\n" +
      "- **Conditional Validation**: Only validate when conditions are met\n" +
      "- **Request Deduplication**: Prevent multiple requests for the same value\n" +
      "- **Loading States**: Provide user feedback during validation\n" +
      "- **Error Handling**: Gracefully handle validation failures\n\n" +
      "**Best Practices:**\n" +
      "- Use `updateOn: 'blur'` for most async validators\n" +
      "- Implement debouncing for real-time validation\n" +
      "- Cache validation results when possible\n" +
      "- Provide loading indicators for better UX\n" +
      "- Handle errors gracefully\n" +
      "- Monitor validation performance\n" +
      "- Use conditional validation to reduce unnecessary calls\n" +
      "- Implement request deduplication\n" +
      "- Test with slow network conditions\n" +
      "- Consider using Web Workers for heavy validation logic",
    category: "Forms",
    difficulty: "advanced",
    tags: ["async-validators", "performance", "debouncing", "caching", "updateOn", "optimization"],
  },
  {
    id: 211,
    question: "How to set ngFor and ngIf on the same element?",
    answer:
      "Sometimes you may need to both `ngFor` and `ngIf` on the same element but unfortunately you are going to encounter the below template error:\n\n" +
      "```\n" +
      "Template parse errors: Can't have multiple template bindings on one element.\n" +
      "```\n\n" +
      "In this case, you need to use either `ng-container` or `ng-template`. Let's say if you try to loop over the items only when the items are available, the below code throws an error in the browser:\n\n" +
      "**❌ Incorrect - This will throw an error:**\n" +
      "```html\n" +
      '<ul *ngIf="items" *ngFor="let item of items">\n' +
      "  <li>{{ item.name }}</li>\n" +
      "</ul>\n" +
      "```\n\n" +
      "**✅ Correct Solutions:**\n\n" +
      "**1. Using ng-container:**\n" +
      "```html\n" +
      '<ng-container *ngIf="items">\n' +
      '  <ul *ngFor="let item of items">\n' +
      "    <li>{{ item.name }}</li>\n" +
      "  </ul>\n" +
      "</ng-container>\n" +
      "```\n\n" +
      "**2. Using ng-template:**\n" +
      "```html\n" +
      '<ng-template [ngIf]="items">\n' +
      '  <ul *ngFor="let item of items">\n' +
      "    <li>{{ item.name }}</li>\n" +
      "  </ul>\n" +
      "</ng-template>\n" +
      "```\n\n" +
      "**3. Using ng-container with template reference:**\n" +
      "```html\n" +
      '<ng-container *ngIf="items; else noItems">\n' +
      '  <ul *ngFor="let item of items">\n' +
      "    <li>{{ item.name }}</li>\n" +
      "  </ul>\n" +
      "</ng-container>\n" +
      "\n" +
      "<ng-template #noItems>\n" +
      "  <p>No items available</p>\n" +
      "</ng-template>\n" +
      "```\n\n" +
      "**Real-World Examples:**\n\n" +
      "**Example 1: User List with Loading State**\n" +
      "```html\n" +
      '<div class="user-list">\n' +
      '  <ng-container *ngIf="users && users.length > 0; else noUsers">\n' +
      '    <div *ngFor="let user of users" class="user-card">\n' +
      "      <h3>{{ user.name }}</h3>\n" +
      "      <p>{{ user.email }}</p>\n" +
      "    </div>\n" +
      "  </ng-container>\n" +
      "  \n" +
      "  <ng-template #noUsers>\n" +
      '    <div class="no-users">\n' +
      "      <p>No users found</p>\n" +
      "    </div>\n" +
      "  </ng-template>\n" +
      "</div>\n" +
      "```\n\n" +
      "**Example 2: Product Grid with Filter**\n" +
      "```html\n" +
      '<div class="product-grid">\n' +
      '  <ng-container *ngIf="filteredProducts && filteredProducts.length > 0">\n' +
      '    <div *ngFor="let product of filteredProducts" class="product-card">\n' +
      '      <img [src]="product.image" [alt]="product.name">\n' +
      "      <h4>{{ product.name }}</h4>\n" +
      '      <p class="price">${{ product.price }}</p>\n' +
      "    </div>\n" +
      "  </ng-container>\n" +
      "  \n" +
      '  <div *ngIf="!filteredProducts || filteredProducts.length === 0" class="no-products">\n' +
      "    <p>No products match your criteria</p>\n" +
      "  </div>\n" +
      "</div>\n" +
      "```\n\n" +
      "**Example 3: Dynamic Form Fields**\n" +
      "```html\n" +
      '<form [formGroup]="dynamicForm">\n' +
      '  <ng-container *ngIf="formFields && formFields.length > 0">\n' +
      '    <div *ngFor="let field of formFields" class="form-field">\n' +
      '      <label [for]="field.id">{{ field.label }}</label>\n' +
      "      <input \n" +
      '        [id]="field.id"\n' +
      '        [type]="field.type"\n' +
      '        [formControlName]="field.name"\n' +
      '        [placeholder]="field.placeholder">\n' +
      "    </div>\n" +
      "  </ng-container>\n" +
      "  \n" +
      '  <div *ngIf="!formFields || formFields.length === 0" class="no-fields">\n' +
      "    <p>No form fields configured</p>\n" +
      "  </div>\n" +
      "</form>\n" +
      "```\n\n" +
      "**Example 4: Table with Conditional Rows**\n" +
      "```html\n" +
      '<table class="data-table">\n' +
      "  <thead>\n" +
      "    <tr>\n" +
      "      <th>Name</th>\n" +
      "      <th>Status</th>\n" +
      "      <th>Actions</th>\n" +
      "    </tr>\n" +
      "  </thead>\n" +
      "  <tbody>\n" +
      '    <ng-container *ngIf="items && items.length > 0">\n' +
      '      <tr *ngFor="let item of items" [class.active]="item.isActive">\n' +
      "        <td>{{ item.name }}</td>\n" +
      "        <td>\n" +
      '          <span [class]="item.status">{{ item.status }}</span>\n' +
      "        </td>\n" +
      "        <td>\n" +
      '          <button (click)="editItem(item)">Edit</button>\n' +
      '          <button (click)="deleteItem(item)">Delete</button>\n' +
      "        </td>\n" +
      "      </tr>\n" +
      "    </ng-container>\n" +
      "  </tbody>\n" +
      "</table>\n" +
      "\n" +
      '<div *ngIf="!items || items.length === 0" class="no-data">\n' +
      "  <p>No data available</p>\n" +
      "</div>\n" +
      "```\n\n" +
      "**Example 5: Nested Conditions with ng-container**\n" +
      "```html\n" +
      '<div class="content-section">\n' +
      '  <ng-container *ngIf="user && user.isLoggedIn">\n' +
      "    <h2>Welcome, {{ user.name }}!</h2>\n    " +
      "    \n" +
      '    <ng-container *ngIf="user.permissions && user.permissions.length > 0">\n' +
      '      <div *ngFor="let permission of user.permissions" class="permission-item">\n' +
      '        <span class="permission-name">{{ permission.name }}</span>\n' +
      '        <span class="permission-level">{{ permission.level }}</span>\n' +
      "      </div>\n" +
      "    </ng-container>\n" +
      "    \n" +
      '    <div *ngIf="!user.permissions || user.permissions.length === 0" class="no-permissions">\n' +
      "      <p>No permissions assigned</p>\n" +
      "    </div>\n" +
      "  </ng-container>\n" +
      "  \n" +
      '  <div *ngIf="!user || !user.isLoggedIn" class="login-prompt">\n' +
      "    <p>Please log in to view content</p>\n" +
      '    <button (click)="login()">Login</button>\n' +
      "  </div>\n" +
      "</div>\n" +
      "```\n\n" +
      "**Component Code Examples:**\n\n" +
      "**TypeScript Component:**\n" +
      "```typescript\n" +
      "export class ListComponent {\n" +
      "  users: User[] = [];\n" +
      "  products: Product[] = [];\n" +
      "  formFields: FormField[] = [];\n" +
      "  \n" +
      "  constructor(private dataService: DataService) {\n" +
      "    this.loadData();\n" +
      "  }\n" +
      "  \n" +
      "  loadData() {\n" +
      "    this.dataService.getUsers().subscribe(users => {\n" +
      "      this.users = users;\n" +
      "    });\n" +
      "    \n" +
      "    this.dataService.getProducts().subscribe(products => {\n" +
      "      this.products = products;\n" +
      "    });\n" +
      "    \n" +
      "    this.dataService.getFormFields().subscribe(fields => {\n" +
      "      this.formFields = fields;\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "interface User {\n" +
      "  id: number;\n" +
      "  name: string;\n" +
      "  email: string;\n" +
      "  isLoggedIn: boolean;\n" +
      "  permissions: Permission[];\n" +
      "}\n" +
      "\n" +
      "interface Permission {\n" +
      "  name: string;\n" +
      "  level: string;\n" +
      "}\n" +
      "\n" +
      "interface Product {\n" +
      "  id: number;\n" +
      "  name: string;\n" +
      "  price: number;\n" +
      "  image: string;\n" +
      "}\n" +
      "\n" +
      "interface FormField {\n" +
      "  id: string;\n" +
      "  name: string;\n" +
      "  label: string;\n" +
      "  type: string;\n" +
      "  placeholder: string;\n" +
      "}\n" +
      "```\n\n" +
      "**Key Points:**\n" +
      "- **ng-container**: A logical container that doesn't render any HTML element\n" +
      "- **ng-template**: A template that can be referenced and reused\n" +
      "- **Template Reference Variables**: Use `#` to create references to templates\n      " +
      "- **Structural Directives**: `*ngIf`, `*ngFor`, `*ngSwitch` are structural directives\n" +
      "- **Multiple Directives**: Only one structural directive per element\n" +
      "- **Conditional Rendering**: Use `ng-container` for conditional rendering with loops\n" +
      "- **Template Reusability**: Use `ng-template` for reusable template blocks\n\n" +
      "**Best Practices:**\n" +
      "- Use `ng-container` when you need a logical container without extra HTML\n" +
      "- Use `ng-template` when you need to reuse template blocks\n" +
      "- Always check for null/undefined before using `ngFor`\n" +
      "- Use template reference variables for complex conditional logic\n" +
      "- Keep template logic simple and readable\n" +
      "- Use meaningful variable names for template references\n" +
      "- Consider performance implications of nested conditions\n" +
      "- Test with different data states (empty, null, undefined)\n" +
      "- Use TypeScript interfaces for better type safety",
    category: "Structural Directives",
    difficulty: "intermediate",
    tags: ["ngFor", "ngIf", "ng-container", "ng-template", "structural-directives", "template"],
  },
  {
    id: 212,
    question: "What is host property in CSS?",
    answer:
      "The `:host` pseudo-class selector is used to target styles in the element that hosts the component. Since the host element is in a parent component's template, you can't reach the host element from inside the component by other means.\n\n" +
      "**Basic Usage:**\n" +
      "```css\n" +
      "/* app.component.css */\n" +
      ":host {\n" +
      "  display: block;\n" +
      "  border: 1px solid black;\n" +
      "  padding: 20px;\n" +
      "}\n" +
      "```\n\n" +
      "**Key Points:**\n" +
      "- **Host Element**: The element that hosts the component\n" +
      "- **Scoped Styling**: Styles only apply to the component's host element\n" +
      "- **Parent Template**: The host element exists in the parent component's template\n" +
      "- **Component Isolation**: Cannot be styled from inside the component by other means\n\n" +
      "**Advanced Usage:**\n" +
      "```css\n" +
      "/* Conditional styling based on component state */\n" +
      ":host(.active) {\n" +
      "  background-color: #f0f0f0;\n" +
      "}\n" +
      "\n" +
      ":host(.disabled) {\n" +
      "  opacity: 0.5;\n" +
      "  pointer-events: none;\n" +
      "}\n" +
      "\n" +
      "/* Responsive design */\n" +
      ":host {\n" +
      "  width: 100%;\n" +
      "}\n" +
      "\n" +
      "@media (max-width: 768px) {\n" +
      "  :host {\n" +
      "    padding: 10px;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Component Integration:**\n" +
      "```typescript\n" +
      "// app.component.ts\n" +
      "import { Component, HostBinding } from '@angular/core';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-root',\n" +
      "  templateUrl: './app.component.html',\n" +
      "  styleUrls: ['./app.component.css']\n" +
      "})\n" +
      "export class AppComponent {\n" +
      "  @HostBinding('class.active') isActive = true;\n" +
      "  @HostBinding('class.disabled') isDisabled = false;\n" +
      "  \n" +
      "  toggleActive() {\n" +
      "    this.isActive = !this.isActive;\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Best Practices:**\n" +
      "- Use `:host` for component-level styling\n" +
      "- Combine with `@HostBinding` for dynamic classes\n" +
      "- Consider responsive design in host styles\n" +
      "- Use meaningful class names for conditional styling",
    category: "Styling",
    difficulty: "intermediate",
    tags: ["CSS", "host", "styling", "component", "pseudo-class"],
  },
  {
    id: 213,
    question: "How do you get the current route?",
    answer:
      "In Angular, there is an `url` property of the router package to get the current route. You need to follow the below few steps:\n\n" +
      "**Step 1: Import Router from @angular/router**\n" +
      "```typescript\n" +
      "import { Router } from '@angular/router';\n" +
      "```\n\n" +
      "**Step 2: Inject router inside constructor**\n" +
      "```typescript\n" +
      "constructor(private router: Router) {\n" +
      "  \n" +
      "}\n" +
      "```\n\n" +
      "**Step 3: Access url parameter**\n" +
      "```typescript\n" +
      "console.log(this.router.url); //  /routename\n" +
      "```\n\n" +
      "**Complete Example:**\n" +
      "```typescript\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { Router } from '@angular/router';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-current-route',\n" +
      "  template: `\n" +
      "    <div>\n" +
      "      <h2>Current Route Information</h2>\n" +
      "      <p>Current URL: {{ currentUrl }}</p>\n" +
      "      <p>Route Path: {{ routePath }}</p>\n" +
      '      <button (click)="logCurrentRoute()">Log Current Route</button>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class CurrentRouteComponent implements OnInit {\n" +
      "  currentUrl: string = '';\n" +
      "  routePath: string = '';\n" +
      "  \n" +
      "  constructor(private router: Router) {}\n" +
      "  \n" +
      "  ngOnInit() {\n" +
      "    this.currentUrl = this.router.url;\n" +
      "    this.routePath = this.router.url.split('?')[0]; // Remove query parameters\n" +
      "  }\n" +
      "  \n" +
      "  logCurrentRoute() {\n" +
      "    console.log('Current URL:', this.router.url);\n" +
      "    console.log('Route Path:', this.routePath);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Advanced Usage with Route Parameters:**\n" +
      "```typescript\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { Router, ActivatedRoute } from '@angular/router';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-route-info',\n" +
      "  template: `\n" +
      "    <div>\n" +
      "      <h2>Route Information</h2>\n" +
      "      <p>Current URL: {{ router.url }}</p>\n" +
      "      <p>Route Path: {{ routePath }}</p>\n" +
      "      <p>Route Parameters: {{ routeParams | json }}</p>\n" +
      "      <p>Query Parameters: {{ queryParams | json }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class RouteInfoComponent implements OnInit {\n" +
      "  routePath: string = '';\n" +
      "  routeParams: any = {};\n" +
      "  queryParams: any = {};\n" +
      "  \n" +
      "  constructor(\n" +
      "    public router: Router,\n" +
      "    private activatedRoute: ActivatedRoute\n" +
      "  ) {}\n" +
      "  \n" +
      "  ngOnInit() {\n" +
      "    this.routePath = this.router.url.split('?')[0];\n    " +
      "    \n" +
      "    // Get route parameters\n" +
      "    this.activatedRoute.params.subscribe(params => {\n" +
      "      this.routeParams = params;\n" +
      "    });\n" +
      "    \n" +
      "    // Get query parameters\n" +
      "    this.activatedRoute.queryParams.subscribe(queryParams => {\n" +
      "      this.queryParams = queryParams;\n" +
      "    });\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Service for Route Monitoring:**\n" +
      "```typescript\n" +
      "import { Injectable } from '@angular/core';\n" +
      "import { Router, NavigationEnd } from '@angular/router';\n" +
      "import { filter } from 'rxjs/operators';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class RouteService {\n" +
      "  private currentUrl: string = '';\n" +
      "  \n" +
      "  constructor(private router: Router) {\n" +
      "    // Monitor route changes\n" +
      "    this.router.events\n" +
      "      .pipe(filter(event => event instanceof NavigationEnd))\n" +
      "      .subscribe((event: NavigationEnd) => {\n" +
      "        this.currentUrl = event.url;\n" +
      "        console.log('Route changed to:', this.currentUrl);\n" +
      "      });\n" +
      "  }\n" +
      "  \n" +
      "  getCurrentUrl(): string {\n" +
      "    return this.currentUrl;\n" +
      "  }\n" +
      "  \n" +
      "  getCurrentRoute(): string {\n" +
      "    return this.currentUrl.split('?')[0];\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Properties Available:**\n" +
      "- **router.url**: Complete URL including query parameters\n" +
      "- **router.url.split('?')[0]**: Route path without query parameters\n" +
      "- **ActivatedRoute.params**: Route parameters (e.g., /users/:id)\n" +
      "- **ActivatedRoute.queryParams**: Query parameters (e.g., ?page=1&size=10)\n" +
      "- **ActivatedRoute.fragment**: URL fragment (e.g., #section1)\n\n" +
      "**Best Practices:**\n" +
      "- Use `ActivatedRoute` for accessing route parameters\n" +
      "- Subscribe to route changes for dynamic updates\n" +
      "- Use services for route monitoring across components\n" +
      "- Handle route changes in `ngOnInit` lifecycle hook\n" +
      "- Unsubscribe from observables to prevent memory leaks",
    category: "Routing",
    difficulty: "intermediate",
    tags: ["router", "routing", "URL", "navigation", "ActivatedRoute"],
  },
  {
    id: 214,
    question: "What is standalone component?",
    answer:
      "A standalone component is a type of component which is not part of any Angular module. It provides a simplified way to build Angular applications without the need for NgModules.\n\n" +
      "**Key Features:**\n" +
      "- **No NgModule Required**: Standalone components can be used without declaring them in any module\n" +
      "- **Self-Contained**: They can import their own dependencies directly\n" +
      "- **Simplified Architecture**: Reduces the complexity of Angular applications\n" +
      "- **Tree-Shakable**: Better optimization and smaller bundle sizes\n" +
      "- **Modern Approach**: Recommended for new Angular applications\n\n" +
      "**Basic Standalone Component:**\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "import { CommonModule } from '@angular/common';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-standalone',\n" +
      "  standalone: true,\n" +
      "  imports: [CommonModule],\n" +
      "  template: `\n" +
      "    <div>\n" +
      "      <h2>Standalone Component</h2>\n" +
      "      <p>This component doesn't need a module!</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class StandaloneComponent {\n" +
      "  title = 'Standalone Component Example';\n" +
      "}\n" +
      "```\n\n" +
      "**Standalone Component with Forms:**\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "import { CommonModule } from '@angular/common';\n" +
      "import { ReactiveFormsModule, FormControl, FormGroup } from '@angular/forms';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-user-form',\n" +
      "  standalone: true,\n" +
      "  imports: [CommonModule, ReactiveFormsModule],\n" +
      "  template: `\n" +
      '    <form [formGroup]="userForm" (ngSubmit)="onSubmit()">\n' +
      "      <div>\n" +
      '        <label for="name">Name:</label>\n' +
      '        <input id="name" formControlName="name" required>\n' +
      "      </div>\n" +
      "      <div>\n" +
      '        <label for="email">Email:</label>\n' +
      '        <input id="email" formControlName="email" type="email" required>\n' +
      "      </div>\n" +
      '      <button type="submit" [disabled]="!userForm.valid">Submit</button>\n' +
      "    </form>\n" +
      "  `\n" +
      "})\n" +
      "export class UserFormComponent {\n" +
      "  userForm = new FormGroup({\n" +
      "    name: new FormControl(''),\n" +
      "    email: new FormControl('')\n" +
      "  });\n" +
      "  \n" +
      "  onSubmit() {\n" +
      "    if (this.userForm.valid) {\n" +
      "      console.log('Form submitted:', this.userForm.value);\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Standalone Component with Routing:**\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "import { RouterModule, RouterOutlet } from '@angular/router';\n" +
      "import { CommonModule } from '@angular/common';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-root',\n" +
      "  standalone: true,\n" +
      "  imports: [CommonModule, RouterOutlet],\n      " +
      "  template: `\n" +
      "    <nav>\n" +
      '      <a routerLink="/home">Home</a>\n' +
      '      <a routerLink="/about">About</a>\n' +
      "    </nav>\n" +
      "    <router-outlet></router-outlet>\n" +
      "  `\n" +
      "})\n" +
      "export class AppComponent {\n" +
      "  title = 'Standalone App';\n" +
      "}\n" +
      "```\n\n" +
      "**Bootstrapping Standalone Components:**\n" +
      "```typescript\n" +
      "// main.ts\n" +
      "import { bootstrapApplication } from '@angular/platform-browser';\n" +
      "import { AppComponent } from './app/app.component';\n" +
      "import { provideRouter } from '@angular/router';\n" +
      "import { routes } from './app/app.routes';\n" +
      "\n" +
      "bootstrapApplication(AppComponent, {\n" +
      "  providers: [\n" +
      "    provideRouter(routes)\n" +
      "  ]\n" +
      "})\n" +
      "  .catch(err => console.error(err));\n" +
      "```\n\n" +
      "**Standalone Component with Services:**\n" +
      "```typescript\n" +
      "import { Component, inject } from '@angular/core';\n" +
      "import { CommonModule } from '@angular/common';\n" +
      "import { HttpClientModule } from '@angular/common/http';\n" +
      "import { DataService } from './data.service';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-data-display',\n" +
      "  standalone: true,\n" +
      "  imports: [CommonModule, HttpClientModule],\n" +
      "  providers: [DataService],\n" +
      "  template: `\n" +
      "    <div>\n" +
      "      <h2>Data Display</h2>\n" +
      '      <div *ngIf="data$ | async as data">\n' +
      "        <p>{{ data.message }}</p>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class DataDisplayComponent {\n" +
      "  private dataService = inject(DataService);\n" +
      "  data$ = this.dataService.getData();\n" +
      "}\n" +
      "```\n\n" +
      "**Advantages of Standalone Components:**\n" +
      "- **Simplified Architecture**: No need to manage NgModules\n" +
      "- **Better Tree Shaking**: Unused components can be eliminated\n" +
      "- **Easier Testing**: Components can be tested in isolation\n" +
      "- **Reduced Boilerplate**: Less code to write and maintain\n" +
      "- **Modern Development**: Aligns with modern Angular practices\n" +
      "- **Lazy Loading**: Easier to implement lazy loading\n\n" +
      "**Migration from NgModules:**\n" +
      "```typescript\n" +
      "// Old way with NgModule\n" +
      "@NgModule({\n" +
      "  declarations: [MyComponent],\n" +
      "  imports: [CommonModule, FormsModule],\n" +
      "  exports: [MyComponent]\n" +
      "})\n" +
      "export class MyModule {}\n" +
      "\n" +
      "// New way with Standalone Component\n" +
      "@Component({\n" +
      "  selector: 'app-my',\n" +
      "  standalone: true,\n" +
      "  imports: [CommonModule, FormsModule],\n" +
      "  template: `...`\n" +
      "})\n" +
      "export class MyComponent {}\n" +
      "```\n\n" +
      "**Best Practices:**\n" +
      "- Use standalone components for new applications\n" +
      "- Import only necessary dependencies\n" +
      "- Use `inject()` function for dependency injection\n" +
      "- Consider using standalone components for better performance\n" +
      "- Leverage tree-shaking benefits\n" +
      "- Use with Angular CLI's standalone flag: `ng generate component --standalone`",
    category: "Components",
    difficulty: "intermediate",
    tags: ["standalone", "components", "modules", "architecture", "modern"],
  },
  {
    id: 215,
    question: "What are Angular Signals?",
    answer:
      "A signal is a wrapper around a value that can notify interested consumers when that value changes. Signals can contain any value, from simple primitives to complex data structures.\n\n" +
      "**Key Features:**\n" +
      "- **Reactive Values**: Signals automatically track dependencies and notify consumers of changes\n" +
      "- **Fine-Grained Reactivity**: Only components that depend on a signal update when it changes\n" +
      "- **Type Safety**: Signals provide full TypeScript support\n" +
      "- **Performance**: More efficient than traditional change detection\n" +
      "- **Composability**: Signals can be combined and derived from other signals\n\n" +
      "**Basic Signal Creation:**\n" +
      "```typescript\n" +
      "import { signal } from '@angular/core';\n" +
      "\n" +
      "// Create a signal with initial value\n" +
      "const count = signal(0);\n" +
      "const name = signal('John');\n" +
      "const items = signal<string[]>([]);\n" +
      "```\n\n" +
      "**Signal Operations:**\n" +
      "```typescript\n" +
      "import { signal } from '@angular/core';\n" +
      "\n" +
      "const count = signal(0);\n" +
      "\n" +
      "// Read signal value\n" +
      "console.log(count()); // 0\n" +
      "\n" +
      "// Update signal value\n" +
      "count.set(10);\n" +
      "console.log(count()); // 10\n" +
      "\n" +
      "// Update using previous value\n" +
      "count.update(value => value + 1);\n" +
      "console.log(count()); // 11\n" +
      "```\n\n" +
      "**Computed Signals:**\n" +
      "```typescript\n" +
      "import { signal, computed } from '@angular/core';\n" +
      "\n" +
      "const firstName = signal('John');\n" +
      "const lastName = signal('Doe');\n" +
      "\n" +
      "// Computed signal that depends on other signals\n" +
      "const fullName = computed(() => {\n" +
      "  return `${firstName()} ${lastName()}`;\n" +
      "});\n" +
      "\n" +
      'console.log(fullName()); // "John Doe"\n' +
      "\n" +
      "firstName.set('Jane');\n" +
      'console.log(fullName()); // "Jane Doe"\n' +
      "```\n\n" +
      "**Signal in Component:**\n" +
      "```typescript\n" +
      "import { Component, signal, computed } from '@angular/core';\n" +
      "import { CommonModule } from '@angular/common';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-signal-example',\n" +
      "  standalone: true,\n" +
      "  imports: [CommonModule],\n" +
      "  template: `\n" +
      "    <div>\n" +
      "      <h2>Signal Example</h2>\n" +
      "      <p>Count: {{ count() }}</p>\n" +
      "      <p>Double Count: {{ doubleCount() }}</p>\n" +
      '      <button (click)="increment()">Increment</button>\n' +
      '      <button (click)="decrement()">Decrement</button>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class SignalExampleComponent {\n" +
      "  count = signal(0);\n" +
      "  doubleCount = computed(() => this.count() * 2);\n" +
      "  \n" +
      "  increment() {\n" +
      "    this.count.update(value => value + 1);\n" +
      "  }\n" +
      "  \n" +
      "  decrement() {\n" +
      "    this.count.update(value => Math.max(0, value - 1));\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Signal with Objects:**\n" +
      "```typescript\n" +
      "import { signal, computed } from '@angular/core';\n" +
      "\n" +
      "interface User {\n" +
      "  id: number;\n" +
      "  name: string;\n" +
      "  email: string;\n" +
      "}\n" +
      "\n" +
      "const user = signal<User>({\n" +
      "  id: 1,\n" +
      "  name: 'John Doe',\n" +
      "  email: 'john@example.com'\n" +
      "});\n" +
      "\n" +
      "// Computed signal for user display name\n" +
      "const displayName = computed(() => {\n" +
      "  const u = user();\n" +
      "  return `${u.name} (${u.email})`;\n" +
      "});\n" +
      "\n" +
      "// Update user object\n" +
      "user.update(currentUser => ({\n" +
      "  ...currentUser,\n" +
      "  name: 'Jane Doe'\n" +
      "}));\n" +
      "```\n\n" +
      "**Signal with Arrays:**\n" +
      "```typescript\n" +
      "import { signal, computed } from '@angular/core';\n" +
      "\n" +
      "const items = signal<string[]>(['apple', 'banana', 'cherry']);\n" +
      "\n" +
      "// Computed signal for array length\n" +
      "const itemCount = computed(() => items().length);\n" +
      "\n" +
      "// Computed signal for filtered items\n" +
      "const filteredItems = computed(() => {\n" +
      "  return items().filter(item => item.startsWith('a'));\n" +
      "});\n" +
      "\n" +
      "// Add item to array\n" +
      "items.update(currentItems => [...currentItems, 'date']);\n" +
      "\n" +
      "// Remove item from array\n" +
      "items.update(currentItems => currentItems.filter(item => item !== 'banana'));\n" +
      "```\n\n" +
      "**Signal Effects:**\n" +
      "```typescript\n" +
      "import { signal, effect } from '@angular/core';\n" +
      "\n" +
      "const count = signal(0);\n" +
      "\n" +
      "// Effect that runs when signal changes\n" +
      "effect(() => {\n" +
      "  console.log('Count changed to:', count());\n" +
      "  \n" +
      "  // Side effects like API calls, DOM manipulation, etc.\n" +
      "  if (count() > 10) {\n" +
      "    console.log('Count is greater than 10!');\n" +
      "  }\n" +
      "});\n" +
      "\n" +
      'count.set(5);  // Logs: "Count changed to: 5"\n' +
      'count.set(15); // Logs: "Count changed to: 15" and "Count is greater than 10!"\n' +
      "```\n\n" +
      "**Signal with Services:**\n" +
      "```typescript\n" +
      "import { Injectable, signal } from '@angular/core';\n" +
      "\n" +
      "@Injectable({\n" +
      "  providedIn: 'root'\n" +
      "})\n" +
      "export class CounterService {\n" +
      "  private count = signal(0);\n" +
      "  \n" +
      "  // Expose signal as read-only\n" +
      "  readonly count$ = this.count.asReadonly();\n" +
      "  \n" +
      "  increment() {\n" +
      "    this.count.update(value => value + 1);\n" +
      "  }\n" +
      "  \n" +
      "  decrement() {\n" +
      "    this.count.update(value => Math.max(0, value - 1));\n" +
      "  }\n" +
      "  \n" +
      "  reset() {\n" +
      "    this.count.set(0);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Signal vs Traditional Change Detection:**\n" +
      "```typescript\n" +
      "// Traditional approach with OnPush\n" +
      "@Component({\n" +
      "  changeDetection: ChangeDetectionStrategy.OnPush\n" +
      "})\n" +
      "export class TraditionalComponent {\n" +
      "  count = 0;\n" +
      "  \n" +
      "  increment() {\n" +
      "    this.count++;\n" +
      "    // Need to manually trigger change detection\n" +
      "    this.cdr.detectChanges();\n" +
      "  }\n" +
      "}\n" +
      "\n" +
      "// Signal approach\n" +
      "@Component({})\n" +
      "export class SignalComponent {\n" +
      "  count = signal(0);\n" +
      "  \n" +
      "  increment() {\n" +
      "    // Change detection happens automatically\n" +
      "    this.count.update(value => value + 1);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Advantages of Signals:**\n" +
      "- **Automatic Change Detection**: No need to manually trigger change detection\n" +
      "- **Fine-Grained Updates**: Only affected components update\n" +
      "- **Better Performance**: More efficient than traditional change detection\n" +
      "- **Type Safety**: Full TypeScript support\n" +
      "- **Composability**: Easy to combine and derive values\n" +
      "- **Debugging**: Better debugging experience with signal tracking\n\n" +
      "**Best Practices:**\n" +
      "- Use signals for reactive state management\n" +
      "- Prefer computed signals for derived values\n" +
      "- Use effects for side effects\n" +
      "- Keep signals immutable\n" +
      "- Use `asReadonly()` to prevent external modifications\n" +
      "- Consider signals for complex state management scenarios",
    category: "Signals",
    difficulty: "intermediate",
    tags: ["signals", "reactivity", "change-detection", "performance", "modern"],
  },
  {
    id: 216,
    question: "Explain Angular Signals with an example.",
    answer:
      "In this example, we create a signal named count and initialize it with a value of 0. We then connect to the signal, allowing us to be notified whenever its value changes. Finally, we add a button that increments the count when clicked.\n\n" +
      "When the button is clicked, the incrementCount() method is called. This method sets the new value of the count signal to 1. Objects connected to the signal (subscribers) are then notified of the change, and the updated value is displayed in the UI.\n\n" +
      "**Complete Example:**\n" +
      "```typescript\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { signal, computed } from '@angular/core';\n" +
      "import { CommonModule } from '@angular/common';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'my-app',\n" +
      "  standalone: true,\n" +
      "  imports: [CommonModule],\n" +
      "  templateUrl: './app.component.html',\n" +
      "  styleUrls: ['./app.component.css']\n" +
      "})\n" +
      "export class AppComponent implements OnInit {\n" +
      "  count = signal(0);\n" +
      "  doubleCount = computed(() => this.count() * 2);\n" +
      "  \n" +
      "  constructor() {}\n" +
      "  \n" +
      "  ngOnInit() {\n" +
      "    // Optional logging for debugging displayedCount changes\n" +
      "    console.log('Initial count:', this.count());\n" +
      "    console.log('Initial double count:', this.doubleCount());\n" +
      "  }\n" +
      "  \n" +
      "  incrementCount() {\n" +
      "    this.count.set(this.count() + 1);\n" +
      "  }\n" +
      "  \n" +
      "  decrementCount() {\n" +
      "    this.count.update((value) => Math.max(0, value - 1));\n" +
      "  }\n" +
      "  \n" +
      "  resetCount() {\n" +
      "    this.count.set(0);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**HTML Template:**\n" +
      "```html\n" +
      "<h1>Angular Signals Example</h1>\n" +
      "\n" +
      '<div class="counter-container">\n' +
      "  <h2>Counter: {{ count() }}</h2>\n" +
      "  <p>Double Count: {{ doubleCount() }}</p>\n" +
      "  \n" +
      '  <div class="button-group">\n' +
      '    <button (click)="incrementCount()" class="btn btn-primary">\n' +
      "      Increment Count\n" +
      "    </button>\n" +
      '    <button (click)="decrementCount()" class="btn btn-secondary">\n' +
      "      Decrement Count\n" +
      "    </button>\n" +
      '    <button (click)="resetCount()" class="btn btn-danger">\n' +
      "      Reset\n" +
      "    </button>\n" +
      "  </div>\n" +
      "</div>\n" +
      "```\n\n" +
      "**CSS Styling:**\n" +
      "```css\n" +
      ".counter-container {\n" +
      "  text-align: center;\n" +
      "  padding: 20px;\n" +
      "  max-width: 400px;\n" +
      "  margin: 0 auto;\n" +
      "}\n" +
      "\n" +
      ".button-group {\n" +
      "  display: flex;\n" +
      "  gap: 10px;\n" +
      "  justify-content: center;\n" +
      "  margin-top: 20px;\n" +
      "}\n" +
      "\n" +
      ".btn {\n" +
      "  padding: 10px 20px;\n" +
      "  border: none;\n" +
      "  border-radius: 4px;\n" +
      "  cursor: pointer;\n" +
      "  font-size: 14px;\n" +
      "}\n" +
      "\n" +
      ".btn-primary {\n" +
      "  background-color: #007bff;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-secondary {\n" +
      "  background-color: #6c757d;\n" +
      "  color: white;\n" +
      "}\n" +
      "\n" +
      ".btn-danger {\n" +
      "  background-color: #dc3545;\n" +
      "  color: white;\n" +
      "}\n" +
      "```\n\n" +
      "**Advanced Example with Multiple Signals:**\n" +
      "```typescript\n" +
      "import { Component, signal, computed, effect } from '@angular/core';\n" +
      "import { CommonModule } from '@angular/common';\n" +
      "\n" +
      "interface Todo {\n" +
      "  id: number;\n" +
      "  text: string;\n" +
      "  completed: boolean;\n" +
      "}\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-todo-signals',\n" +
      "  standalone: true,\n" +
      "  imports: [CommonModule],\n" +
      "  template: `\n" +
      '    <div class="todo-container">\n' +
      "      <h2>Todo List with Signals</h2>\n" +
      "      \n" +
      '      <div class="stats">\n' +
      "        <p>Total: {{ totalTodos() }}</p>\n" +
      "        <p>Completed: {{ completedTodos() }}</p>\n" +
      "        <p>Remaining: {{ remainingTodos() }}</p>\n" +
      "      </div>\n" +
      "      \n" +
      '      <div class="add-todo">\n' +
      "        <input \n" +
      "          #todoInput\n" +
      '          type="text" \n' +
      '          placeholder="Add a new todo"\n' +
      "          (keyup.enter)=\"addTodo(todoInput.value); todoInput.value = ''\"\n" +
      "        >\n" +
      "        <button (click)=\"addTodo(todoInput.value); todoInput.value = ''\">Add</button>\n" +
      "      </div>\n" +
      "      \n" +
      '      <ul class="todo-list">\n' +
      '        <li *ngFor="let todo of todos()" class="todo-item">\n' +
      "          <input \n" +
      '            type="checkbox" \n' +
      '            [checked]="todo.completed"\n' +
      '            (change)="toggleTodo(todo.id)"\n' +
      "          >\n" +
      '          <span [class.completed]="todo.completed">{{ todo.text }}</span>\n' +
      '          <button (click)="removeTodo(todo.id)" class="delete-btn">Delete</button>\n' +
      "        </li>\n" +
      "      </ul>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class TodoSignalsComponent {\n" +
      "  todos = signal<Todo[]>([\n" +
      "    { id: 1, text: 'Learn Angular Signals', completed: false },\n" +
      "    { id: 2, text: 'Build a todo app', completed: true },\n" +
      "    { id: 3, text: 'Master reactive programming', completed: false }\n" +
      "  ]);\n" +
      "  \n" +
      "  // Computed signals for statistics\n" +
      "  totalTodos = computed(() => this.todos().length);\n" +
      "  completedTodos = computed(() => \n" +
      "    this.todos().filter(todo => todo.completed).length\n" +
      "  );\n" +
      "  remainingTodos = computed(() => \n" +
      "    this.todos().filter(todo => !todo.completed).length\n" +
      "  );\n" +
      "  \n" +
      "  constructor() {\n" +
      "    // Effect to log changes\n" +
      "    effect(() => {\n" +
      "      console.log('Todos updated:', this.todos());\n" +
      "      console.log('Completed:', this.completedTodos());\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  addTodo(text: string) {\n" +
      "    if (text.trim()) {\n" +
      "      const newTodo: Todo = {\n" +
      "        id: Date.now(),\n" +
      "        text: text.trim(),\n" +
      "        completed: false\n" +
      "      };\n" +
      "      \n" +
      "      this.todos.update(currentTodos => [...currentTodos, newTodo]);\n" +
      "    }\n" +
      "  }\n" +
      "  \n" +
      "  toggleTodo(id: number) {\n" +
      "    this.todos.update(currentTodos =>\n" +
      "      currentTodos.map(todo =>\n" +
      "        todo.id === id ? { ...todo, completed: !todo.completed } : todo\n" +
      "      )\n" +
      "    );\n" +
      "  }\n" +
      "  \n" +
      "  removeTodo(id: number) {\n" +
      "    this.todos.update(currentTodos =>\n" +
      "      currentTodos.filter(todo => todo.id !== id)\n" +
      "    );\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Key Concepts Demonstrated:**\n" +
      "1. **Signal Creation**: `count = signal(0)` creates a reactive value\n" +
      "2. **Computed Signals**: `doubleCount = computed(() => this.count() * 2)` creates derived values\n" +
      "3. **Signal Updates**: `count.set()` and `count.update()` modify signal values\n" +
      "4. **Automatic Reactivity**: UI updates automatically when signals change\n" +
      "5. **Effects**: Side effects that run when signals change\n" +
      "6. **Immutable Updates**: Using spread operator for array/object updates\n\n" +
      "**Benefits of This Approach:**\n" +
      "- **Automatic Change Detection**: No need to manually trigger change detection\n" +
      "- **Fine-Grained Updates**: Only affected parts of the UI update\n" +
      "- **Better Performance**: More efficient than traditional change detection\n" +
      "- **Type Safety**: Full TypeScript support with proper typing\n" +
      "- **Composability**: Easy to combine and derive values from signals\n" +
      "- **Debugging**: Better debugging experience with signal tracking",
    category: "Signals",
    difficulty: "intermediate",
    tags: ["signals", "example", "computed", "effects", "reactivity"],
  },
  {
    id: 217,
    question: "What are the Route Parameters? Could you explain each of them?",
    answer:
      'Route parameters are used to pass dynamic values in the URL of a route. They allow you to define variable segments in the route path, which can be accessed and used by components and services. Path parameters are represented by a colon (":") followed by the parameter name.\n\n' +
      "There are three types of route parameters in Angular:\n\n" +
      "**1. Path Parameters**\n" +
      "Path parameters are used to define dynamic segments in the URL path. They are specified as part of the route's path and are extracted from the actual URL when navigating to that route.\n\n" +
      "```typescript\n" +
      "// Route configuration\n" +
      "const routes: Routes = [\n" +
      "  { path: 'users/:id', component: UserComponent },\n" +
      "  { path: 'products/:category/:id', component: ProductComponent }\n" +
      "];\n" +
      "```\n\n" +
      "**Accessing Path Parameters:**\n" +
      "```typescript\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { ActivatedRoute } from '@angular/router';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-user',\n" +
      "  template: `\n" +
      "    <div>\n" +
      "      <h2>User Details</h2>\n" +
      "      <p>User ID: {{ userId }}</p>\n" +
      "      <p>User Name: {{ userName }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class UserComponent implements OnInit {\n" +
      "  userId: string | null = null;\n" +
      "  userName: string = '';\n" +
      "  \n" +
      "  constructor(private route: ActivatedRoute) {}\n" +
      "  \n" +
      "  ngOnInit() {\n" +
      "    // Get path parameter\n" +
      "    this.userId = this.route.snapshot.paramMap.get('id');\n" +
      "    \n" +
      "    // Subscribe to parameter changes\n" +
      "    this.route.paramMap.subscribe(params => {\n" +
      "      this.userId = params.get('id');\n" +
      "      this.loadUser(this.userId);\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  loadUser(id: string | null) {\n" +
      "    if (id) {\n" +
      "      // Load user data based on ID\n" +
      "      this.userName = `User ${id}`;\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**2. Query Parameters**\n" +
      'Query parameters are used to pass additional information in the URL as key-value pairs. They are appended to the URL after a question mark ("?") and can be accessed by components and services.\n\n' +
      "```typescript\n" +
      "// Route configuration\n" +
      "const routes: Routes = [\n" +
      "  { path: 'search', component: SearchComponent },\n" +
      "  { path: 'products', component: ProductListComponent }\n" +
      "];\n" +
      "```\n\n" +
      "**Accessing Query Parameters:**\n" +
      "```typescript\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { ActivatedRoute } from '@angular/router';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-search',\n" +
      "  template: `\n" +
      "    <div>\n" +
      "      <h2>Search Results</h2>\n" +
      "      <p>Query: {{ searchQuery }}</p>\n" +
      "      <p>Page: {{ currentPage }}</p>\n" +
      "      <p>Sort: {{ sortBy }}</p>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class SearchComponent implements OnInit {\n" +
      "  searchQuery: string = '';\n" +
      "  currentPage: number = 1;\n" +
      "  sortBy: string = 'name';\n" +
      "  \n" +
      "  constructor(private route: ActivatedRoute) {}\n" +
      "  \n" +
      "  ngOnInit() {\n" +
      "    // Get query parameters\n" +
      "    this.searchQuery = this.route.snapshot.queryParamMap.get('q') || '';\n" +
      "    this.currentPage = parseInt(this.route.snapshot.queryParamMap.get('page') || '1');\n" +
      "    this.sortBy = this.route.snapshot.queryParamMap.get('sort') || 'name';\n" +
      "    \n" +
      "    // Subscribe to query parameter changes\n" +
      "    this.route.queryParamMap.subscribe(params => {\n" +
      "      this.searchQuery = params.get('q') || '';\n" +
      "      this.currentPage = parseInt(params.get('page') || '1');\n" +
      "      this.sortBy = params.get('sort') || 'name';\n" +
      "      this.performSearch();\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  performSearch() {\n" +
      "    // Perform search based on query parameters\n" +
      "    console.log('Searching for:', this.searchQuery);\n" +
      "    console.log('Page:', this.currentPage);\n" +
      "    console.log('Sort by:', this.sortBy);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**3. Optional Parameters**\n" +
      'Optional parameters are used when you want to make a route parameter optional. They are represented by placing a question mark ("?") after the parameter name.\n\n' +
      "```typescript\n" +
      "// Route configuration with optional parameters\n" +
      "const routes: Routes = [\n" +
      "  { path: 'products/:id/:category?', component: ProductComponent },\n" +
      "  { path: 'users/:id/:tab?', component: UserProfileComponent }\n" +
      "];\n" +
      "```\n\n" +
      "**Accessing Optional Parameters:**\n" +
      "```typescript\n" +
      "import { Component, OnInit } from '@angular/core';\n" +
      "import { ActivatedRoute } from '@angular/router';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-product',\n" +
      "  template: `\n" +
      "    <div>\n" +
      "      <h2>Product Details</h2>\n" +
      "      <p>Product ID: {{ productId }}</p>\n" +
      "      <p>Category: {{ category || 'No category specified' }}</p>\n" +
      '      <div *ngIf="category">\n' +
      "        <h3>Category: {{ category }}</h3>\n" +
      "      </div>\n" +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class ProductComponent implements OnInit {\n" +
      "  productId: string | null = null;\n" +
      "  category: string | null = null;\n" +
      "  \n" +
      "  constructor(private route: ActivatedRoute) {}\n" +
      "  \n" +
      "  ngOnInit() {\n" +
      "    // Get required parameter\n" +
      "    this.productId = this.route.snapshot.paramMap.get('id');\n" +
      "    \n" +
      "    // Get optional parameter\n" +
      "    this.category = this.route.snapshot.paramMap.get('category');\n" +
      "    \n" +
      "    // Subscribe to parameter changes\n" +
      "    this.route.paramMap.subscribe(params => {\n" +
      "      this.productId = params.get('id');\n" +
      "      this.category = params.get('category');\n" +
      "      this.loadProduct();\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  loadProduct() {\n" +
      "    if (this.productId) {\n" +
      "      console.log('Loading product:', this.productId);\n" +
      "      if (this.category) {\n" +
      "        console.log('With category:', this.category);\n" +
      "      }\n" +
      "    }\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**Navigation with Parameters:**\n" +
      "```typescript\n" +
      "import { Component } from '@angular/core';\n" +
      "import { Router } from '@angular/router';\n" +
      "\n" +
      "@Component({\n" +
      "  selector: 'app-navigation',\n" +
      "  template: `\n" +
      "    <div>\n" +
      '      <button (click)="navigateToUser()">Go to User</button>\n' +
      '      <button (click)="navigateToSearch()">Go to Search</button>\n' +
      '      <button (click)="navigateToProduct()">Go to Product</button>\n' +
      "    </div>\n" +
      "  `\n" +
      "})\n" +
      "export class NavigationComponent {\n" +
      "  constructor(private router: Router) {}\n" +
      "  \n" +
      "  navigateToUser() {\n" +
      "    // Navigate with path parameter\n" +
      "    this.router.navigate(['/users', '123']);\n" +
      "  }\n" +
      "  \n" +
      "  navigateToSearch() {\n" +
      "    // Navigate with query parameters\n" +
      "    this.router.navigate(['/search'], {\n" +
      "      queryParams: {\n" +
      "        q: 'angular',\n" +
      "        page: 1,\n" +
      "        sort: 'name'\n" +
      "      }\n" +
      "    });\n" +
      "  }\n" +
      "  \n" +
      "  navigateToProduct() {\n" +
      "    // Navigate with path and optional parameters\n" +
      "    this.router.navigate(['/products', '456', 'electronics']);\n" +
      "    \n" +
      "    // Or without optional parameter\n" +
      "    // this.router.navigate(['/products', '456']);\n" +
      "  }\n" +
      "}\n" +
      "```\n\n" +
      "**URL Examples:**\n" +
      "- **Path Parameters**: `/users/123` → `id = '123'`\n" +
      "- **Query Parameters**: `/search?q=angular&page=1&sort=name` → `q = 'angular'`, `page = '1'`, `sort = 'name'`\n" +
      "- **Optional Parameters**: `/products/456/electronics` → `id = '456'`, `category = 'electronics'`\n" +
      "- **Optional Parameters (missing)**: `/products/456` → `id = '456'`, `category = null`\n\n" +
      "**Best Practices:**\n" +
      "- Use path parameters for required, identifying data\n" +
      "- Use query parameters for optional, filtering, or pagination data\n" +
      "- Use optional parameters sparingly to avoid confusion\n" +
      "- Always handle null/undefined values when accessing parameters\n" +
      "- Use `paramMap` and `queryParamMap` for type-safe parameter access\n" +
      "- Subscribe to parameter changes for dynamic updates\n" +
      "- Consider using resolvers for complex parameter-based data loading",
    category: "Routing",
    difficulty: "intermediate",
    tags: ["routing", "parameters", "path", "query", "optional"],
  },
];

export default ANGULAR_ENHANCED_QUESTIONS;
