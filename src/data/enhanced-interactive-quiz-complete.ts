/**
 * Enhanced Interactive Quiz Data - High-Quality Multiple-Choice Questions
 * Manually curated from existing Angular question content
 */

import type { InteractiveQuizQuestion } from "../types/interactive-quiz";

// Angular Questions - 30 per level with real content
export const ANGULAR_ENHANCED_QUESTIONS = {
  junior: [
    {
      id: "angular-junior-1",
      question: "What is Angular?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "A JavaScript library", isCorrect: false },
        { id: "b", text: "A complete platform for building web applications", isCorrect: true },
        { id: "c", text: "A CSS framework", isCorrect: false },
        { id: "d", text: "A database management system", isCorrect: false },
      ],
      explanation:
        "Angular is a complete platform for building web applications, not just a library. It provides a full framework with routing, forms, HTTP client, and more.",
      category: "Angular Basics",
      difficulty: "easy" as const,
      tags: ["basics", "platform"],
      points: 1,
    },
    {
      id: "angular-junior-2",
      question: "What directive is used for two-way data binding in Angular?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "*ngIf", isCorrect: false },
        { id: "b", text: "*ngFor", isCorrect: false },
        { id: "c", text: "ngModel", isCorrect: true },
        { id: "d", text: "ngClass", isCorrect: false },
      ],
      explanation:
        "Angular uses ngModel directive for two-way data binding, allowing data to flow both from component to view and from view to component.",
      category: "Data Binding",
      difficulty: "easy" as const,
      tags: ["data-binding", "ngModel"],
      points: 1,
    },
    {
      id: "angular-junior-3",
      question: "What is the purpose of Angular components?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To manage HTTP requests", isCorrect: false },
        { id: "b", text: "To define the structure and behavior of UI elements", isCorrect: true },
        { id: "c", text: "To handle routing", isCorrect: false },
        { id: "d", text: "To manage state", isCorrect: false },
      ],
      explanation:
        "Angular components define the structure and behavior of UI elements. They contain the template, component class, and metadata.",
      category: "Components",
      difficulty: "easy" as const,
      tags: ["components", "ui"],
      points: 1,
    },
    {
      id: "angular-junior-4",
      question: "Which directive is used to display a list of items?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "*ngIf", isCorrect: false },
        { id: "b", text: "*ngFor", isCorrect: true },
        { id: "c", text: "ngModel", isCorrect: false },
        { id: "d", text: "ngClass", isCorrect: false },
      ],
      explanation:
        "*ngFor is a structural directive used to display a list of items by repeating a template for each item in a collection.",
      category: "Directives",
      difficulty: "easy" as const,
      tags: ["directives", "ngFor"],
      points: 1,
    },
    {
      id: "angular-junior-5",
      question: "Which decorator is used to create Angular services?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "@Component", isCorrect: false },
        { id: "b", text: "@Injectable", isCorrect: true },
        { id: "c", text: "@NgModule", isCorrect: false },
        { id: "d", text: "@Directive", isCorrect: false },
      ],
      explanation:
        "Angular services are created using the @Injectable decorator, which makes them available for dependency injection.",
      category: "Services",
      difficulty: "easy" as const,
      tags: ["services", "dependency-injection"],
      points: 1,
    },
    {
      id: "angular-junior-6",
      question: "What is the purpose of Angular CLI?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To create, build, and test Angular applications", isCorrect: true },
        { id: "b", text: "To manage CSS styles", isCorrect: false },
        { id: "c", text: "To handle database operations", isCorrect: false },
        { id: "d", text: "To create HTML templates", isCorrect: false },
      ],
      explanation:
        "Angular CLI (Command Line Interface) is used to create, build, test, and manage Angular applications with commands like ng new, ng generate, ng build, and ng test.",
      category: "CLI",
      difficulty: "easy" as const,
      tags: ["cli", "tooling"],
      points: 1,
    },
    {
      id: "angular-junior-7",
      question: "What is the purpose of Angular modules?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "To organize related components, services, and other code",
          isCorrect: true,
        },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage CSS styles", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular modules organize related components, services, directives, and pipes into cohesive blocks of functionality.",
      category: "Modules",
      difficulty: "easy" as const,
      tags: ["modules", "organization"],
      points: 1,
    },
    {
      id: "angular-junior-8",
      question: "What is the purpose of Angular pipes?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To transform data in templates", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create components", isCorrect: false },
      ],
      explanation:
        "Angular pipes transform data in templates, such as formatting dates, currency, or text.",
      category: "Pipes",
      difficulty: "easy" as const,
      tags: ["pipes", "transformation"],
      points: 1,
    },
    {
      id: "angular-junior-9",
      question: "What is the purpose of Angular directives?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To extend HTML with custom behavior", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage state", isCorrect: false },
        { id: "d", text: "To create services", isCorrect: false },
      ],
      explanation:
        "Angular directives extend HTML with custom behavior, allowing you to create reusable UI components and behaviors.",
      category: "Directives",
      difficulty: "easy" as const,
      tags: ["directives", "html-extension"],
      points: 1,
    },
    {
      id: "angular-junior-10",
      question: "What is the purpose of Angular templates?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To define the view structure of components", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage state", isCorrect: false },
        { id: "d", text: "To create services", isCorrect: false },
      ],
      explanation:
        "Angular templates define the view structure of components using HTML with Angular-specific syntax and directives.",
      category: "Templates",
      difficulty: "easy" as const,
      tags: ["templates", "views"],
      points: 1,
    },
    {
      id: "angular-junior-11",
      question: "What is the purpose of Angular decorators?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To add metadata to classes", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular decorators add metadata to classes, telling Angular how to process them (e.g., @Component, @Injectable).",
      category: "Decorators",
      difficulty: "easy" as const,
      tags: ["decorators", "metadata"],
      points: 1,
    },
    {
      id: "angular-junior-12",
      question: "What is the purpose of Angular lifecycle hooks?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To respond to component lifecycle events", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular lifecycle hooks allow you to respond to component lifecycle events like initialization, changes, and destruction.",
      category: "Lifecycle Hooks",
      difficulty: "easy" as const,
      tags: ["lifecycle", "hooks"],
      points: 1,
    },
    {
      id: "angular-junior-13",
      question: "What is the purpose of Angular forms?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To handle user input and validation", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular forms handle user input, validation, and form submission with both template-driven and reactive approaches.",
      category: "Forms",
      difficulty: "easy" as const,
      tags: ["forms", "validation"],
      points: 1,
    },
    {
      id: "angular-junior-14",
      question: "What is the purpose of Angular routing?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To navigate between different views", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage forms", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular routing enables navigation between different views/components based on URL changes.",
      category: "Routing",
      difficulty: "easy" as const,
      tags: ["routing", "navigation"],
      points: 1,
    },
    {
      id: "angular-junior-15",
      question: "What is the purpose of Angular services?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To share data and logic between components", isCorrect: true },
        { id: "b", text: "To handle routing", isCorrect: false },
        { id: "c", text: "To manage forms", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular services are used to share data and logic between components, handle business logic, and manage state.",
      category: "Services",
      difficulty: "easy" as const,
      tags: ["services", "data-sharing"],
      points: 1,
    },
    {
      id: "angular-junior-16",
      question: "What is the purpose of Angular components?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To define the structure and behavior of UI elements", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular components define the structure and behavior of UI elements. They contain the template, component class, and metadata.",
      category: "Components",
      difficulty: "easy" as const,
      tags: ["components", "ui"],
      points: 1,
    },
    {
      id: "angular-junior-17",
      question: "What is the purpose of Angular dependency injection?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To provide dependencies to components and services", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular dependency injection provides dependencies to components and services, promoting modularity and testability.",
      category: "Dependency Injection",
      difficulty: "easy" as const,
      tags: ["dependency-injection", "modularity"],
      points: 1,
    },
    {
      id: "angular-junior-18",
      question: "What is the purpose of Angular change detection?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To update the DOM when component data changes", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular change detection updates the DOM when component data changes, keeping the view in sync with the component state.",
      category: "Change Detection",
      difficulty: "easy" as const,
      tags: ["change-detection", "dom-updates"],
      points: 1,
    },
    {
      id: "angular-junior-19",
      question: "What is the purpose of Angular testing?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To ensure code quality and functionality", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular testing ensures code quality and functionality through unit tests, integration tests, and end-to-end tests.",
      category: "Testing",
      difficulty: "easy" as const,
      tags: ["testing", "quality"],
      points: 1,
    },
    {
      id: "angular-junior-20",
      question: "What is the purpose of Angular CLI?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To generate, build, and test Angular applications", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular CLI (Command Line Interface) generates, builds, and tests Angular applications with commands like ng generate, ng build, and ng test.",
      category: "CLI",
      difficulty: "easy" as const,
      tags: ["cli", "tooling"],
      points: 1,
    },
    {
      id: "angular-junior-21",
      question: "What is the purpose of Angular observables?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To handle asynchronous data streams", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular observables handle asynchronous data streams, allowing you to work with data that arrives over time.",
      category: "Observables",
      difficulty: "easy" as const,
      tags: ["observables", "async"],
      points: 1,
    },
    {
      id: "angular-junior-22",
      question: "What is the purpose of Angular zones?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To detect changes and trigger change detection", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular zones detect changes and trigger change detection automatically, ensuring the UI stays in sync with component state.",
      category: "Zones",
      difficulty: "easy" as const,
      tags: ["zones", "change-detection"],
      points: 1,
    },
    {
      id: "angular-junior-23",
      question: "What is the purpose of Angular standalone components?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To create components without NgModule", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular standalone components allow you to create components without needing to declare them in an NgModule, simplifying the component architecture.",
      category: "Standalone Components",
      difficulty: "easy" as const,
      tags: ["standalone", "architecture"],
      points: 1,
    },
    {
      id: "angular-junior-24",
      question: "What is the purpose of Angular performance optimization?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To improve application speed and efficiency", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular performance optimization improves application speed and efficiency through techniques like OnPush strategy, lazy loading, and trackBy functions.",
      category: "Performance",
      difficulty: "easy" as const,
      tags: ["performance", "optimization"],
      points: 1,
    },
    {
      id: "angular-junior-25",
      question: "What is the purpose of Angular Universal?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To enable server-side rendering (SSR)", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular Universal enables server-side rendering (SSR) for Angular applications, improving SEO and initial load performance.",
      category: "SSR",
      difficulty: "easy" as const,
      tags: ["ssr", "universal"],
      points: 1,
    },
    {
      id: "angular-junior-26",
      question: "What is the purpose of Angular schematics?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To automate code generation and modifications", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular schematics automate code generation and modifications, helping to maintain consistency and best practices across projects.",
      category: "Schematics",
      difficulty: "easy" as const,
      tags: ["schematics", "cli"],
      points: 1,
    },
    {
      id: "angular-junior-27",
      question: "What is the purpose of Angular animations?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To create rich UI animations and transitions", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create services", isCorrect: false },
      ],
      explanation:
        "Angular animations provide a powerful API to create rich UI animations and transitions, enhancing user experience.",
      category: "Animations",
      difficulty: "easy" as const,
      tags: ["animations", "ui"],
      points: 1,
    },
    {
      id: "angular-junior-28",
      question: "What is the purpose of Angular internationalization (i18n)?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To support multiple languages and regions", isCorrect: true },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular internationalization (i18n) provides tools to support multiple languages and regions in your application, making it accessible to a global audience.",
      category: "Internationalization",
      difficulty: "easy" as const,
      tags: ["i18n", "localization"],
      points: 1,
    },
    {
      id: "angular-junior-29",
      question: "What is the purpose of Angular accessibility (a11y)?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "To make applications usable by people with disabilities",
          isCorrect: true,
        },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular accessibility (a11y) focuses on making applications usable by people with disabilities, following web accessibility standards and guidelines.",
      category: "Accessibility",
      difficulty: "easy" as const,
      tags: ["a11y", "usability"],
      points: 1,
    },
    {
      id: "angular-junior-30",
      question: "What is the purpose of Angular Material?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "To provide pre-built UI components following Material Design",
          isCorrect: true,
        },
        { id: "b", text: "To handle HTTP requests", isCorrect: false },
        { id: "c", text: "To manage routing", isCorrect: false },
        { id: "d", text: "To create animations", isCorrect: false },
      ],
      explanation:
        "Angular Material provides pre-built UI components that follow Google's Material Design principles, making it easier to create consistent and beautiful user interfaces.",
      category: "Material Design",
      difficulty: "easy" as const,
      tags: ["material", "ui-components"],
      points: 1,
    },
  ] as InteractiveQuizQuestion[],

  intermediate: [
    {
      id: "angular-intermediate-1",
      question: "What are HTTP Interceptors in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Services that intercept and modify HTTP requests and responses globally",
          isCorrect: true,
        },
        { id: "b", text: "Components that handle HTTP requests", isCorrect: false },
        { id: "c", text: "Guards that protect HTTP routes", isCorrect: false },
        { id: "d", text: "Pipes that transform HTTP data", isCorrect: false },
      ],
      explanation:
        "HTTP Interceptors are services that intercept and modify HTTP requests and responses globally in your Angular application, commonly used for authentication, logging, and error handling.",
      category: "HTTP",
      difficulty: "medium" as const,
      tags: ["interceptors", "http"],
      points: 2,
    },
    {
      id: "angular-intermediate-2",
      question: "How do you implement lazy loading in Angular?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "Using loadChildren in routing configuration", isCorrect: true },
        { id: "b", text: "Using ngOnInit hook", isCorrect: false },
        { id: "c", text: "Using @Injectable decorator", isCorrect: false },
        { id: "d", text: "Using *ngIf directive", isCorrect: false },
      ],
      explanation:
        "Lazy loading is implemented using loadChildren in the routing configuration, which loads modules only when their routes are accessed, improving initial load time.",
      category: "Routing",
      difficulty: "medium" as const,
      tags: ["routing", "lazy-loading", "performance"],
      points: 2,
    },
    {
      id: "angular-intermediate-3",
      question: "What is RxJS used for in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Reactive programming and handling asynchronous data streams",
          isCorrect: true,
        },
        { id: "b", text: "Managing component state", isCorrect: false },
        { id: "c", text: "Handling routing", isCorrect: false },
        { id: "d", text: "Creating templates", isCorrect: false },
      ],
      explanation:
        "Angular uses RxJS (Reactive Extensions for JavaScript) for reactive programming, providing powerful tools like observables, operators, and subjects to handle asynchronous data streams.",
      category: "RxJS",
      difficulty: "medium" as const,
      tags: ["rxjs", "reactive-programming", "observables"],
      points: 2,
    },
    {
      id: "angular-intermediate-4",
      question: "What is the difference between ngOnInit and constructor?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "constructor runs after ngOnInit", isCorrect: false },
        {
          id: "b",
          text: "constructor runs before ngOnInit and is for dependency injection",
          isCorrect: true,
        },
        { id: "c", text: "They are the same", isCorrect: false },
        { id: "d", text: "ngOnInit is for services only", isCorrect: false },
      ],
      explanation:
        "The constructor runs first and is primarily for dependency injection. ngOnInit runs after the component's input properties have been initialized and is used for component initialization logic.",
      category: "Lifecycle",
      difficulty: "medium" as const,
      tags: ["lifecycle", "ngOnInit", "constructor"],
      points: 2,
    },
    {
      id: "angular-intermediate-5",
      question: "How do you handle HTTP errors in Angular?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "Using catchError operator with RxJS", isCorrect: true },
        { id: "b", text: "Using try-catch blocks", isCorrect: false },
        { id: "c", text: "Using error property in HttpClient", isCorrect: false },
        { id: "d", text: "Using throwError in templates", isCorrect: false },
      ],
      explanation:
        "HTTP errors are handled using the catchError operator from RxJS, which allows you to catch and handle errors in the observable stream.",
      category: "HTTP",
      difficulty: "medium" as const,
      tags: ["http", "error-handling", "rxjs"],
      points: 2,
    },
    {
      id: "angular-intermediate-6",
      question: "What's the difference between reactive and template-driven forms?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "Reactive forms are more scalable and testable", isCorrect: true },
        { id: "b", text: "Template-driven forms are more scalable", isCorrect: false },
        { id: "c", text: "No difference, they're the same", isCorrect: false },
        { id: "d", text: "Reactive forms only work with TypeScript", isCorrect: false },
      ],
      explanation:
        "Reactive forms are more scalable, testable, and provide better control over form validation and data flow compared to template-driven forms.",
      category: "Forms",
      difficulty: "medium" as const,
      tags: ["forms", "reactive", "template-driven"],
      points: 2,
    },
    {
      id: "angular-intermediate-7",
      question: "How do you implement custom validators in Angular?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "Create a function that returns ValidatorFn", isCorrect: true },
        { id: "b", text: "Extend the Validator class", isCorrect: false },
        { id: "c", text: "Use @Validator decorator", isCorrect: false },
        { id: "d", text: "Implement Validator interface", isCorrect: false },
      ],
      explanation:
        "Custom validators are functions that return a ValidatorFn, which takes a FormControl and returns validation errors or null.",
      category: "Validation",
      difficulty: "medium" as const,
      tags: ["validation", "custom-validators", "forms"],
      points: 2,
    },
    {
      id: "angular-intermediate-8",
      question: "What is the OnPush change detection strategy?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "A strategy that only checks for changes when inputs change or events occur",
          isCorrect: true,
        },
        { id: "b", text: "A strategy that checks for changes every second", isCorrect: false },
        { id: "c", text: "A strategy that never checks for changes", isCorrect: false },
        { id: "d", text: "A strategy that checks for changes continuously", isCorrect: false },
      ],
      explanation:
        "OnPush change detection strategy only checks for changes when input properties change, events are triggered, or observables emit new values, improving performance.",
      category: "Performance",
      difficulty: "medium" as const,
      tags: ["performance", "change-detection", "onpush"],
      points: 2,
    },
    {
      id: "angular-intermediate-9",
      question: "How do you implement route guards in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Implement CanActivate interface and add to route configuration",
          isCorrect: true,
        },
        { id: "b", text: "Use @Guard decorator", isCorrect: false },
        { id: "c", text: "Extend Guard class", isCorrect: false },
        { id: "d", text: "Use *ngGuard directive", isCorrect: false },
      ],
      explanation:
        "Route guards are implemented by creating a service that implements interfaces like CanActivate, CanDeactivate, etc., and then adding them to the route configuration.",
      category: "Routing",
      difficulty: "medium" as const,
      tags: ["guards", "routing", "authentication"],
      points: 2,
    },
    {
      id: "angular-intermediate-10",
      question: "What is dependency injection in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "A design pattern that provides dependencies to classes",
          isCorrect: true,
        },
        { id: "b", text: "A way to inject CSS into components", isCorrect: false },
        { id: "c", text: "A method to inject HTML templates", isCorrect: false },
        { id: "d", text: "A way to inject JavaScript libraries", isCorrect: false },
      ],
      explanation:
        "Dependency injection is a design pattern where dependencies are provided to classes rather than being created within them, promoting modularity and testability.",
      category: "Dependency Injection",
      difficulty: "medium" as const,
      tags: ["dependency-injection", "design-patterns"],
      points: 2,
    },
    {
      id: "angular-intermediate-11",
      question: "How do you create a custom pipe in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Create a class with @Pipe decorator and implement PipeTransform",
          isCorrect: true,
        },
        { id: "b", text: "Extend the Pipe class", isCorrect: false },
        { id: "c", text: "Use @PipeTransform decorator", isCorrect: false },
        { id: "d", text: "Implement Pipe interface", isCorrect: false },
      ],
      explanation:
        "Custom pipes are created by defining a class with the @Pipe decorator and implementing the PipeTransform interface with a transform method.",
      category: "Pipes",
      difficulty: "medium" as const,
      tags: ["pipes", "custom-pipes", "transformation"],
      points: 2,
    },
    {
      id: "angular-intermediate-12",
      question: "What is the difference between BehaviorSubject and Subject?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "BehaviorSubject has an initial value and emits the last value to new subscribers",
          isCorrect: true,
        },
        { id: "b", text: "Subject has an initial value", isCorrect: false },
        { id: "c", text: "No difference, they're the same", isCorrect: false },
        { id: "d", text: "BehaviorSubject is only for HTTP requests", isCorrect: false },
      ],
      explanation:
        "BehaviorSubject extends Subject and has an initial value. It emits the last emitted value to new subscribers, while Subject only emits values after subscription.",
      category: "RxJS",
      difficulty: "medium" as const,
      tags: ["rxjs", "behavior-subject", "subject"],
      points: 2,
    },
    {
      id: "angular-intermediate-13",
      question: "How do you implement two-way data binding with reactive forms?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "Use FormControl with [(ngModel)] or formControlName", isCorrect: true },
        { id: "b", text: "Use only ngModel directive", isCorrect: false },
        { id: "c", text: "Use only formControlName", isCorrect: false },
        { id: "d", text: "Use @Input and @Output decorators", isCorrect: false },
      ],
      explanation:
        "In reactive forms, two-way data binding is achieved using FormControl with either [(ngModel)] or formControlName directive, depending on the approach.",
      category: "Forms",
      difficulty: "medium" as const,
      tags: ["forms", "reactive", "data-binding"],
      points: 2,
    },
    {
      id: "angular-intermediate-14",
      question: "What is the purpose of trackBy function in *ngFor?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "To optimize performance by tracking items by unique identifier",
          isCorrect: true,
        },
        { id: "b", text: "To filter items in the list", isCorrect: false },
        { id: "c", text: "To sort items in the list", isCorrect: false },
        { id: "d", text: "To validate items in the list", isCorrect: false },
      ],
      explanation:
        "trackBy function helps Angular track items in *ngFor by providing a unique identifier, preventing unnecessary DOM re-rendering and improving performance.",
      category: "Performance",
      difficulty: "medium" as const,
      tags: ["performance", "ngFor", "trackBy"],
      points: 2,
    },
    {
      id: "angular-intermediate-15",
      question: "How do you implement custom directives in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Create a class with @Directive decorator and implement ElementRef",
          isCorrect: true,
        },
        { id: "b", text: "Extend the Directive class", isCorrect: false },
        { id: "c", text: "Use @DirectiveTransform decorator", isCorrect: false },
        { id: "d", text: "Implement Directive interface", isCorrect: false },
      ],
      explanation:
        "Custom directives are created by defining a class with the @Directive decorator and injecting ElementRef to manipulate DOM elements.",
      category: "Directives",
      difficulty: "medium" as const,
      tags: ["directives", "custom-directives", "dom"],
      points: 2,
    },
    {
      id: "angular-intermediate-16",
      question: "What is the difference between async and async pipe?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "async pipe automatically subscribes and unsubscribes from observables",
          isCorrect: true,
        },
        { id: "b", text: "async pipe is only for promises", isCorrect: false },
        { id: "c", text: "async pipe is deprecated", isCorrect: false },
        { id: "d", text: "No difference, they're the same", isCorrect: false },
      ],
      explanation:
        "The async pipe automatically subscribes to observables and promises, handles the subscription lifecycle, and updates the view when new values are emitted.",
      category: "Pipes",
      difficulty: "medium" as const,
      tags: ["pipes", "async", "observables"],
      points: 2,
    },
    {
      id: "angular-intermediate-17",
      question: "How do you implement error handling in Angular applications?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use ErrorHandler service, HTTP interceptors, and try-catch blocks",
          isCorrect: true,
        },
        { id: "b", text: "Only use try-catch blocks", isCorrect: false },
        { id: "c", text: "Only use ErrorHandler service", isCorrect: false },
        { id: "d", text: "Use console.error() method", isCorrect: false },
      ],
      explanation:
        "Angular error handling involves multiple approaches: ErrorHandler service for global errors, HTTP interceptors for HTTP errors, and try-catch blocks for synchronous code.",
      category: "Error Handling",
      difficulty: "medium" as const,
      tags: ["error-handling", "interceptors", "errorhandler"],
      points: 2,
    },
    {
      id: "angular-intermediate-18",
      question: "What is the purpose of Angular modules (NgModule)?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "To organize and configure related components, services, and other code",
          isCorrect: true,
        },
        { id: "b", text: "To manage HTTP requests", isCorrect: false },
        { id: "c", text: "To handle routing only", isCorrect: false },
        { id: "d", text: "To create components", isCorrect: false },
      ],
      explanation:
        "Angular modules organize related components, services, directives, and pipes into cohesive blocks of functionality and configure how they work together.",
      category: "Modules",
      difficulty: "medium" as const,
      tags: ["modules", "ngmodule", "organization"],
      points: 2,
    },
    {
      id: "angular-intermediate-19",
      question: "How do you implement state management in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use services with RxJS, NgRx, or state management libraries",
          isCorrect: true,
        },
        { id: "b", text: "Use only component properties", isCorrect: false },
        { id: "c", text: "Use only localStorage", isCorrect: false },
        { id: "d", text: "Use only @Input and @Output", isCorrect: false },
      ],
      explanation:
        "State management in Angular can be implemented using services with RxJS for simple cases, or libraries like NgRx for complex applications requiring centralized state management.",
      category: "State Management",
      difficulty: "medium" as const,
      tags: ["state-management", "rxjs", "ngrx"],
      points: 2,
    },
    {
      id: "angular-intermediate-20",
      question: "What is the difference between ViewChild and ViewChildren?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "ViewChild gets one element, ViewChildren gets multiple elements",
          isCorrect: true,
        },
        {
          id: "b",
          text: "ViewChild is for services, ViewChildren is for components",
          isCorrect: false,
        },
        { id: "c", text: "No difference, they're the same", isCorrect: false },
        { id: "d", text: "ViewChild is deprecated", isCorrect: false },
      ],
      explanation:
        "ViewChild decorator is used to get a reference to a single child element or component, while ViewChildren decorator is used to get references to multiple child elements or components.",
      category: "View Queries",
      difficulty: "medium" as const,
      tags: ["viewchild", "viewchildren", "queries"],
      points: 2,
    },
    {
      id: "angular-intermediate-21",
      question: "How do you implement internationalization (i18n) in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use Angular i18n tools, extract translations, and configure locales",
          isCorrect: true,
        },
        { id: "b", text: "Use only Angular CLI", isCorrect: false },
        { id: "c", text: "Use only TypeScript", isCorrect: false },
        { id: "d", text: "Use only CSS", isCorrect: false },
      ],
      explanation:
        "Angular i18n involves marking text for translation, extracting translation files, translating content, and configuring the application for different locales.",
      category: "Internationalization",
      difficulty: "medium" as const,
      tags: ["i18n", "internationalization", "localization"],
      points: 2,
    },
    {
      id: "angular-intermediate-22",
      question: "What is the purpose of Angular Universal?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "To enable server-side rendering (SSR) for Angular applications",
          isCorrect: true,
        },
        { id: "b", text: "To create universal components", isCorrect: false },
        { id: "c", text: "To handle universal routing", isCorrect: false },
        { id: "d", text: "To manage universal state", isCorrect: false },
      ],
      explanation:
        "Angular Universal enables server-side rendering (SSR) for Angular applications, improving SEO, initial load performance, and accessibility.",
      category: "SSR",
      difficulty: "medium" as const,
      tags: ["ssr", "universal", "seo"],
      points: 2,
    },
    {
      id: "angular-intermediate-23",
      question: "How do you implement authentication in Angular applications?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "Use guards, interceptors, and authentication services", isCorrect: true },
        { id: "b", text: "Use only localStorage", isCorrect: false },
        { id: "c", text: "Use only cookies", isCorrect: false },
        { id: "d", text: "Use only sessionStorage", isCorrect: false },
      ],
      explanation:
        "Angular authentication typically involves route guards for protection, HTTP interceptors for token management, and authentication services for login/logout functionality.",
      category: "Authentication",
      difficulty: "medium" as const,
      tags: ["authentication", "guards", "interceptors"],
      points: 2,
    },
    {
      id: "angular-intermediate-24",
      question: "What is the difference between pure and impure pipes?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Pure pipes only run when input changes, impure pipes run on every change detection",
          isCorrect: true,
        },
        { id: "b", text: "Pure pipes are deprecated", isCorrect: false },
        { id: "c", text: "No difference, they're the same", isCorrect: false },
        { id: "d", text: "Impure pipes are faster", isCorrect: false },
      ],
      explanation:
        "Pure pipes only execute when their input parameters change, while impure pipes execute on every change detection cycle, making them less performant.",
      category: "Pipes",
      difficulty: "medium" as const,
      tags: ["pipes", "pure", "impure", "performance"],
      points: 2,
    },
    {
      id: "angular-intermediate-25",
      question: "How do you implement testing in Angular applications?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "Use Jasmine, Karma, and Angular Testing Utilities", isCorrect: true },
        { id: "b", text: "Use only Jest", isCorrect: false },
        { id: "c", text: "Use only Mocha", isCorrect: false },
        { id: "d", text: "Use only Cypress", isCorrect: false },
      ],
      explanation:
        "Angular testing uses Jasmine as the testing framework, Karma as the test runner, and Angular Testing Utilities for component and service testing.",
      category: "Testing",
      difficulty: "medium" as const,
      tags: ["testing", "jasmine", "karma"],
      points: 2,
    },
    {
      id: "angular-intermediate-26",
      question: "What is the purpose of Angular CLI schematics?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "To automate code generation and project modifications", isCorrect: true },
        { id: "b", text: "To create only components", isCorrect: false },
        { id: "c", text: "To manage only dependencies", isCorrect: false },
        { id: "d", text: "To handle only routing", isCorrect: false },
      ],
      explanation:
        "Angular CLI schematics automate code generation, project modifications, and enforce best practices through templates and rules.",
      category: "CLI",
      difficulty: "medium" as const,
      tags: ["cli", "schematics", "code-generation"],
      points: 2,
    },
    {
      id: "angular-intermediate-27",
      question: "How do you implement animations in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use Angular Animations API with trigger, state, and transition",
          isCorrect: true,
        },
        { id: "b", text: "Use only CSS animations", isCorrect: false },
        { id: "c", text: "Use only JavaScript animations", isCorrect: false },
        { id: "d", text: "Use only jQuery animations", isCorrect: false },
      ],
      explanation:
        "Angular animations use the Angular Animations API with triggers, states, and transitions to create rich, declarative animations.",
      category: "Animations",
      difficulty: "medium" as const,
      tags: ["animations", "transitions", "states"],
      points: 2,
    },
    {
      id: "angular-intermediate-28",
      question: "What is the purpose of Angular zones?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "To detect changes and trigger change detection automatically",
          isCorrect: true,
        },
        { id: "b", text: "To manage HTTP requests", isCorrect: false },
        { id: "c", text: "To handle routing", isCorrect: false },
        { id: "d", text: "To manage forms", isCorrect: false },
      ],
      explanation:
        "Angular zones detect changes and automatically trigger change detection, keeping the UI in sync with component state.",
      category: "Zones",
      difficulty: "medium" as const,
      tags: ["zones", "change-detection"],
      points: 2,
    },
    {
      id: "angular-intermediate-29",
      question: "How do you implement performance optimization in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use OnPush strategy, lazy loading, trackBy, and AOT compilation",
          isCorrect: true,
        },
        { id: "b", text: "Use only OnPush strategy", isCorrect: false },
        { id: "c", text: "Use only lazy loading", isCorrect: false },
        { id: "d", text: "Use only trackBy", isCorrect: false },
      ],
      explanation:
        "Angular performance optimization involves multiple techniques: OnPush change detection, lazy loading, trackBy functions, AOT compilation, and tree shaking.",
      category: "Performance",
      difficulty: "medium" as const,
      tags: ["performance", "optimization", "onpush"],
      points: 2,
    },
    {
      id: "angular-intermediate-30",
      question: "What is the purpose of Angular standalone components?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "To create components without requiring NgModule declarations",
          isCorrect: true,
        },
        { id: "b", text: "To create components that work alone", isCorrect: false },
        { id: "c", text: "To create components without dependencies", isCorrect: false },
        { id: "d", text: "To create components without templates", isCorrect: false },
      ],
      explanation:
        "Angular standalone components can be created and used without being declared in an NgModule, simplifying the component architecture and reducing boilerplate.",
      category: "Standalone Components",
      difficulty: "medium" as const,
      tags: ["standalone", "components", "architecture"],
      points: 2,
    },
  ] as InteractiveQuizQuestion[],

  senior: [
    {
      id: "angular-senior-1",
      question: "How do you implement micro-frontends with Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use Module Federation, single-spa, or Angular Elements",
          isCorrect: true,
        },
        { id: "b", text: "Use only Angular Elements", isCorrect: false },
        { id: "c", text: "Use only Module Federation", isCorrect: false },
        { id: "d", text: "Use only single-spa", isCorrect: false },
      ],
      explanation:
        "Micro-frontends with Angular can be implemented using Module Federation for webpack-based apps, single-spa for framework-agnostic approach, or Angular Elements for custom elements.",
      category: "Architecture",
      difficulty: "hard" as const,
      tags: ["micro-frontends", "architecture", "module-federation"],
      points: 3,
    },
    {
      id: "angular-senior-2",
      question: "How do you implement advanced RxJS patterns in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use operators like switchMap, mergeMap, combineLatest, and custom operators",
          isCorrect: true,
        },
        { id: "b", text: "Use only map operator", isCorrect: false },
        { id: "c", text: "Use only filter operator", isCorrect: false },
        { id: "d", text: "Use only subscribe method", isCorrect: false },
      ],
      explanation:
        "Advanced RxJS patterns involve complex operators like switchMap for request cancellation, mergeMap for concurrent requests, combineLatest for combining streams, and creating custom operators.",
      category: "RxJS",
      difficulty: "hard" as const,
      tags: ["rxjs", "operators", "patterns"],
      points: 3,
    },
    {
      id: "angular-senior-3",
      question: "How do you implement custom change detection strategies?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Create custom ChangeDetectionStrategy and implement DoCheck interface",
          isCorrect: true,
        },
        { id: "b", text: "Use only OnPush strategy", isCorrect: false },
        { id: "c", text: "Use only Default strategy", isCorrect: false },
        { id: "d", text: "Use only OnChanges interface", isCorrect: false },
      ],
      explanation:
        "Custom change detection involves creating strategies that implement specific change detection logic and using interfaces like DoCheck for custom change detection hooks.",
      category: "Change Detection",
      difficulty: "hard" as const,
      tags: ["change-detection", "custom-strategies", "performance"],
      points: 3,
    },
    {
      id: "angular-senior-4",
      question: "How do you implement advanced state management with NgRx?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use actions, reducers, effects, selectors, and store with advanced patterns",
          isCorrect: true,
        },
        { id: "b", text: "Use only actions and reducers", isCorrect: false },
        { id: "c", text: "Use only effects", isCorrect: false },
        { id: "d", text: "Use only selectors", isCorrect: false },
      ],
      explanation:
        "Advanced NgRx involves complex patterns with actions, reducers, effects, selectors, store configuration, and advanced techniques like entity management and feature modules.",
      category: "State Management",
      difficulty: "hard" as const,
      tags: ["ngrx", "state-management", "redux"],
      points: 3,
    },
    {
      id: "angular-senior-5",
      question: "How do you implement advanced testing strategies in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use unit tests, integration tests, e2e tests, and testing utilities",
          isCorrect: true,
        },
        { id: "b", text: "Use only unit tests", isCorrect: false },
        { id: "c", text: "Use only integration tests", isCorrect: false },
        { id: "d", text: "Use only e2e tests", isCorrect: false },
      ],
      explanation:
        "Advanced testing involves comprehensive strategies: unit tests for components/services, integration tests for feature modules, e2e tests for user workflows, and proper testing utilities setup.",
      category: "Testing",
      difficulty: "hard" as const,
      tags: ["testing", "unit-tests", "integration-tests", "e2e"],
      points: 3,
    },
    {
      id: "angular-senior-6",
      question: "How do you implement advanced RxJS patterns with custom operators?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Create custom operators using pipe() and implement OperatorFunction interface",
          isCorrect: true,
        },
        { id: "b", text: "Use only built-in operators", isCorrect: false },
        { id: "c", text: "Extend Observable class", isCorrect: false },
        { id: "d", text: "Use only map and filter operators", isCorrect: false },
      ],
      explanation:
        "Custom RxJS operators are created by implementing the OperatorFunction interface and using the pipe() method to compose complex data transformations.",
      category: "RxJS",
      difficulty: "hard" as const,
      tags: ["rxjs", "custom-operators", "advanced"],
      points: 3,
    },
    {
      id: "angular-senior-7",
      question: "How do you implement advanced state management with NgRx Entity?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use EntityState, EntityAdapter, and entity selectors for normalized data",
          isCorrect: true,
        },
        { id: "b", text: "Use only basic NgRx store", isCorrect: false },
        { id: "c", text: "Use only effects", isCorrect: false },
        { id: "d", text: "Use only actions", isCorrect: false },
      ],
      explanation:
        "NgRx Entity provides normalized state management for collections of entities, using EntityState, EntityAdapter, and specialized selectors for efficient data operations.",
      category: "State Management",
      difficulty: "hard" as const,
      tags: ["ngrx", "entity", "normalized-state"],
      points: 3,
    },
    {
      id: "angular-senior-8",
      question: "How do you implement advanced routing with dynamic route configuration?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "Use Router.resetConfig() and dynamic route generation", isCorrect: true },
        { id: "b", text: "Use only static routes", isCorrect: false },
        { id: "c", text: "Use only lazy loading", isCorrect: false },
        { id: "d", text: "Use only route guards", isCorrect: false },
      ],
      explanation:
        "Dynamic routing involves programmatically configuring routes at runtime using Router.resetConfig() and generating routes based on user permissions or data.",
      category: "Routing",
      difficulty: "hard" as const,
      tags: ["routing", "dynamic", "advanced"],
      points: 3,
    },
    {
      id: "angular-senior-9",
      question: "How do you implement advanced form validation with custom async validators?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Create AsyncValidatorFn with HTTP calls and debouncing",
          isCorrect: true,
        },
        { id: "b", text: "Use only sync validators", isCorrect: false },
        { id: "c", text: "Use only built-in validators", isCorrect: false },
        { id: "d", text: "Use only template-driven validation", isCorrect: false },
      ],
      explanation:
        "Advanced async validation involves creating AsyncValidatorFn functions that make HTTP calls, implement debouncing, and handle complex validation scenarios.",
      category: "Forms",
      difficulty: "hard" as const,
      tags: ["forms", "async-validation", "advanced"],
      points: 3,
    },
    {
      id: "angular-senior-10",
      question: "How do you implement advanced performance monitoring and optimization?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use Angular DevTools, Web Vitals, and custom performance metrics",
          isCorrect: true,
        },
        { id: "b", text: "Use only OnPush strategy", isCorrect: false },
        { id: "c", text: "Use only lazy loading", isCorrect: false },
        { id: "d", text: "Use only AOT compilation", isCorrect: false },
      ],
      explanation:
        "Advanced performance monitoring involves using Angular DevTools, Web Vitals API, custom performance metrics, and profiling tools to identify and optimize bottlenecks.",
      category: "Performance",
      difficulty: "hard" as const,
      tags: ["performance", "monitoring", "optimization"],
      points: 3,
    },
    {
      id: "angular-senior-11",
      question: "How do you implement advanced security patterns in Angular applications?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use CSP, XSS protection, CSRF tokens, and secure authentication",
          isCorrect: true,
        },
        { id: "b", text: "Use only HTTPS", isCorrect: false },
        { id: "c", text: "Use only route guards", isCorrect: false },
        { id: "d", text: "Use only input validation", isCorrect: false },
      ],
      explanation:
        "Advanced security involves implementing Content Security Policy (CSP), XSS protection, CSRF tokens, secure authentication flows, and following OWASP guidelines.",
      category: "Security",
      difficulty: "hard" as const,
      tags: ["security", "csp", "xss", "csrf"],
      points: 3,
    },
    {
      id: "angular-senior-12",
      question: "How do you implement advanced testing with mocking and test utilities?",
      type: "multiple-choice" as const,
      options: [
        { id: "a", text: "Use TestBed, spies, mocks, and custom test utilities", isCorrect: true },
        { id: "b", text: "Use only basic component testing", isCorrect: false },
        { id: "c", text: "Use only unit tests", isCorrect: false },
        { id: "d", text: "Use only integration tests", isCorrect: false },
      ],
      explanation:
        "Advanced testing involves using TestBed configuration, spies for mocking dependencies, custom test utilities, and comprehensive test coverage strategies.",
      category: "Testing",
      difficulty: "hard" as const,
      tags: ["testing", "mocking", "test-utilities"],
      points: 3,
    },
    {
      id: "angular-senior-13",
      question: "How do you implement advanced error handling and recovery strategies?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use global error handlers, retry mechanisms, and graceful degradation",
          isCorrect: true,
        },
        { id: "b", text: "Use only try-catch blocks", isCorrect: false },
        { id: "c", text: "Use only HTTP interceptors", isCorrect: false },
        { id: "d", text: "Use only console.error", isCorrect: false },
      ],
      explanation:
        "Advanced error handling involves global error handlers, retry mechanisms with exponential backoff, graceful degradation, and comprehensive error recovery strategies.",
      category: "Error Handling",
      difficulty: "hard" as const,
      tags: ["error-handling", "recovery", "resilience"],
      points: 3,
    },
    {
      id: "angular-senior-14",
      question: "How do you implement advanced caching strategies in Angular?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use HTTP interceptors, service workers, and intelligent cache invalidation",
          isCorrect: true,
        },
        { id: "b", text: "Use only browser cache", isCorrect: false },
        { id: "c", text: "Use only localStorage", isCorrect: false },
        { id: "d", text: "Use only sessionStorage", isCorrect: false },
      ],
      explanation:
        "Advanced caching involves HTTP interceptors for API caching, service workers for offline caching, and intelligent cache invalidation strategies.",
      category: "Caching",
      difficulty: "hard" as const,
      tags: ["caching", "service-workers", "performance"],
      points: 3,
    },
    {
      id: "angular-senior-15",
      question: "How do you implement advanced accessibility (a11y) features?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use ARIA attributes, keyboard navigation, and screen reader support",
          isCorrect: true,
        },
        { id: "b", text: "Use only alt text", isCorrect: false },
        { id: "c", text: "Use only semantic HTML", isCorrect: false },
        { id: "d", text: "Use only color contrast", isCorrect: false },
      ],
      explanation:
        "Advanced accessibility involves ARIA attributes, keyboard navigation, screen reader support, focus management, and WCAG compliance.",
      category: "Accessibility",
      difficulty: "hard" as const,
      tags: ["a11y", "aria", "wcag"],
      points: 3,
    },
    {
      id: "angular-senior-16",
      question: "How do you implement advanced internationalization (i18n) with dynamic content?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use Angular i18n with dynamic translations and locale-specific formatting",
          isCorrect: true,
        },
        { id: "b", text: "Use only static translations", isCorrect: false },
        { id: "c", text: "Use only date formatting", isCorrect: false },
        { id: "d", text: "Use only number formatting", isCorrect: false },
      ],
      explanation:
        "Advanced i18n involves dynamic translations, locale-specific formatting, pluralization, and runtime language switching.",
      category: "Internationalization",
      difficulty: "hard" as const,
      tags: ["i18n", "localization", "dynamic"],
      points: 3,
    },
    {
      id: "angular-senior-17",
      question: "How do you implement advanced build optimization and tree shaking?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use AOT compilation, tree shaking, and bundle analysis",
          isCorrect: true,
        },
        { id: "b", text: "Use only JIT compilation", isCorrect: false },
        { id: "c", text: "Use only basic bundling", isCorrect: false },
        { id: "d", text: "Use only minification", isCorrect: false },
      ],
      explanation:
        "Advanced build optimization involves AOT compilation, tree shaking for dead code elimination, bundle analysis, and code splitting strategies.",
      category: "Build Optimization",
      difficulty: "hard" as const,
      tags: ["build", "tree-shaking", "optimization"],
      points: 3,
    },
    {
      id: "angular-senior-18",
      question: "How do you implement advanced deployment strategies with CI/CD?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use automated testing, staging environments, and blue-green deployments",
          isCorrect: true,
        },
        { id: "b", text: "Use only manual deployment", isCorrect: false },
        { id: "c", text: "Use only basic CI", isCorrect: false },
        { id: "d", text: "Use only CD", isCorrect: false },
      ],
      explanation:
        "Advanced deployment involves automated testing pipelines, staging environments, blue-green deployments, and comprehensive CI/CD strategies.",
      category: "Deployment",
      difficulty: "hard" as const,
      tags: ["deployment", "ci-cd", "automation"],
      points: 3,
    },
    {
      id: "angular-senior-19",
      question: "How do you implement advanced monitoring and analytics?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use error tracking, performance monitoring, and user analytics",
          isCorrect: true,
        },
        { id: "b", text: "Use only console.log", isCorrect: false },
        { id: "c", text: "Use only basic analytics", isCorrect: false },
        { id: "d", text: "Use only error tracking", isCorrect: false },
      ],
      explanation:
        "Advanced monitoring involves error tracking services, performance monitoring, user analytics, and comprehensive observability strategies.",
      category: "Monitoring",
      difficulty: "hard" as const,
      tags: ["monitoring", "analytics", "observability"],
      points: 3,
    },
    {
      id: "angular-senior-20",
      question: "How do you implement advanced code organization and architecture patterns?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use feature modules, barrel exports, and clean architecture principles",
          isCorrect: true,
        },
        { id: "b", text: "Use only basic modules", isCorrect: false },
        { id: "c", text: "Use only components", isCorrect: false },
        { id: "d", text: "Use only services", isCorrect: false },
      ],
      explanation:
        "Advanced architecture involves feature modules, barrel exports, clean architecture principles, and scalable code organization patterns.",
      category: "Architecture",
      difficulty: "hard" as const,
      tags: ["architecture", "organization", "patterns"],
      points: 3,
    },
    {
      id: "angular-senior-21",
      question: "How do you implement advanced data flow patterns with reactive programming?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use reactive streams, state management, and data flow optimization",
          isCorrect: true,
        },
        { id: "b", text: "Use only basic observables", isCorrect: false },
        { id: "c", text: "Use only subjects", isCorrect: false },
        { id: "d", text: "Use only promises", isCorrect: false },
      ],
      explanation:
        "Advanced reactive patterns involve complex data flows, state management with reactive streams, and optimized data flow architectures.",
      category: "Reactive Programming",
      difficulty: "hard" as const,
      tags: ["reactive", "data-flow", "streams"],
      points: 3,
    },
    {
      id: "angular-senior-22",
      question: "How do you implement advanced component communication patterns?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use services, observables, and advanced communication strategies",
          isCorrect: true,
        },
        { id: "b", text: "Use only @Input and @Output", isCorrect: false },
        { id: "c", text: "Use only ViewChild", isCorrect: false },
        { id: "d", text: "Use only EventEmitter", isCorrect: false },
      ],
      explanation:
        "Advanced component communication involves services with observables, complex parent-child communication, and sophisticated data sharing patterns.",
      category: "Component Communication",
      difficulty: "hard" as const,
      tags: ["communication", "services", "observables"],
      points: 3,
    },
    {
      id: "angular-senior-23",
      question: "How do you implement advanced animation and transition patterns?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use complex animations, route transitions, and performance optimization",
          isCorrect: true,
        },
        { id: "b", text: "Use only basic animations", isCorrect: false },
        { id: "c", text: "Use only CSS animations", isCorrect: false },
        { id: "d", text: "Use only simple transitions", isCorrect: false },
      ],
      explanation:
        "Advanced animations involve complex animation sequences, route transitions, performance optimization, and sophisticated UI interactions.",
      category: "Animations",
      difficulty: "hard" as const,
      tags: ["animations", "transitions", "performance"],
      points: 3,
    },
    {
      id: "angular-senior-24",
      question: "How do you implement advanced PWA features and offline capabilities?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use service workers, offline storage, and background sync",
          isCorrect: true,
        },
        { id: "b", text: "Use only basic PWA", isCorrect: false },
        { id: "c", text: "Use only manifest", isCorrect: false },
        { id: "d", text: "Use only basic caching", isCorrect: false },
      ],
      explanation:
        "Advanced PWA features involve service workers for offline functionality, background sync, push notifications, and comprehensive offline capabilities.",
      category: "PWA",
      difficulty: "hard" as const,
      tags: ["pwa", "offline", "service-workers"],
      points: 3,
    },
    {
      id: "angular-senior-25",
      question: "How do you implement advanced scalability and performance patterns?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use lazy loading, code splitting, and performance optimization strategies",
          isCorrect: true,
        },
        { id: "b", text: "Use only basic lazy loading", isCorrect: false },
        { id: "c", text: "Use only OnPush strategy", isCorrect: false },
        { id: "d", text: "Use only basic optimization", isCorrect: false },
      ],
      explanation:
        "Advanced scalability involves sophisticated lazy loading strategies, code splitting, performance optimization, and scalable architecture patterns.",
      category: "Scalability",
      difficulty: "hard" as const,
      tags: ["scalability", "performance", "optimization"],
      points: 3,
    },
    {
      id: "angular-senior-26",
      question: "How do you implement advanced debugging and development tools?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use Angular DevTools, debugging strategies, and development workflows",
          isCorrect: true,
        },
        { id: "b", text: "Use only console.log", isCorrect: false },
        { id: "c", text: "Use only basic debugging", isCorrect: false },
        { id: "d", text: "Use only browser dev tools", isCorrect: false },
      ],
      explanation:
        "Advanced debugging involves Angular DevTools, sophisticated debugging strategies, development workflows, and comprehensive debugging techniques.",
      category: "Debugging",
      difficulty: "hard" as const,
      tags: ["debugging", "devtools", "development"],
      points: 3,
    },
    {
      id: "angular-senior-27",
      question: "How do you implement advanced team collaboration and code quality?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use ESLint, Prettier, Husky, and comprehensive code quality tools",
          isCorrect: true,
        },
        { id: "b", text: "Use only basic linting", isCorrect: false },
        { id: "c", text: "Use only formatting", isCorrect: false },
        { id: "d", text: "Use only basic testing", isCorrect: false },
      ],
      explanation:
        "Advanced team collaboration involves ESLint, Prettier, Husky hooks, comprehensive code quality tools, and team development workflows.",
      category: "Code Quality",
      difficulty: "hard" as const,
      tags: ["code-quality", "collaboration", "tooling"],
      points: 3,
    },
    {
      id: "angular-senior-28",
      question: "How do you implement advanced documentation and knowledge sharing?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use JSDoc, Storybook, and comprehensive documentation strategies",
          isCorrect: true,
        },
        { id: "b", text: "Use only basic comments", isCorrect: false },
        { id: "c", text: "Use only README files", isCorrect: false },
        { id: "d", text: "Use only inline documentation", isCorrect: false },
      ],
      explanation:
        "Advanced documentation involves JSDoc comments, Storybook for component documentation, and comprehensive knowledge sharing strategies.",
      category: "Documentation",
      difficulty: "hard" as const,
      tags: ["documentation", "storybook", "jsdoc"],
      points: 3,
    },
    {
      id: "angular-senior-29",
      question: "How do you implement advanced maintenance and refactoring strategies?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use automated refactoring, code analysis, and maintenance workflows",
          isCorrect: true,
        },
        { id: "b", text: "Use only manual refactoring", isCorrect: false },
        { id: "c", text: "Use only basic maintenance", isCorrect: false },
        { id: "d", text: "Use only code reviews", isCorrect: false },
      ],
      explanation:
        "Advanced maintenance involves automated refactoring tools, code analysis, comprehensive maintenance workflows, and systematic refactoring strategies.",
      category: "Maintenance",
      difficulty: "hard" as const,
      tags: ["maintenance", "refactoring", "automation"],
      points: 3,
    },
    {
      id: "angular-senior-30",
      question: "How do you implement advanced enterprise patterns and best practices?",
      type: "multiple-choice" as const,
      options: [
        {
          id: "a",
          text: "Use enterprise architecture patterns, governance, and best practices",
          isCorrect: true,
        },
        { id: "b", text: "Use only basic patterns", isCorrect: false },
        { id: "c", text: "Use only simple architecture", isCorrect: false },
        { id: "d", text: "Use only basic practices", isCorrect: false },
      ],
      explanation:
        "Advanced enterprise patterns involve sophisticated architecture patterns, governance strategies, and comprehensive best practices for large-scale applications.",
      category: "Enterprise Patterns",
      difficulty: "hard" as const,
      tags: ["enterprise", "architecture", "governance"],
      points: 3,
    },
  ] as InteractiveQuizQuestion[],
} as const;
